The Dragon Hatchling: The Missing Link between the Transformer and Models of the Brain
1
Introduction
1.1
Motivation
Reconciling Reasoning Function of the Brain with Language Models.
Towards scale-free foreseeable AI.
Introducing Axiomatic AI.
1.2
Intuition of results: combining
modus ponens
reasoning with Hebbian learning
1.3
Contribution of this work
Language Models as Local Graph Dynamics.
A tensor-friendly case of BDH: the BDH-GPU architecture.
The bridge between the Transformer and Brain models.
Implications for learning dynamics of natural lifelong inference systems.
1.4
Notation
State-space models.
Models as programs.
Graphs and their dynamical systems interpretation.
2
BDH: a language model architecture given by local distributed graph dynamics
2.1
Formalism for local graph-based language models
Introduction to distributed graph systems.
Programmable rulesets and the interaction kernel.
Restricting the interaction kernel to spiking signals and graph systems.
Definition of the edge-reweighting kernel.
2.2
Definition of BDH as a local edge-reweighting process (equations of reasoning)
Inference dynamics of BDH.
Notes on training.
2.3
Interpretation of attention as a micro-inductive bias of reasoning
2.4
Interpretation of BDH as an oscillator network toy-model
Definition of the toy-model.
Effects captured by the toy-model.
2.5
Expressing BDH using brain models
3
BDH-GPU: a tensor-friendly version of the BDH architecture
3.1
Notation for BDH-GPU
Nonlinearities: ReLU and LayerNorm.
Activation vectors and parameter matrices.
3.2
Definition of BDH-GPU as a state-space system
BDH-GPU as a language model.
State-space representation.
3.3
Interpretation of BDH-GPU as a local interacting particle system
3.4
Expressing BDH-GPU using BDH: preserving parameter and state size
3.4.1
Expressing matrices
D
x
,
D
y
,
E
{D_{x}},{D_{y}},E
as graphs
G
x
,
G
y
{G_{x}},{G_{y}}
3.4.2
Expressing BDH-GPU attention on graphs: sparsification and trainability of
G
s
{G_{s}}
4
Implementation and scaling laws
4.1
Implementation characteristics of BDH-GPU
Model scaling in neuron dimension
n
n
.
Layers and heads.
Linear attention with state aligned to neurons.
Sparse positive activation.
4.2
Comparison of BDH-GPU to GPT2-like Transformers
Architecture differences.
Transformer-like scaling laws.
FLOPS counts.
4.3
Comparison of BDH-GPU to other sequence processing architectures
Transformers with Linear Attention.
Other types of Transformers.
Networks with sparse activation.
Oscillatory SSMâ€™s.
5
Analysis: emergence of modularity and scale-free structure
5.1
Background: modularity and scale-free property of systems
Importance of modularity for information propagation.
Scale-free property.
5.2
BDH-GPU feed-forward network with the â€˜ReLU-lowrankâ€™ block
Definition of ReLU-lowrank.
Expressiveness of ReLU-lowrank in BDH-GPU and MLP in the Transformer.
5.3
ReLU-lowrank as a signal propagation dynamics
Error of low-rank approximation (without ReLU).
Expressiveness of ReLU-lowrank for Markov chain propagation.
Propagation and reinforcement of signal.
5.4
Modularity in BDH-GPU signal propagation
Supermodularity on input perturbation.
5.5
Empirical findings: parameter distribution in ReLU-lowrank matrix products
Choice of prior of matrix parameter distributions.
Experimental setup.
Findings.
6
Analysis: linear attention, sparse positive activation, and monosemanticity
6.1
Macro-expressiveness of attention in BDH-GPU
Basic properties of BDH-GPU attention.
State capacity vs. distinction capacity.
Expressiveness of linear attention in dimension
n
n
.
Preparation of positive keys for Linear Attention.
Using LSH to move key vectors into the positive orthant.
Attention in the positive concept space of language and reasoning.
Natural support for long context.
6.2
Micro-interpretation of attention in BDH-GPU
6.3
Empirical findings: monosemantic synapses
6.4
Empirical findings: sparse neuron activations
7
Playing with the Hatchling
7.1
Model merging: concatenating two models
7.2
Training without backpropagation through time
8
Conclusions
8.1
Takeaways for model engineering
8.2
Implications for brain science
How this work helps with axiomatization of learning theory in the brain.
8.3
Societal impact
A
Connection between generalization of reasoning and computational expressiveness
B
Further description of experiments
B.1
Language translation task
B.2
BDH Scaling Experimental Details
B.3
BDH Monosemantic Synapse Experiment Details
B.4
BDH Merging Experiment Details
C
Omitted formal claims and proofs
C.1
Proof of Observation
1
C.2
Formal statement of Claim
7
(linear attention)
C.3
Proof of Claim
3
Considerations of building linear circuits.
C.4
Formal statement of Claim
4
D
Desirable properties of a local graph dynamics for language models
E
BDH-GPU PyTorch code listing
The Dragon Hatchling: The Missing Link
between the Transformer and Models of the Brain
Adrian Kosowski
Author contributions are listed at the end of the paper.Corresponding author.
PrzemysÅ‚aw UznaÅ„ski
2
2
footnotemark:
2
Jan Chorowski
2
2
footnotemark:
2
Zuzanna Stamirowska
2
2
footnotemark:
2
MichaÅ‚ Bartoszkiewicz
2
2
footnotemark:
2
Pathway, Palo Alto, USA
research@pathway.com
Abstract
The relationship between computing systems and the brain has served as motivation for pioneering theoreticians since John von Neumann and Alan Turing.
Uniform, scale-free biological networks, such as the brain, have powerful properties, including generalizing over time, which is the main barrier for Machine Learning on the path to Universal Reasoning Models.
We introduce â€˜Dragon Hatchlingâ€™ (BDH), a new Large Language Model architecture based on a scale-free biologically inspired network of
n
n
locally-interacting neuron particles. BDH couples strong theoretical foundations and inherent interpretability without sacrificing Transformer-like performance.
BDH is a practical, performant state-of-the-art
attention-based state space sequence learning architecture.
In addition to being a graph model, BDH admits a GPU-friendly formulation. It exhibits Transformer-like scaling laws: we find empirically that BDH rivals GPT2-architecture Transformer performance on language and translation tasks, at the same number of parameters (10M to 1B), for the same training data.
BDH provides theoretical foundations for understanding model behavior in the limit of large size and reasoning time.
Our results, formalized as a chain of reductions of expressiveness in the framework of computational Complexity Theory and Distributed Computing, and combined with findings on the BDH model, show a macro-to-micro correspondence of function between the general attention mechanisms in state-of-the-art Language Models, and attention mechanisms observed in the brain. These attention mechanisms formally converge as closed-form local graph dynamics at neurons and synapses: â€œthe equations of reasoningâ€.
BDH can be represented as a brain model. It contains
n
n
neurons, organized as an excitatory circuit and an inhibitory circuit with integrate-and-fire thresholding of input signals at neurons. The working memory of BDH during inference entirely relies on synaptic plasticity with Hebbian learning using spiking neurons, at potentiation scales of minutes for the brain (up to hundreds of tokens). We confirm empirically that specific, individual synapses strengthen connection whenever BDH hears or reasons about a specific concept while processing language inputs. The neuron interaction network of BDH is a graph of high modularity with heavy-tailed degree distribution. The BDH model is biologically plausible, explaining one possible mechanism which human neurons could use to achieve speech.
BDH is designed for interpretability. Activation vectors of BDH are sparse and positive. We demonstrate monosemanticity in BDH on language tasks, including representation of concept abstractions, which happens even for small models, below 100M-parameter scale. Interpretability of state, which goes beyond interpretability of neurons and model parameters, is an inherent feature of the BDH architecture.
We believe BDH opens the door to a new theory of â€œThermodynamic Limitâ€ behavior for language and reasoning models, with the ultimate goal of Probably Approximately Correct (PAC)-like bounds for generalization of reasoning over time.
âŠ³
\rhd
Technical blog entry:
https://pathway.com/research/bdh
.
âŠ³
\rhd
Code listings:
https://github.com/pathwaycom/bdh
.
Contents
1
Introduction
1.1
Motivation
1.2
Intuition of results: combining
modus ponens
reasoning with Hebbian learning
1.3
Contribution of this work
1.4
Notation
2
BDH: a language model architecture given by local distributed graph dynamics
2.1
Formalism for local graph-based language models
2.2
Definition of BDH as a local edge-reweighting process (equations of reasoning)
2.3
Interpretation of attention as a micro-inductive bias of reasoning
2.4
Interpretation of BDH as an oscillator network toy-model
2.5
Expressing BDH using brain models
3
BDH-GPU: a tensor-friendly version of the BDH architecture
3.1
Notation for BDH-GPU
3.2
Definition of BDH-GPU as a state-space system
3.3
Interpretation of BDH-GPU as a local interacting particle system
3.4
Expressing BDH-GPU using BDH: preserving parameter and state size
4
Implementation and scaling laws
4.1
Implementation characteristics of BDH-GPU
4.2
Comparison of BDH-GPU to GPT2-like Transformers
4.3
Comparison of BDH-GPU to other sequence processing architectures
5
Analysis: emergence of modularity and scale-free structure
5.1
Background: modularity and scale-free property of systems
5.2
BDH-GPU feed-forward network with the â€˜ReLU-lowrankâ€™ block
5.3
ReLU-lowrank as a signal propagation dynamics
5.4
Modularity in BDH-GPU signal propagation
5.5
Empirical findings: parameter distribution in ReLU-lowrank matrix products
6
Analysis: linear attention, sparse positive activation, and monosemanticity
6.1
Macro-expressiveness of attention in BDH-GPU
6.2
Micro-interpretation of attention in BDH-GPU
6.3
Empirical findings: monosemantic synapses
6.4
Empirical findings: sparse neuron activations
7
Playing with the Hatchling
7.1
Model merging: concatenating two models
7.2
Training without backpropagation through time
8
Conclusions
8.1
Takeaways for model engineering
8.2
Implications for brain science
8.3
Societal impact
A
Connection between generalization of reasoning and computational expressiveness
B
Further description of experiments
B.1
Language translation task
B.2
BDH Scaling Experimental Details
B.3
BDH Monosemantic Synapse Experiment Details
B.4
BDH Merging Experiment Details
C
Omitted formal claims and proofs
C.1
Proof of Observation
1
C.2
Formal statement of Claim
7
(linear attention)
C.3
Proof of Claim
3
C.4
Formal statement of Claim
4
D
Desirable properties of a local graph dynamics for language models
E
BDH-GPU PyTorch code listing
1
Introduction
Long reasoning and long context inference pose a severe challenge of generalization across scales of time. From vibe coding to market research, users of Language Models and agentic systems are increasingly relying on defining tasks through informal prompts, which the language model is expected to follow over long sequences of actions or decisions, like a reasonable human actor would. Implicitly, most users expect machines to follow the generalization patterns of human reasoning, i.e., to generalize reasoning in the same way as humans do. The complexity of tasks attempted in this way has gone from the equivalent of hours of human work for a single prompt, to weeks
(Emberson etÂ al.,
2025
)
. However, experimental evidence suggests that the Transformer and other state-of-the-art architectures do not systematically generalize chain-of-thought (CoT) reasoning to scenarios longer than the ones seen during training
(Shojaee etÂ al.,
2025
)
.
Chain-of-Thought reasoning models can be considered through the lens of computational complexity theory. For a Language Model to generalize human reasoning on a given class of tasks, we expect this model to be able to emulate the corresponding reasoning function of the human brain efficiently.
1
1
1
We provide a more formal explanation of this point in Appendix
A
.
While the Transformer with Chain-of-Thought is Turing-complete and can efficiently emulate certain restricted classes of formal languages
(Merrill and
Sabharwal,
2024
)
, this does not in itself provide a satisfactory answer as to how it emulates human reasoning. The human brain is an extremely complex graph-based distributed computing system with
n
â‰ˆ
8
â‹…
10
10
n\approx 8\cdot 10^{10}
neurons, and
m
>
10
14
m>10^{14}
neuron connections (synapses), of which a certain percentage is actively used. The direct simulation of such a distributed system by a Language Model through generic Turing-machine reductions would require billions of CoT tokens of the Language Model to represent a single step of reasoning in the brain. So, do Transformer-like models actually relate to brain function?
Such a relationship should follow more closely from a tighter, more direct simulation. Finding such a connection between Language Models and human brain function has, so far, proved elusive. Indeed, when comparing a tensor-based Language Model based on feed-forward network blocks and attention, to a uniform, scale-free graph-based distributed system, such as the brain, the two may, at first glance, appear very dissimilar.
This apparent dissimilarity of structure between Language Models and brain structure has been one of the main causes of concern in attempts to reconcile Computation and the Brain
(Olshausen,
2018
)
, as well as a cause of concern regarding the difficulty to foresee the behavior of autonomous AI systems.
In this paper, we show the link between the Transformer and Brain models.
1.1
Motivation
The development of Artificial Intelligence and the understanding of Neural Science have gone hand in hand since the 1940â€™s, both being efforts to understand the â€œmystery of intelligenceâ€. The relationship between computing systems and the brain served as motivation for the pioneering theoreticians such as John von NeumannÂ (
1958
), Alan TuringÂ (
1950
), Goeff HintonÂ (
2005
), Warren McCulloch and Walter PittsÂ (
1943
), and Horace BarlowÂ (
1972
).
Since then, milestones in Machine Learning around Artificial Neural Networks â€” using backpropagation with SGD
(Rumelhart etÂ al.,
1986
)
, followed by Deep Learning
(LeCun etÂ al.,
2015
)
, and the Attention mechanism
(Bahdanau etÂ al.,
2015
; Vaswani etÂ al.,
2017
)
â€” have split the â€œmystery of how intelligence worksâ€ into two. First, we still have no clear explanation for the micro-to-macro correspondence of the reasoning function of the brain. Second, we do not understand the correspondence between the artificial and natural systems â€” notably, how effects observed in the brain (emergent network; sparse activations; oscillatory phenomena; unknown relationship to backpropagation mechanisms) map into those which appear in systems based on dense tensors, trained using gradient back-propagation over time.
Reconciling Reasoning Function of the Brain with Language Models.
There is a seemingly deep divide between state-of-the-art language models, like the Transformer, and natural distributed systems with local graph dynamics, like those of the brain. Specifically, for the brain, we do not understand how the reasoning function emerges from neuronal dynamics at the microscale. For the Transformer, the interpretation of function is given at the level of vectors, but not at the level of particle dynamics or a uniform distributed computing system.
Language and reasoning are the key areas of higher-order brain function for which we do not yet have a complete understanding. Many other areas of brain function have been explained through analogies to Machine Learning architectures.
For example, the visual cortex is becoming well-understood, especially in its peripheral layers, and the observed inference dynamics are shown to have a correspondence to known Deep Learning architectures
(Mohsenzadeh etÂ al.,
2020
)
. The use of sparse coding by the brain was considered in the context of processing visual cues
(Olshausen and Field,
1997
)
, as well as for the olfactory systems
(Lin etÂ al.,
2014
)
. By contrast, higher-order cognitive functions of the association cortex of the human brain, such as language and reasoning, are among the least understood. A number of models provide partial explanations and have been verified at small scales. Some of the first attempts include explaining context-dependent computation in the prefrontal cortex using population dynamics of an RNN
(Mante etÂ al.,
2013
)
. Later approaches include the Tolman-Eichenbaum Machine
(Whittington etÂ al.,
2020
,
2022
)
, as well as a number of more recent works
(Papadimitriou etÂ al.,
2020
; Dabagia etÂ al.,
2024
; Mitropolsky and Papadimitriou,
2025
)
. One of the main stumbling blocks concerns going from spiking activation patterns at neurons, and localized attention effects at synapses, to a higher-order function, serving a reasoning purpose, efficiently organized at a scale of millions to billions of neurons.
Conversely, for Language Models architectures such as the Transformer, we miss a compact micro-interpretation as a distributed system. The expressiveness of the Transformer has been approximated using approaches from centralized computing and Complexity Theory, rather than from distributed systems. In the centralized perspective, a language model can be seen as a transformation function from inputs into outputs. The computational expressiveness of the Transformer architecture may then be approximated through frameworks based on RASP, such as RASP-L
(Zhou etÂ al.,
2024
)
or C-RASP
(Yang and Chiang,
2024
; Huang etÂ al.,
2025
)
. RASP-L provides a very convenient heuristic for estimating Transformer expressiveness at the rather coarse level of vector operations, while C-RASP provides a more specialized lower-bound on expressiveness, capturing a class of formulas of temporal counting logic. Both frameworks have been used to suggest theoretical models of task length generalization.
This type of expressiveness techniques, however, do not lead to a uniform asymptotic model for the behavior of the Transformer, whether in GPT2 architecture or simplified. The scaling of the Transformer in its different dimensions, and the need to manipulate context length, complicate this goal.
The lack of such a uniform model also makes it hard to compare the capabilities of the Transformer to the capabilities of the brain at the level of correspondence of structure. Generally, the temporal behavior of a state-space system is reflected in its structure
2
2
2
For a linear system, temporal behavior would be a direct consequence of the spectral properties of the system. The considered systems dynamics are not linear.
.
Understanding whether it is possible to show alignment of the temporal behavior of two systems, which do not display any structural correspondence, and without a clear idea of how the weight tensors and state representation of one system â€˜embedâ€™ into the graph structure and state representation of the other system, is an awkward task.
This brings us naturally to our motivational objective: Can we create Machine Learning models which are closer to the desirable properties of natural (human) reasoning systems, and which exhibit the same types of limit and scaling behavior as such natural systems?
Towards scale-free foreseeable AI.
Ensuring correct scaling behavior of inference over time is of paramount importance for the deployment of AI whose reasoning or actions are not subject to strict human supervision. Most reasoning models and AI agentic systems admit limit objects (i.e., extensions to infinite time and infinite size) which are Turing-complete (cf.Â e.g.
(Merrill and
Sabharwal,
2024
; PÃ©rez etÂ al.,
2021
; Jojic etÂ al.,
2023
)
). This means that they should be treated like computer programs â€” and should be approached by the users with the same standards of care, as a computer program of unknown origin and unknown purpose.
An AI model can malfunction when allowed to run for a long time autonomously, i.e., without human validation of actions and reasoning outcomes. The most painful of all consequences, perhaps, is the concept of a failed generalization of reasoning (a malfunction with respect to the original task objective) over time, leading to a grotesque effect known as the â€œPaperclip Factoryâ€
(Bostrom,
2014
)
.
Can the risk of such unsuccessful generalization be bounded?
There are at least two scenarios in which a black-box model
M
M
cannot be considered to have undergone previous empirical validation, and consequently cannot be used in higher-risk autonomous AI use cases.
1.
Length-generalization scenario: Model
M
M
is expected to act autonomously on a task which is longer than tasks forming part of its validation set.
2.
Model scaling scenario: Model
M
M
is not exactly the same closed system as the one which was tested during validation. For example, suppose that models
M
1
M_{1}
and
M
2
M_{2}
were tested individually on smaller tasks, and let
M
M
be an agentic system composed of instances of
M
1
M_{1}
and
M
2
M_{2}
which communicate with exchange messages with each other during inference.
A natural way of avoiding both difficulties consists in studying systems which are scale-free with respect to size and time, and admit a form of uniform â€œthermodynamic limitâ€ behavior. The limit behavior of computational systems at criticality naturally connects the size of the system with the probable duration of its operation, with the connection usually taking polynomial form (cf.Â e.g.
(BjÃ¶rner etÂ al.,
1991
; Cairns,
2018
; Rolla,
2020
)
for examples of graph-based interacting particle systems for which rigorous results have been obtained in this direction). Consider a model
M
n
M_{n}
with architecture
ğ’œ
\mathcal{A}
, parameterized by its size
n
n
(with the interpretation of the number of uniform particles), and sampled from some space of
n
n
-neuron models in architecture
ğ’œ
\mathcal{A}
in some space equipped with a probability measure,
M
n
âˆ¼
ğ’«
ğ’œ
â€‹
(
n
)
M_{n}\sim\mathcal{P}_{\mathcal{A}}(n)
. Informally, if the limit object
ğ’«
ğ’œ
:=
lim
n
â†’
âˆ
ğ’«
ğ’œ
â€‹
(
n
)
\mathcal{P}_{\mathcal{A}}:=\lim_{n\to\infty}\mathcal{P}_{\mathcal{A}}(n)
exists (under an appropriate, well-defined sense of uniformity of limit) then models
M
n
M_{n}
, for
n
n
sufficiently large, will admit in the limit asymptotic properties, which can be used to characterize their behavior over time.
The existence of such a limit theory means that we can characterize, with bounded probability of error, the behavior of a family of large models, having
O
â€‹
(
n
)
O(n)
parameters, while relying on a theory which is independent of the specific structure and size of the specific model. In this way, the limit behavior of a system of a very large number of interacting uniform particles over time becomes (stochastically) foreseeable in the sense of its adherence to expected behavior, which can be extrapolated from observations at shorter time scales. Thus, small tests may be conceived in order to provide validation for a scale-free system at long time scales.
Introducing Axiomatic AI.
Axiomatic systems are those in which micro-foundations and the macro-description which arises from them are consistent and well-understood. The need for axiomatic understanding was highlighted by David HilbertÂ (
1902
), and has become the foundation in Statistical Physics (e.g.Â thermodynamics, fluid dynamics, spin glass theory), cellular mechanisms, Social Networks Science, and reconciliation of Microeconomics and Macroeconomics through a Network Economics perspective.
This paper brings a micro-foundational understanding to Language Model inference, to the mechanisms of in-context learning, and Chain-of-Thought reasoning dynamics.
The considerations in this work naturally support a shift of perspective from
Interpretable AI
, which gives an approximate understanding of what the model is doing now (without necessarily telling us what its current actions are going to lead to over longer time scales), to
Axiomatic AI
, where we also understand the micro-foundations of how the model can be expected to behave subsequently over time.
1.2
Intuition of results: combining
modus ponens
reasoning with Hebbian learning
In this section we provide the reader with some of the main intuitions behind this work which, we hope, will help to navigate the remaining, more formal parts of this paper with ease.
While there are many formal deductive systems in logic, they predominantly rely on the
modus ponens
inference rule. Applied to a rule-based reasoning system, it takes the following form:
If we know that the
i
i
-th fact is true, and our ruleset
Ïƒ
\sigma
indicates that the
i
i
-th fact implies the
j
j
-th fact, then we know that the
j
j
-th fact is true as well. In an approximate reasoning system, the strength of the rule
Ïƒ
â€‹
(
i
,
j
)
\sigma(i,j)
indicates how the belief
X
â€‹
(
i
)
X(i)
of the system affects its belief
A
â€‹
(
j
)
A(j)
. We could write:
X
â€‹
(
i
)
,
Ïƒ
â€‹
(
i
,
j
)
â†’
A
â€‹
(
j
)
,
X(i),\sigma(i,j)\xrightarrow{}A(j),
(1)
to indicate that if
X
â€‹
(
i
)
X(i)
is a weighted belief, it contributes
X
â€‹
(
i
)
â€‹
Ïƒ
â€‹
(
i
,
j
)
X(i)\sigma(i,j)
to the systemâ€™s belief
A
â€‹
(
j
)
A(j)
.
Practical logical inference systems differ in strategies employed for rule selection, with the most advanced ones allowing direct manipulation of the ruleset, effectively resulting in a form of program evolution during inference
3
3
3
The authorsâ€™ personal experience with writing efficient Prolog programs confirms that such direct ruleset management is often a necessary pragmatic evil, guiding the inference system in the right direction.
. For an approximate reasoning system, such a heuristic could manipulate the strength of rules, modulating the impact of belief
X
â€‹
(
i
)
X(i)
on the systemâ€™s belief
A
â€‹
(
j
)
A(j)
.
Hebbian learning
(Hebb,
1949
)
, often presented as the mnemonic â€œ
Neurons that fire together wire together
â€, can be seen as a heuristic for ruleset manipulation. It postulates that synaptic connections are strengthened when the activity of one neuron,
Y
â€‹
(
i
)
Y(i)
, led to the firing of another neuron,
X
â€‹
(
j
)
X(j)
. In the context of an adaptive, approximate inference system, the Hebbian heuristic means that if during the course of operation a fact
i
i
contributed some evidence for
j
j
, the system increases the significance of the implication
Ïƒ
â€‹
(
i
,
j
)
\sigma(i,j)
. We could write this rule as:
Y
â€‹
(
i
)
,
X
â€‹
(
j
)
â†’
Ïƒ
â€‹
(
i
,
j
)
,
Y(i),X(j)\xrightarrow{}\sigma(i,j),
(2)
with the interpretation that co-presence (or a spike) of
Y
â€‹
(
i
)
Y(i)
followed by
X
â€‹
(
j
)
X(j)
increases
Ïƒ
â€‹
(
i
,
j
)
\sigma(i,j)
by
Y
â€‹
(
i
)
â€‹
X
â€‹
(
j
)
Y(i)X(j)
.
The relations (
1
) and (
2
), over a set of
n
n
facts, may form the basis of a simple approximate reasoning system that adapts its operation to the problem at hand. Starting with some initial connections between facts, the system applies the rules to discover new facts, at the same time reweighting the ruleset in a way that strengthens the connections between the initial and derived facts. Effectively, should the system be rerun with the new ruleset, it would arrive at similar conclusions faster.
Suppose now that the reasoning system is equipped with two sets of rules: a fixed set
G
G
and an evolving set
Ïƒ
\sigma
. From a machine learning perspective, the fixed ruleset
G
G
can be seen as model weights in Deep Learning terminology, learned using e.g. error backpropagation on a training set. On the other hand, the evolving ruleset can be seen as the temporal state of the reasoning system, sometimes called â€œfast weightsâ€
(Hinton and Plaut,
1987
; Schmidhuber,
1993
; Ba etÂ al.,
2016a
)
. Fast-weights systems have a favorable ratio of state size to parameter count. A system with
n
n
facts has
m
=
O
â€‹
(
n
2
)
m=O(n^{2})
trainable parameters (expressed using one or more
n
Ã—
n
n\times n
matrices). A classical recurrent neural net, such as the LSTM
(Hochreiter and Schmidhuber,
1997
)
, treats individual fact (neuron) activations as its state, thus maintaining only
O
â€‹
(
n
)
O(n)
state variables. On the other hand, the evolving set of fast-weights
Ïƒ
\sigma
has
m
=
O
â€‹
(
n
2
)
m=O(n^{2})
state entries. We believe this 1-1 ratio of trainable parameter to state size is important in designing practical reasoning systems and may justify the success of the Transformer
(Vaswani etÂ al.,
2017
)
and state-space
(Gu and Dao,
2024
)
sequence processing models.
Now, bearing in mind that the trainable parameters and state have comparable size
m
m
, we can adjust the ratio between this value
m
m
and the size
n
n
of the fact base. This will happen through a choice of sparsity for the
n
Ã—
n
n\times n
matrices carrying parameters and state, resulting in a specific relationship of the two values,
n
â‰ª
m
â‰ª
n
2
n\ll m\ll n^{2}
. In this way, our system gets a natural interpretation in terms of graphs on
n
n
nodes and
m
m
edges, with the graph edges tasked with their first two roles: carrying state, and, carrying trainable parameters. Finally, we will give our system an interpretation of a dynamical system with distributed (localized) dynamics, and we will task our edges with their third crucial role: mediating in communication between nodes of the system. In this way, through assimilation of edges to natural function in the brain, we will refer to the
m
m
edges as
synapses
connecting a set of
n
n
neurons
into a distributed graph-based system.
In the following Section
2
, we will introduce BDH, a reasoning system that formalizes and combines relations (
1
) and (
2
) with dynamics involving fixed rules. The BDH system:
1.
is a reasoning system, efficiently using the
modus ponens
reasoning rule with heuristic rule reweighting, based on (
1
) and (
2
),
2.
can be implemented with local graph dynamics, making it suitable for brain-like execution model, and amenable to a principled, axiomatic description,
3.
contains a set of fixed connections (parameters), and a set of dynamically adjusted connections (
Ïƒ
\sigma
), which can be seen as its dynamic state updated with a Hebbian learning rule,
4.
admits as its special case BDH-GPU, a GPU-efficient reasoning model architecture, introduced in Section
3
and experimentally validated at scale in Section
7
in direct comparison to state-of-the-art GPT2-like Transformers.
1.3
Contribution of this work
The focus of this paper is in explaining the dynamics of the primary function of language and reasoning models: inference. We provide a description of a language model architecture which is directly comparable to the Transformer, and admits a clear and interpretable local interpretation of its inference dynamics as a programmable interacting particle system.
Language Models as Local Graph Dynamics.
In Section
2
, we introduce a graph-based model architecture called
BDH
, where all model parameters are represented as topology and weights of the communication graph, and model state during inference is represented as edge-reweighting applied to this graph topology.
Claim 1
(informal overview of theoretical results for BDH)
.
We introduce a state-space Machine Learning architecture called BDH, formed by a system of
n
n
particles called neurons which communicate in a way governed by the weights and topology of the system graph, representing a â€œcommunication by wireâ€ network.
â€¢
The inference dynamics of BDH, treated as a distributed system, can be represented as execution of local rulesets for
n
n
particles with programmable interactions, with particles acting as nodes of the interaction graph and scalar state variables located on its edges (cf.Â Section
2.2
).
â€¢
The local kernel of BDH can be naturally expressed (emulated) by a graph-based Spiking Neural Network system capable of Hebbian learning dynamics, an Excitatory circuit, and an Inhibitory circuit on an
n
n
-neuron system described by a neuron interaction graph (cf.Â Section
2.5
).
In order to train BDH efficiently and analyze its performance, we restrict it, making this restriction the core of a GPU-friendly architecture called
BDH-GPU
. This restriction is obtained by treating the communication of the
n
n
particles as proceeding through a mean-field (â€œradio networkâ€), rather than a graph (â€œcommunication by wireâ€), cf.Â Fig.
3
for an explanation of how the state-space equations of BDH-GPU are obtained from BDH.
This allows us to train a mathematically equivalent model, while localizing its state in short vectors at neurons, not at connections (synapses) of the system.
A tensor-friendly case of BDH: the BDH-GPU architecture.
The BDH-GPU architecture, like the Transformer, crucially relies on an attention mechanism, and is amenable to token-parallel training on GPU for next token prediction tasks. Unlike the Transformer, activation vectors of BDH-GPU appear in a very high dimension
n
n
, are positive by design, and turn out to be sparse.
Claim 2
(informal overview of theoretical results for BDH-GPU)
.
We introduce a Machine Learning architecture called BDH-GPU, parameterized by a single (very large) scaling parameter
n
n
and a second parameter
d
d
,
log
â¡
n
<
d
â‰ª
n
\log n<d\ll n
(
d
=
256
d=256
in practice), such that:
â€¢
A model in BDH-GPU
(
n
,
d
)
(n,d)
has
(
3
+
o
â€‹
(
1
)
)
â€‹
n
â€‹
d
(3+o(1))nd
parameters, and admits a precise interpretation as a state-space system following the local dynamics of a
n
n
-particle system in an interaction field subject to equations of stateÂ (
8
). This system is described by
O
â€‹
(
d
)
O(d)
parameters per particle, whose interaction field has mean field interpretation, which in a computational view corresponds to a particle communication network realized by means of â€œnoisy radio broadcastâ€.
â€¢
BDH-GPU is a special case of BDH in the sense that, for any BDH-GPU model with
n
n
particles, there exists a BDH model with
n
n
particles with the same inference behavior and the same size
O
â€‹
(
n
â€‹
d
)
O(nd)
of trainable parameters, with the two models being formally equivalent up to placement of Layer Norms (cf.Â Claims
3
and
4
).
â€¢
The BDH-GPU architecture relies on a combination of two blocks: a specific kind of
ReLU-lowrank
feed-forward network, and a
linear attention
mechanism, which both operate in the same neuron dimension
n
n
, using positive activation vectors.
â€¢
The mechanisms of BDH-GPU, considered at the macro-level of activation vectors in
R
n
R^{n}
, can be compared to those of the Transformer (cf.Â Section
6.1
, Section
5.2
). This justifies the applicability of the frameworks of approximate macro-expressiveness, based on RASP
(
Weiss etÂ al.
,
2021
; Zhou etÂ al.
,
2024
; Yang and Chiang
,
2024
)
and designed for the Transformer, to BDH-GPU.
â€¢
The micro-interpretation of BDH-GPU mechanisms as neuron-neuron interaction dynamics: (1) explains mechanisms of in-cluster communication of neurons and the spontaneous emergence of graph structure with high Newman modularity in the neuron-neuron communication network (cf.Â Section
5
), and (2) provides a strict correspondence between the macro-mechanism of in-context inference based on attention and the local representation of state on individual neuron-neuron pairs (synapses) with state update dynamics based on sporadic updates to synaptic edge weight (cf.Â Section
6
).
The above results are complemented by empirical findings.
Empirical Finding 1
(informal overview of empirical results of BDH-GPU)
.
BDH-GPU is represented as a tensor-based architecture and can be trained with standard back-propagation methods (cf.Â Section
3
).
â€¢
The BDH-GPU architecture is shown to follow scaling laws (parameters vs. loss) of optimized Transformers in the GPT architecture, at parameter scales between 10M to 1B, on all next token prediction tasks we tested, including tasks of language and translation reminiscent of those in the original benchmark set for the Transformer architecture (cf.Â Section
4.2
).
â€¢
An emergent network reflecting the associated BDH graph dynamics can be read out directly from the parameter matrices of a trained BDH-GPU model, showing emergence of graph structureÂ (cf.Â Section
5.5
).
â€¢
The positive activations of BDH-GPU exhibit sparsity (at about 5% level) in the
y
y
vectors of its state space dynamics, with sparsity levels reflecting the amount of activity being performed by BDH-GPU for a given tokenÂ (cf.Â Section
6.2
).
â€¢
In-context state of BDH-GPU attention is shown to localize on the same synapses (neuron-neuron links) consistently across multiple prompts, allowing for some basic features, the interpretation of the current in-context state based on the reading of state of an individual synapse associated with such a feature (cf.Â Section
6.3
).
A more detailed discussion of the training approach is provided in Appendix
B.2
, while the code listing for BDH-GPU is provided in Appendix
E
. For the purposes of our experiments, we did not apply any specific training method which would be known to guide the system towards any of the observed emergent properties. (In particular, L1-regularization was disabled.) The observed emergent effects follow naturally from the design choices of the BDH and BDH-GPU architectures, and are largely attributable to the combination of: the choice of model dimensions with comparable model-to-state ratio, reliance on linear attention in high dimension, reliance on ReLU thresholds for ensuring that activation vectors are positive (trivially) and sparse (an effect empirically noted in
(Haziza etÂ al.,
2025
)
).
We also remark that the BDH-GPU architecture allows for the uniform asymptotic scaling of the model in one dimension,
n
n
. For example, a composition of models, obtained by concatenation, is also model in the same architecture, with a larger value of
n
n
(cf.Â Section
7.1
for an empirical study of this effect for practical translation tasks).
Historically, a link has been established between infinitely wide feedforward networks and Gaussian Processes
(Neal,
2012
; Lee etÂ al.,
2017
; Yang,
2019
)
. BDH allows the study of limit behavior of reasoning models.
With BDH and BDH-GPU, we show that Language Models can be amenable to a particle-based interpretation. In fact, two micro-foundations â€” particle-based behavior and logic-programming behavior of a reasoning system â€” fuse together in these architectures.
The bridge between the Transformer and Brain models.
The inference dynamics of BDH and BDH-GPU act as a natural bridge between Transformer, and neuromorphic models of the brain and its subsystems. We illustrate this in Fig.
1
.
Figure 1:
General overview of architectures and their relationships: the inference dynamics of BDH and BDH-GPU act as a natural bridge between Transformer and models of the brain. The two main inference mechanisms of a reasoning architecture, attention and the feed-forward network, are defined at a macro-level through tensor operations for the Transformer, and at the micro-level of neuron interactions through local graph dynamics for Brain models. The new BDH-GPU architecture is naturally defined both at the level of vectors and of particle dynamics of neurons and synapses, acting as a bridge between these two approaches. See also Table
3
at the end of the paper for a more detailed comparison of architecture properties.
Implications for learning dynamics of natural lifelong inference systems.
A lifelong learning system progresses in time, performing extremely rapid inference, combined with several training mechanisms at different time scales.
In this work, we provide and validate at scale a plausible explanation of what the
predominant
dynamics of such a system could look like, taking the system from â€˜split-secondâ€™ scale, to the scale of inference during â€˜minutesâ€™, considering the flow of time at the natural rate of thought and language for humans.
A complementary discussion of learning dynamics would aim to provide an explanation of how to take such a lifelong inference system from the scale of â€˜minutesâ€™ into even longer timescales. This would concern the slower transfer of â€œfast-weightsâ€-like inference state to long-term memory, starting at the order of
10
3
10^{3}
â€”
10
4
10^{4}
tokens, and taking into account feedback signals. In this work, we do not provide a direct answer as to how the brain actually handles this effect at longer timescales. However, a constructive way to resolve this problem seems to be less challenging, once the local inference dynamics of the brain are better understood (we come back to this in the Conclusions). The modeling approach provided in Section
2.5
is proposed as a suitable framework for such a study.
1.4
Notation
State-space models.
For describing inference dynamics of any system, we will use state-space notation, and consider a state-space system composed of two parts: a set of
model parameters
M
M
which does not change during inference, and a
state
Ïƒ
â€‹
(
t
)
\sigma(t)
which changes during inference. The model performs inference following state-space equation
Ïƒ
â€‹
(
t
+
1
)
:=
ğ’œ
â€‹
(
M
,
Ïƒ
â€‹
(
t
)
,
a
t
)
\sigma(t+1):=\mathcal{A}(M,\sigma(t),a_{t})
, where
a
t
a_{t}
is a possible external input to the system at time
t
t
(such as a language token),
t
=
0
,
1
,
2
,
â€¦
t=0,1,2,\ldots
, and
ğ’œ
\mathcal{A}
is referred to as the
architecture
ğ’œ
\mathcal{A}
which drives its progress. During inference without external input, usually autoregressive inference, we will shorten this to
Ïƒ
â€‹
(
t
)
:=
ğ’œ
t
â€‹
(
M
,
Ïƒ
0
)
\sigma(t):=\mathcal{A}^{t}(M,\sigma_{0})
.
Models as programs.
In settings that are of interest to us (inference with combining multiple facts, reasoning), we opt for terminology from computing.
M
M
has the interpretation of a computer program code,
ğ’œ
\mathcal{A}
has the interpretation of a computational machine architecture which runs it, and
Ïƒ
\sigma
has the interpretation of the variable state of the program. We will use the terms â€˜model
M
M
â€™ and â€˜program
M
M
â€™ interchangeably.
Graphs and their dynamical systems interpretation.
For a square matrix with non-negative coefficients,
H
âˆˆ
(
â„
+
)
n
,
n
H\in(\mathbb{R}^{+})^{n,n}
,
n
âˆˆ
â„•
n\in\mathbb{N}
, we will consider two more equivalent representations. In one, we will treat
H
H
as a graph defined on some nodeset
V
V
, with
V
=
|
n
|
V=|n|
. Formally, we can take
V
=
{
e
1
,
â€¦
,
e
n
}
V=\{e_{1},\ldots,e_{n}\}
, where
e
i
=
(
0
,
â€¦
,
0
,
1
,
0
â€‹
â€¦
,
0
)
âˆˆ
â„
n
Ã—
1
e_{i}=(0,\ldots,0,1,0\ldots,0)\in\mathbb{R}^{n\times 1}
with
1
1
on the
i
i
-th position, forming an orthonormal basis. Non-zero entries of
H
H
are referred to as
edges
. By an overloading of notation, we will write
H
â€‹
(
i
,
j
)
:=
e
j
T
â€‹
H
â€‹
e
i
â‰¥
0
H(i,j):={e_{j}}^{T}H{e_{i}}\geq 0
, to represent the node affinity function, or
edge weight
, from
i
i
to
j
j
. We define the
edge set
E
â€‹
(
H
)
:=
{
(
i
,
j
)
âˆˆ
V
Ã—
V
:
H
â€‹
(
i
,
j
)
>
0
}
E(H):=\{(i,j)\in V\times V:H(i,j)>0\}
.
In discussions of graph-based model architectures, we will take the standard interpretation of graphs from a linear dynamical systems perspective, applied to positive vectors. When
v
âˆˆ
(
â„
+
)
n
Ã—
1
v\in(\mathbb{R}^{+})^{n\times 1}
is a non-negative vector,
H
â€‹
v
âˆˆ
(
â„
+
)
n
Hv\in(\mathbb{R}^{+})^{n}
has the interpretation of a linear transformation of
v
v
. If
H
H
satisfies the condition of stochasticity (column-normalization to
1
1
), then
v
â†¦
H
â€‹
v
v\mapsto Hv
is a Markov chain transition, with
â€–
H
â€‹
v
â€–
1
=
â€–
v
â€–
1
\|Hv\|_{1}=\|v\|_{1}
. From a distributed systems perspective, transitions of stochastic matrices can be represented either through the direct simulation of (probabilities) of such a Markov chain, or described by the token dynamics of an extremely simple stochastic token distribution scheme in which a token located at node
e
i
e_{i}
goes to node
e
j
e_{j}
with probability
H
â€‹
(
i
,
j
)
H(i,j)
. If
H
H
is not stochastic, the operation
v
â†¦
H
â€‹
v
v\mapsto Hv
additionally necessitates the suppression of a fraction of tokens, or the multiplication of tokens, at each step at each node, depending on the column-normalization of a given node.
4
4
4
We provide a graph distributed systems interpretation only for dynamics on graphs with non-negative matrix entries (positive-weight edges). Negative-weight edges are hard to represent using natural local dynamics based on token distribution or spiking models.
For two graphs
H
1
,
H
2
âˆˆ
â„
n
Ã—
n
H_{1},H_{2}\in\mathbb{R}^{n\times n}
, the graph
H
=
H
2
â€‹
H
1
H=H_{2}H_{1}
is obtained through (linear algebraic) matrix multiplication, and in a distributed system, the corresponding transition
v
â†¦
H
â€‹
v
v\mapsto Hv
is obtained with two steps of token dynamics, one following graph
H
1
H_{1}
, the next following graph
H
2
H_{2}
.
Representing
m
m
edge-weights of a sparse
n
n
-node graph with
b
b
bits of numerical precision per parameter is possible with
O
â€‹
(
m
â€‹
(
b
+
log
â¡
n
)
)
O(m(b+\log n))
bits of information, which corresponds to
O
â€‹
(
m
â€‹
(
1
+
log
â¡
n
b
)
)
O(m(1+\frac{\log n}{b}))
parameters. For the sake of simplicity, we will assume in asymptotics that the second term of the sum does not dominate (i.e.,
log
â¡
n
=
O
â€‹
(
b
)
\log n=O(b)
), and so we simply say that we represent the graph with
O
â€‹
(
m
)
O(m)
parameters.
2
BDH: a language model architecture given by local distributed graph dynamics
2.1
Formalism for local graph-based language models
We consider model architectures
ğ’œ
\mathcal{A}
which correspond to models of graph-based distributed computing (cf.
(Peleg,
2000
; Hirvonen and Suomela,
2025
)
). A specific model
M
M
in architecture
ğ’œ
\mathcal{A}
corresponds to the weights and topology of the communication graph or graphs used by such a system.
Introduction to distributed graph systems.
The distributed system architecture
ğ’œ
\mathcal{A}
, representing the model architecture, is defined through a
scheduler
, and a local dynamics (
kernel
K
â€‹
(
ğ’œ
)
K(\mathcal{A})
) describing the local computations to be performed at each node of the system, and, communication between pairs of nodes connected by edges of the graph representing a given model
M
M
.
We will generally accept that computations are performed only at
n
n
neuron nodes (particles), whereas state variables of the system may appear both on nodes and edges. We will, for simplicity of analysis, consider systems governed by a
synchronous scheduler
, which in successive rounds, acts in two sub-rounds:
1.
Computation:
computations of the kernel of
ğ’œ
\mathcal{A}
are run at all neuron nodes independently.
2.
Communication â€œover wireâ€
: each neuron node sends specified â€˜output variablesâ€™ to specified â€˜input variablesâ€™ of its neighboring neurons.
We expect the scheduler to follow the same communication pattern between neurons over time in a uniform way. In order to avoid artificial constructions of cyclic time-counters at nodes, we will define the architecture kernel through a short sequence of kernels, with the scheduler executing them in successive rounds in round-robin manner. Specifically, when
ğ’œ
\mathcal{A}
is BDH, we will have a sequence of four kernels,
K
â€‹
(
ğ’œ
)
=
(
K
1
â€‹
(
ğ’œ
)
,
K
2
â€‹
(
ğ’œ
)
,
K
3
â€‹
(
ğ’œ
)
,
K
4
â€‹
(
ğ’œ
)
)
K(\mathcal{A})=(K_{1}(\mathcal{A}),K_{2}(\mathcal{A}),K_{3}(\mathcal{A}),K_{4}(\mathcal{A}))
, with
K
i
â€‹
(
ğ’œ
)
K_{i}(\mathcal{A})
being executed in every round
r
r
such that
r
â‰¡
i
â€‹
mod
â€‹
4
r\equiv i\textrm{\, mod \, }4
.
Programmable rulesets and the interaction kernel.
We recall from Section
1.4
that a model architecture
ğ’œ
\mathcal{A}
has the interpretation of a computational machine architecture, and models
M
M
have the interpretation of programs in architecture
ğ’œ
\mathcal{A}
. We also recall that a graph-based model
M
M
is defined through a set of parameters which represent the topology and weights of the communication graph of the system.
The above considerations lead directly to the following observation:
The graph of the communication network, which is used for communication between sites by the distributed system architecture
ğ’œ
\mathcal{A}
during reasoning and language inference, has the interpretation of a (trainable, rule-based) program.
Consequently, we embed the subsequent definition of BDH in a kernel formalism, given through a form of
programmable rulesets
, using two-particle interaction rules on a graph.
5
5
5
We refer the reader to Appendix
D
for a more principled background discussion, guiding the appropriate choice of formalism for rule-based local interaction.
The rulesets which we will use to define BDH will closely resemble rulesets (protocols) known from evolutionary and population dynamics
(Hofbauer and Sigmund,
1998
; Angluin etÂ al.,
2006
; Aspnes and Ruppert,
2009
)
and chemical reaction networks
(Chen etÂ al.,
2014
; Feinberg,
2019
)
, however, they will be restricted to a special class of interactions.
We start by presenting the more general form of this
interaction kernel
. We then explain how such a kernel can be restricted, allowing it to be naturally implemented using a local graph-based distributed system (in particular, one relying spiking dynamics), while remaining sufficiently expressive to describe an attention-based language model. The resulting restriction will be called the
edge-reweighting kernel
.
Definition 1
(Interaction kernel, general form)
.
A system with
z
z
species,
z
âˆˆ
â„•
z\in\mathbb{N}
, and state
(
q
1
,
â€¦
,
q
z
)
âˆˆ
Q
(q_{1},\ldots,q_{z})\in Q
,
q
i
âˆˆ
R
+
q_{i}\in R^{+}
, performs the
interaction kernel with a ruleset (protocol)
P
P
given by a set of transition rates called
rule weights
,
P
=
(
(
r
i
â€‹
j
â€‹
k
âˆˆ
R
+
)
i
,
j
,
k
âˆˆ
{
1
â€‹
â€¦
,
z
}
,
(
d
k
âˆˆ
R
+
)
k
âˆˆ
{
1
â€‹
â€¦
,
z
}
)
P=((r_{ijk}\in R^{+})_{i,j,k\in\{1\ldots,z\}},(d_{k}\in R^{+})_{k\in\{1\ldots,z\}})
, producing the following transition from a state
(
q
1
,
â€¦
,
q
z
)
âˆˆ
Q
(q_{1},\ldots,q_{z})\in Q
to a state
(
q
1
â€²
,
â€¦
,
q
z
â€²
)
âˆˆ
Q
(q^{\prime}_{1},\ldots,q^{\prime}_{z})\in Q
:
q
k
â€²
:=
(
1
âˆ’
d
k
)
â€‹
q
k
+
âˆ‘
i
,
j
r
i
â€‹
j
â€‹
k
â€‹
q
i
â€‹
q
j
q_{k}^{\prime}:=(1-d_{k})q_{k}+\sum_{i,j}r_{ijk}q_{i}q_{j}
(3)
We will describe such a ruleset
P
P
using the notational form:
P
=
(
{
â€˜
â€‹
â€˜
â€‹
q
i
,
q
j
â†’
r
i
â€‹
j
â€‹
k
q
k
â€‹
â€
}
i
,
j
,
k
âˆˆ
{
1
â€‹
â€¦
,
z
}
,
{
â€˜
â€‹
â€˜
â€‹
q
k
â†“
d
k
â€
}
k
âˆˆ
{
1
â€‹
â€¦
,
z
}
)
.
P=(\{``q_{i},q_{j}\xrightarrow{r_{ijk}}q_{k}"\}_{i,j,k\in\{1\ldots,z\}},\{``q_{k}\downarrow_{d_{k}}\!\!"\}_{k\in\{1\ldots,z\}}).
As a matter of convention, omitted rules correspond to
r
i
â€‹
j
â€‹
k
=
0
r_{ijk}=0
(respectively,
d
k
=
0
d_{k}=0
), while rules with no rate value stated next the pointer correspond to
r
i
â€‹
j
â€‹
k
=
1
r_{ijk}=1
(respectively,
d
k
=
1
d_{k}=1
). If
q
j
q_{j}
is omitted from notation on the left-hand side, we assume
q
j
=
1
q_{j}=1
.
EquationÂ (
3
) captures the dynamics of the following differential equation:
d
â€‹
q
k
d
â€‹
t
=
âˆ’
d
k
â€‹
q
k
+
âˆ‘
i
,
j
r
i
â€‹
j
â€‹
k
â€‹
q
i
â€‹
q
j
\frac{dq_{k}}{dt}=-d_{k}q_{k}+\sum_{i,j}r_{ijk}q_{i}q_{j}
. Assuming
q
i
,
q
j
,
r
i
â€‹
j
â€‹
k
âˆˆ
[
0
,
1
]
q_{i},q_{j},r_{ijk}\in[0,1]
, the expression
r
i
â€‹
j
â€‹
k
â€‹
q
i
â€‹
q
j
r_{ijk}q_{i}q_{j}
has the interpretation of a population dynamics or chemical process of the form â€œ
i
i
and
j
j
give
k
k
â€, with this processes happening at rate
r
i
â€‹
j
â€‹
k
r_{ijk}
, assuming
q
i
,
q
j
,
q
k
q_{i},q_{j},q_{k}
have the interpretation of concentrations of species
i
,
j
,
k
i,j,k
. The formalism we use here assumes non-normalized state variables.
We will subsequently use a restriction of the interaction kernel to graph-based systems, which we call the
edge-reweighting kernel
, to describe BDH.
Restricting the interaction kernel to spiking signals and graph systems.
First, we observe that rules of the form used in the interaction kernel from Definition
1
are extremely easy to implement in systems which rely on stochastic 0/1-valued signals. When
q
^
i
\hat{q}_{i}
and
q
^
j
\hat{q}_{j}
are independent random variables in
{
0
,
1
}
\{0,1\}
, with
Pr
â¡
[
q
^
i
=
1
]
=
q
i
\Pr[\hat{q}_{i}=1]=q_{i}
and
Pr
â¡
[
q
^
j
=
1
]
=
q
j
\Pr[\hat{q}_{j}=1]=q_{j}
, then
q
i
,
q
j
â†’
q
k
q_{i},q_{j}\xrightarrow{}q_{k}
is expressible as the â€œAND gateâ€ of probability: the random variable
Î´
â€‹
q
^
k
:=
q
i
â€‹
q
j
âˆˆ
{
0
,
1
}
\delta\hat{q}_{k}:=q_{i}q_{j}\in\{0,1\}
gives the same expected contribution
ğ”¼
â€‹
Î´
â€‹
q
^
k
=
q
i
â€‹
q
j
\mathbb{E}\delta\hat{q}_{k}=q_{i}q_{j}
as the considered rule.
We now consider the restriction of interaction kernels to the case of graph systems. In the general formalism,
k
k
can be arbitrary with respect to
i
i
and
j
j
. By contrast, consider graph systems, which describe binary relations between nodes, and not (directly) three-point relations. To resolve this, we will require that
i
i
,
j
j
, and
k
k
have the interpretation of two nodes of a graph and an edge which is incident to them.
For an anchoring in the literature of dynamical systems, we note that already systems following an interaction kernel with a strongly constrained
k
k
of the form
k
âˆˆ
{
i
,
j
}
k\in\{i,j\}
, exhibit powerful nonlinearities: with such a restriction on
k
k
, EquationÂ (
3
) describes the class of evolutionary systems following the equations of
replicator dynamics
(Hofbauer and Sigmund,
1998
)
, also equivalently known as a non-normalized form of the fundamental Lotka-Volterra predator-prey dynamics. Replicator dynamics can naturally be represented as graph systems whose parameters are defined on
on edges of the graph
, but whose state is updated on
on nodes of the graph
. By contrast, when defining dynamics for reasoning in the current work, we will also need to capture a more powerful class of graph-based systems, where, crucially, state is larger than the number of neuron nodes, appearing on neuron-neuron edges (synapses).
We are now ready to describe a restriction of the interaction kernel from Definition
1
to the case of node-edge-node interaction rulesets in a graph: the
edge-reweighting kernel
.
Definition of the edge-reweighting kernel.
We consider a graph system with
n
n
nodes
, indexed
V
=
{
1
,
â€¦
,
n
}
V=\{1,\ldots,n\}
. Additionally, a subset
E
E
of pairs of indexes
(
i
,
j
)
(i,j)
, for
i
,
j
âˆˆ
{
1
,
â€¦
,
n
}
i,j\in\{1,\ldots,n\}
forms the
edges
of the system.
The system has state variables associated (uniformly) with nodes and edges, which we denote with capital letters, e.g.,
X
â€‹
(
i
)
X(i)
, for
i
âˆˆ
V
i\in V
or
Z
â€‹
(
i
,
j
)
Z(i,j)
, for
(
i
,
j
)
âˆˆ
E
(i,j)\in E
.
Definition 2
(edge-reweighting kernel)
.
A distributed system follows the
edge-reweighting kernel
if its dynamics are given by the interaction kernel (Definition
1
) with a set of non-negative state variables, defined on the set of nodes
V
V
and set of edges
E
E
of a graph, such that each local rule with non-zero rate is either a
computational rule
involving only state variables on a single node
i
âˆˆ
V
i\in V
, or a
communication rule
for an edge
(
i
,
j
)
âˆˆ
E
(i,j)\in E
, involving state variables from the nodes
i
,
j
i,j
and edge
(
i
,
j
)
(i,j)
.
For context, we remark that, in comparison to the strictly simpler dynamics of node-reweighting governed by graph-based replicator dynamics equations, dynamical systems based on the edge-reweighting kernel given by Definition
2
are rather elusive to study. We credit the seminal work of Algorithms theory
(Christiano etÂ al.,
2011
)
[Fig.Â 1, ThmÂ 3.2] as the first rigorous study of local edge-reweighting graph dynamics, combining fast-paced linear kernels on nodes with a slower-paced edge-reweighting process, in order to refine (â€˜focusâ€™) electrical flows on graphs towards a sharper form of cost optimality.
6
6
6
The graph dynamics used in this approach are naturally phrased in distributed computing parlance, see
(Becchetti etÂ al.,
2018
; Zou,
2019
)
.
The BDH dynamics that we will introduce here rely on fundamentally different nonlinearities in the process, and will have the interpretation of guiding the system from premises defined at a subset of nodes, towards search targets at nodes representing a desired outcome, through reasoning inference rules with tunable weights set on edges.
In the following Subsection, we will use the introduced formalism to define BDH as an edge-reweighting kernel on the union of edges of several graphs (
G
x
ğ”¢
,
G
x
ğ”¦
,
G
y
ğ”¢
,
G
y
ğ”¦
,
G
s
{G_{x}}^{\mathfrak{e}},{G_{x}}^{\mathfrak{i}},{G_{y}}^{\mathfrak{e}},{G_{y}}^{\mathfrak{i}},{G_{s}}
) with the same set of
n
n
nodes.
2.2
Definition of BDH as a local edge-reweighting process (equations of reasoning)
Bearing in mind the discussion of graph dynamics suitable for the case of language inference, and specifically the definition of the edge-reweighting kernel (Definition
2
), we are now ready to formalize the state-space dynamics of EquationÂ (
6
) as a local graph dynamics.
Definition 3
.
The BDH model with
n
n
neurons, with parameters expressed through graphs
G
x
ğ”¢
,
G
x
ğ”¦
,
G
y
ğ”¢
,
G
y
ğ”¦
,
G
s
{G_{x}}^{\mathfrak{e}},{G_{x}}^{\mathfrak{i}},{G_{y}}^{\mathfrak{e}},{G_{y}}^{\mathfrak{i}},{G_{s}}
is represented as the ruleset of the edge-reweighting kernel, with
O
â€‹
(
n
+
|
E
â€‹
(
G
s
)
|
)
O(n+|E({G_{s}})|)
state variables, with rule amplitudes given by â€œthe equations of reasoningâ€ in Table
1
.
Inference dynamics of BDH.
The BDH dynamics rely on rapid pulse dynamics with state variables
X
â€‹
(
i
)
X(i)
,
Y
â€‹
(
i
)
Y(i)
,
A
â€‹
(
i
)
A(i)
, defined on the
n
n
neuron sites of the system, and fast-weight-like state variables
Ïƒ
â€‹
(
i
,
j
)
\sigma(i,j)
, defined on a subset of edges of the system,
(
i
,
j
)
âˆˆ
E
â€‹
(
G
s
)
(i,j)\in E({G_{s}})
. The full implementation of BDH shown in Table
1
(b) also includes auxiliary state variables
X
ğ”¢
â€‹
(
i
)
X^{\mathfrak{e}}(i)
,
X
ğ”¦
â€‹
(
i
)
X^{\mathfrak{i}}(i)
,
Y
ğ”¢
â€‹
(
i
)
Y^{\mathfrak{e}}(i)
,
Y
ğ”¦
â€‹
(
i
)
Y^{\mathfrak{i}}(i)
which are used as temporary counters, for integration of excitatory and inhibitory signals received by neurons. The dynamics also rely on a set of damping hyperparameters on state,
u
>
0
u>0
, which may in full generality be defined separately as
u
â€‹
(
i
,
j
)
u(i,j)
for each edge
(
i
,
j
)
âˆˆ
E
â€‹
(
G
s
)
(i,j)\in E({G_{s}})
.
Inference with BDH is performed as follows. For some parameter
L
L
(e.g.
L
=
8
L=8
in most of this paper), which would correspond to the number of layers in a Transformer-like system, the system scheduler proceeds through rules in round-robin manner, ingesting new tokens every
4
â€‹
L
4L
rounds and retrieving results
4
â€‹
L
4L
rounds later. During round
4
â€‹
l
+
k
4l+k
, for
0
â‰¤
l
<
L
0\leq l<L
, the system performs rules from the
k
k
-th column of Table
1
, with each such round consisting of a communication step on edges and a local computation step on nodes.
The state-space dynamics of BDH can be rewritten in vector-tensor form, equivalent to the local dynamics of the interaction kernel given in Table
1
. This representation is given by EquationÂ (
6
) in the following Section.
Observation 1
.
The BDH-Graph protocol for the interaction kernel, given for any time round
T
=
4
â€‹
L
â€‹
t
+
(
4
â€‹
l
+
k
)
T=4Lt+(4l+k)
,
0
â‰¤
l
<
L
0\leq l<L
,
k
=
{
0
,
1
,
2
,
3
}
k=\{0,1,2,3\}
by the ruleset in Table
1
is equivalent to the state-space dynamics over time
t
t
and layers
l
l
, given by EquationÂ (
6
).
Proof.
For completeness, a detailed explanation of the equivalence is provided in Appendix
C.1
.
âˆ
The variables
X
â€‹
(
i
)
X(i)
,
Y
â€‹
(
i
)
Y(i)
,
A
â€‹
(
i
)
A(i)
, defined for each of the
n
n
nodes of the system, are updated in successive rounds. The state variables
Ïƒ
\sigma
defined on edges are assumed to be distinct over
l
l
as
Ïƒ
l
\sigma_{l}
, for
0
â‰¤
l
<
L
0\leq l<L
; this distinction serves to facilitate interpretation and to strike a balance between the number of parameters and the size of state of the system (assuming a single state matrix
Ïƒ
\sigma
, uniform across
l
l
, does not fundamentally change the operation and scaling laws of the architecture).
(a) Simple equations of reasoning
Round
4
â€‹
l
4l
Round
4
â€‹
l
+
1
4l+1
Round
4
â€‹
l
+
2
4l+2
Round
4
â€‹
l
+
3
4l+3
Inference from state
Reweighting of synapse state
Neuron replicator dynamics +
inference from parameters
Inference from parameters
X
â€‹
(
i
)
,
Ïƒ
l
â€‹
(
i
,
j
)
â†’
A
â€‹
(
j
)
\displaystyle X(i),\ \sigma_{l}(i,j)\xrightarrow{}A(j)
Ïƒ
l
â€‹
(
i
,
j
)
â†“
1
âˆ’
u
â€‹
(
i
,
j
)
\displaystyle\sigma_{l}(i,j)\downarrow_{1-u(i,j)}
Y
â€‹
(
i
)
,
X
â€‹
(
j
)
â†’
G
s
â€‹
(
i
,
j
)
Ïƒ
l
â€‹
(
i
,
j
)
\displaystyle Y(i),\ X(j)\xrightarrow{G_{s}(i,j)}\sigma_{l}(i,j)
Y
â€‹
(
i
)
â†“
\displaystyle Y(i)\downarrow
A
â€‹
(
i
)
,
X
â€‹
(
j
)
â†’
G
y
ğ”¢
â€‹
(
i
,
j
)
Y
â€‹
(
j
)
\displaystyle A(i),\ X(j)\xrightarrow{G_{y}^{\mathfrak{e}}(i,j)}Y(j)
A
â€‹
(
i
)
â†“
\displaystyle A(i)\downarrow
Y
â€‹
(
i
)
â†’
G
x
ğ”¢
â€‹
(
i
,
j
)
X
â€‹
(
j
)
\displaystyle Y(i)\xrightarrow{G_{x}^{\mathfrak{e}}(i,j)}X(j)
(b) Complete equations of reasoning of BDH
Round
4
â€‹
l
4l
Round
4
â€‹
l
+
1
4l+1
Round
4
â€‹
l
+
2
4l+2
Round
4
â€‹
l
+
3
4l+3
Communication
X
â€‹
(
i
)
,
Ïƒ
l
â€‹
(
i
,
j
)
â†’
A
â€‹
(
j
)
\displaystyle X(i),\ \sigma_{l}(i,j)\xrightarrow{}A(j)
Y
â€‹
(
i
)
,
X
â€‹
(
j
)
â†’
G
s
â€‹
(
i
,
j
)
Ïƒ
l
â€‹
(
i
,
j
)
\displaystyle Y(i),\ X(j)\xrightarrow{G_{s}(i,j)}\sigma_{l}(i,j)
A
â€‹
(
i
)
â†’
G
y
ğ”¢
â€‹
(
i
,
j
)
Y
ğ”¢
â€‹
(
j
)
\displaystyle A(i)\xrightarrow{G_{y}^{\mathfrak{e}}(i,j)}Y^{\mathfrak{e}}(j)
A
â€‹
(
i
)
â†’
G
y
ğ”¦
â€‹
(
i
,
j
)
Y
ğ”¦
â€‹
(
j
)
\displaystyle A(i)\xrightarrow{G_{y}^{\mathfrak{i}}(i,j)}Y^{\mathfrak{i}}(j)
Y
â€‹
(
i
)
â†’
G
x
ğ”¢
â€‹
(
i
,
j
)
X
ğ”¢
â€‹
(
j
)
\displaystyle Y(i)\xrightarrow{G_{x}^{\mathfrak{e}}(i,j)}X^{\mathfrak{e}}(j)
Y
â€‹
(
i
)
â†’
G
x
ğ”¦
â€‹
(
i
,
j
)
X
ğ”¦
â€‹
(
j
)
\displaystyle Y(i)\xrightarrow{G_{x}^{\mathfrak{i}}(i,j)}X^{\mathfrak{i}}(j)
Computation
Ïƒ
l
â€‹
(
i
,
j
)
â†“
1
âˆ’
u
â€‹
(
i
,
j
)
\displaystyle\sigma_{l}(i,j)\downarrow_{1-u(i,j)}
X
ğ”¢
â€‹
(
i
)
â†“
\displaystyle X^{\mathfrak{e}}(i)\downarrow
X
ğ”¦
â€‹
(
i
)
â†“
\displaystyle X^{\mathfrak{i}}(i)\downarrow
Y
â€‹
(
i
)
â†“
\displaystyle Y(i)\downarrow
Y
ğ”¢
â€‹
(
i
)
â†“
\displaystyle Y^{\mathfrak{e}}(i)\downarrow
Y
ğ”¦
â€‹
(
i
)
â†“
\displaystyle Y^{\mathfrak{i}}(i)\downarrow
(
Y
ğ”¢
â€‹
(
i
)
âˆ’
Y
ğ”¦
â€‹
(
i
)
)
+
,
X
â€‹
(
i
)
â†’
Y
â€‹
(
i
)
\displaystyle(Y^{\mathfrak{e}}(i)-Y^{\mathfrak{i}}(i))^{+},\ X(i)\xrightarrow{}Y(i)\hskip-1.72668pt
A
â€‹
(
i
)
â†“
\displaystyle A(i)\downarrow
(
X
ğ”¢
â€‹
(
i
)
âˆ’
X
ğ”¦
â€‹
(
i
)
)
+
â†’
X
â€‹
(
i
)
\displaystyle(X^{\mathfrak{e}}(i)-X^{\mathfrak{i}}(i))^{+}\xrightarrow{}X(i)
Table 1:
The â€œequations of reasoningâ€: State-space dynamics of the BDH language model expressed through local graph dynamics with the edge reweighting kernel (Definition
2
). The rules are executed for a distributed system of
n
n
neurons performing steps of parallel computation and communication during inference. Model parameters are expressed through the weights of edges of graphs
G
x
ğ”¢
,
G
x
ğ”¦
,
G
y
ğ”¢
,
G
x
ğ”¦
,
G
s
{G_{x}}^{\mathfrak{e}},{G_{x}}^{\mathfrak{i}},{G_{y}}^{\mathfrak{e}},{G_{x}}^{\mathfrak{i}},{G_{s}}
, and BDH model training is equivalent to defining rule probability amplitudes
G
x
ğ”¢
â€‹
(
i
,
j
)
,
G
x
ğ”¦
â€‹
(
i
,
j
)
,
G
y
ğ”¢
â€‹
(
i
,
j
)
,
G
y
ğ”¦
â€‹
(
i
,
j
)
,
G
s
â€‹
(
i
,
j
)
â‰¥
0
{G_{x}}^{\mathfrak{e}}(i,j),{G_{x}}^{\mathfrak{i}}(i,j),{G_{y}}^{\mathfrak{e}}(i,j),{G_{y}}^{\mathfrak{i}}(i,j),{G_{s}}(i,j)\geq 0
for pairs of neurons
i
,
j
âˆˆ
{
1
,
â€¦
,
n
}
i,j\in\{1,\ldots,n\}
connected by the edges of these graphs. State is encoded in variables
Ïƒ
â€‹
(
i
,
j
)
\sigma(i,j)
at synapses, representing edges of graph
G
s
G_{s}
. The system proceeds in parallel rounds, with new tokens arriving into the system encoded through variables
X
â€‹
(
i
)
X(i)
at neurons and introduced every
4
â€‹
L
4L
rounds, where
L
L
is a parameter of the model (e.g.,
L
=
8
L=8
). The set of rules being executed (for each round modulo
4
â€‹
L
4L
) is given in the table. The readout of the system also happens through variables
X
â€‹
(
i
)
X(i)
at the end of each
4
â€‹
L
4L
rounds.
(a) Set of rules for the simplified version of the BDH model with no neuron inhibitory circuits and no thresholding (
G
x
ğ”¦
=
G
y
ğ”¦
=
0
{G_{x}}^{\mathfrak{i}}={G_{y}}^{\mathfrak{i}}=0
), capturing the general form of the communication structure and synaptic attention of the model. (b) Set of rules for the general case of BDH, including inhibitory circuits
G
x
ğ”¦
{G_{x}}^{\mathfrak{i}}
,
G
y
ğ”¦
{G_{y}}^{\mathfrak{i}}
. An execution of the provided rules is equivalent to the state-space dynamics given by EquationÂ (
6
).
In the representation in Table
1
we do not impose how the local thresholding operation within some neuron
i
i
, of the form
A
â€‹
(
i
)
,
B
â€‹
(
i
)
â‡¢
(
A
â€‹
(
i
)
âˆ’
B
â€‹
(
i
)
)
+
A(i)\ ,B(i)\dashrightarrow\left(A(i)-B(i)\right)^{+}
, should be performed. We leave this as a computational primitive, which can be realized based on approximate counting or a comparator. The way natural neurons achieve thresholding to determine whether input signal excitation outweighs inhibition relies on time-integration of impulses. For realizations in other types of distributed systems and population protocols, we refer the reader to the literature on thresholding and Majority Protocols, cf.Â e.g.
(Doty etÂ al.,
2021
; Czyzowicz etÂ al.,
2022
)
.
The definition of the protocol does not specify how variable
X
â€‹
(
i
)
X(i)
should be reset when the scheduler passes from layer
L
L
of one input token to layer
0
for the next input token. As with the definition of state-space equations in Section
3
, we leave this open to allow the dynamics to work both with externally provided input (for next-token prediction), or in a self-feedback loop (for autoregressive operation).
Notes on training.
Direct training of the BDH model would be performed by selecting the edges of the considered graphs, and then setting rule weights
G
x
ğ”¢
â€‹
(
i
,
j
)
,
G
x
ğ”¦
â€‹
(
i
,
j
)
,
G
y
ğ”¢
â€‹
(
i
,
j
)
,
G
y
ğ”¦
â€‹
(
i
,
j
)
,
G
s
â€‹
(
i
,
j
)
â‰¥
0
{G_{x}}^{\mathfrak{e}}(i,j),{G_{x}}^{\mathfrak{i}}(i,j),{G_{y}}^{\mathfrak{e}}(i,j),{G_{y}}^{\mathfrak{i}}(i,j),{G_{s}}(i,j)\geq 0
for pairs of neurons
i
,
j
âˆˆ
{
1
,
â€¦
,
n
}
i,j\in\{1,\ldots,n\}
connected by the edges of these graphs.
In what follows, we will train a tensor-friendly special case of BDH, called BDH-GPU, relying on an implicit (generally more efficient) representation of the considered graph parameter weights, using a low-rank product representation for the matrices of these graphs. This representation is reminiscent of the hub-labeling graph representation technique, but is directly suitable for describing and evolving high-conductance scale-free networks. The appropriate architecture is introduced in Section
3
.
2.3
Interpretation of attention as a micro-inductive bias of reasoning
Rule weights in the edge-reweighting kernel have the interpretation of micro-programs, governed by rules of transformation of state variables of the form
A
â€‹
(
i
)
,
B
â€‹
(
j
)
â†’
Ïƒ
â€‹
(
i
,
j
)
A(i),B(j)\to\sigma(i,j)
and
A
â€‹
(
i
)
,
Ïƒ
â€‹
(
i
,
j
)
â†’
C
â€‹
(
j
)
A(i),\sigma(i,j)\to C(j)
, defined on edges between nodes
i
,
j
i,j
of some
n
n
-node graph.
This formalism can be seen as running an enormous circuit with a form of universal gates given by the transition rules, over a structure of computational elements at nodes, and memory elements on edges of a graph.
While the local rulesets have the form of a rule-based micro-assembly, we leave open the extent to which they should be considered to have an interpretation of programming in logic (as would be the case, e.g., for C-RASP
(Yang and Chiang,
2024
)
). The natural interpretation of
Ïƒ
â€‹
(
i
,
j
)
>
0
\sigma(i,j)>0
is a positive bias associated with the neuron pair
(
i
,
j
)
(i,j)
,
i
,
j
âˆˆ
{
1
,
â€¦
,
n
}
i,j\in\{1,\ldots,n\}
, which follows from past context. This can be considered by phrasing the local rules of the system in a framework of logic inference; we do so informally, omitting discussion of layers.
If past context
(
x
Ï„
:
Ï„
<
t
)
(x_{\tau}:\tau<t)
implies that implication
i
â†’
j
i\to j
has weight
Ïƒ
t
âˆ’
1
â€‹
(
i
,
j
)
\sigma_{t-1}(i,j)
, and if the current state at time
t
t
implies that
i
i
follows from this state with weight
x
t
â€‹
(
i
)
x_{t}(i)
, then the current state at time
t
t
implies that
j
j
follows from this state with weight
x
t
â€‹
(
i
)
â€‹
Ïƒ
t
âˆ’
1
â€‹
(
i
,
j
)
x_{t}(i)\sigma_{t-1}(i,j)
.
The above is intentionally phrased to resemble the logical axiom
(
X
â†’
(
i
â†’
j
)
)
â†’
(
(
X
â†’
i
)
â†’
(
X
â†’
j
)
)
(X\to(i\to j))\to((X\to i)\to(X\to j))
, which is perhaps most prevalent across different formalizations of axiomatic logic, with an application of
modus ponens
as an inference rule. The inference system of the considered model uses state and model weights to devise its own heuristic for the order of evaluation, i.e., to consider which facts appear to be most plausible to be evaluated next, and to evaluate them in an order based on what follows most strongly from context. In a way consistent with what we expect from informal reasoning in language, the considered weights have a more direct interpretation of an increment of utility associated with a given inference.
7
7
7
Here, the term
utility
is understood in the sense of evolutionary game theory, as applied to the population of neurons, considering the standard interpretation of replicator dynamics, as applied in the ruleset from Table
1
. Neurons which win in the natural selection process are added to the activation
Y
Y
.
In the setting of argumentation, this utility-based approach could, for example, guide the inference process from a pair of known concepts in context, a source and a target, to an intermediate concept likely to be a common-neighbor shortcut lying on a logical path between this source and target (cf.Â Section
5.3
for a discussion of how this type of mechanism is enforced in the feed-forward network of BDH-GPU).
The considered micro-foundational interpretation of attention, defined at the level of individual neurons (or logical variables), does not contradict the way in which Transformer attention is often regarded at the coarser level of vectors through key-query lookup intuitions. At the same time, it highlights that an attention state entry
Ïƒ
â€‹
(
i
,
j
)
\sigma(i,j)
(and similarly, a model edge weight leading from
i
i
to
j
j
) does not have the interpretation of a logical value (i.e., something that is true or false), but an inductive bias associated with how likely the system is to consider the implication â€˜
i
â†’
j
i\to j
â€™ in its next steps of reasoning, when proposing its next conclusions or next ideas for consideration.
Chains of implications in BDH guide activations along paths in the system graphs
G
x
ğ”¢
,
G
y
ğ”¢
,
ğˆ
{G_{x}}^{\mathfrak{e}},{G_{y}}^{\mathfrak{e}},{\boldsymbol{\sigma}}
. For the latter, attention allows specific implications to enter into paths of thought once the corresponding synapses are open in state
ğˆ
{\boldsymbol{\sigma}}
.
2.4
Interpretation of BDH as an oscillator network toy-model
Whereas the interpretation from Subsection
2.3
focuses on properties which fallow from the computational function (purpose) of the system, here we outline an interpretation of the behavior of BDH considered purely as a dynamical system.
Definition of the toy-model.
We will consider the toy-model of an
n
n
-particle system shown in Fig.
2
as an illustration of the general form of dynamics of the state-space equationÂ (
6
) of BDH. We draw the
n
n
particles in a circle.
8
8
8
This is a direct tribute to the Kuromato coupled oscillators model; the crucial difference being that in BDH, the elements of state with an interpretation similar to oscillators appear on connections between nodes, not nodes.
Symbol
Interpretation in:
Table
1
, StateÂ EquationÂ (
6
)
Oscillator Network Toy-Model
G
x
,
G
y
,
G
s
{G_{x}},{G_{y}},{G_{s}}
graph parameters of model
wires, prods, and elastic connections
Ïƒ
\sigma
synaptic state of model
displacement of elastic connections
x
,
y
x,y
activation vectors
pulses at nodes, state correction
Figure 2:
The â€˜physical systemâ€™ representation of BDH as a physical graph toy-model.
The particles are connected with each other by state elements, represented in Fig.
2
as elastic connectors. The topology of these pairwise connections is given by graph
G
s
{G_{s}}
, and may in general be dense.
The signal displays dynamics of state
ğ†
{\boldsymbol{\rho}}
through tension on connectors, which evolves at a slower time scale, and a more pulse-like activation dynamics
x
,
y
x,y
(on nodes), appearing and vanishing regularly, at a rapid time scale.
The slower state dynamics represent, in the first order, oscillation or relaxation of the system of elastic connectors. Once an elastic connector between particles
i
i
and
j
j
has had its endpoints displaced through state
x
x
and
y
y
, respectively, a tension appears on this connector, which causes its displacement
ğˆ
â€‹
(
i
,
j
)
{\boldsymbol{\sigma}}(i,j)
that relaxes over time (damping variant, corresponding to ALiBi), and/or acts as a spring element (oscillator variant, a simplified illustration of RoPE). Initially,
ğˆ
â€‹
(
i
,
j
)
=
0
{\boldsymbol{\sigma}}(i,j)=0
.
The faster dynamics represent the node dynamics of particles. Over time, pulse displacements
x
â€‹
(
i
)
x(i)
happen at nodes, as a result of either previous behavior of the system, or perturbation by an external forcing field (in reality this field would be language input). A node
i
i
with displacement
x
â€‹
(
i
)
x(i)
may, due to the aggregated action of tension of
elastic connectors
ğˆ
â€‹
(
i
,
â‹…
)
{\boldsymbol{\sigma}}(i,\cdot)
adjacent to it, activate a system of
prods
G
y
{G_{y}}
adjacent to it, perturbing nodes it hits in this way. If another node
j
j
is prodded sufficiently hard, it may cause it to activate a perturbation
y
â€‹
(
j
)
y(j)
. The perturbation
y
â€‹
(
j
)
y(j)
of a node
j
j
will, in the next step, propagate again to those other nodes
i
â€²
i^{\prime}
, which are connected to
j
j
by a system of
wires
(
G
x
{G_{x}}
). If the aggregated pull of wires on a node
i
â€²
i^{\prime}
is sufficiently strong, this modifies its pulse displacement
x
â€‹
(
i
â€²
)
x(i^{\prime})
. The pulse activation
y
â€‹
(
j
â€²
)
y(j^{\prime})
of some node
j
â€²
j^{\prime}
, directly followed by pulse activation
x
â€‹
(
i
â€²
)
x(i^{\prime})
of node
i
â€²
i^{\prime}
, results in an increase in the tension on the connector
(
i
,
j
)
(i,j)
, adding to the value of the tension
ğˆ
â€‹
(
i
â€²
,
j
â€²
)
{\boldsymbol{\sigma}}(i^{\prime},j^{\prime})
. All pulse activations
y
y
subside, and the pulses propagate, consequently altering the slow state
ğˆ
{\boldsymbol{\sigma}}
.
In general,
ğˆ
â€‹
(
i
â€²
,
j
â€²
)
{\boldsymbol{\sigma}}(i^{\prime},j^{\prime})
is triggered simply by the temporal connection between the pulse
y
â€‹
(
j
â€²
)
y(j^{\prime})
activating, followed by the pulse
x
â€‹
(
i
â€²
)
x(i^{\prime})
activating immediately afterwards, even if there was no direct causality between the two (although
y
â€‹
(
j
â€²
)
y(j^{\prime})
contributed to pulse
x
â€‹
(
i
â€²
)
x(i^{\prime})
happening if
(
j
â€²
,
i
â€²
)
âˆˆ
G
x
(j^{\prime},i^{\prime})\in{G_{x}}
). An appropriate correspondence of the graphs,
G
s
âŠ†
G
x
{G_{s}}\subseteq{G_{x}}
, would bring the system close to an observed causal effect on the activated synapse.
The above description of the pulse dynamics was given from the perspective of nodes. From the perspective of connectors, an existing tension on some connector
ğˆ
â€‹
(
i
,
k
)
{\boldsymbol{\sigma}}(i,k)
propagates through prods
G
y
{G_{y}}
to some nodes
j
j
, then through wires
G
x
{G_{x}}
to some nodes
i
â€²
i^{\prime}
, and this finally contributes to tensions on other connectors
ğˆ
â€‹
(
i
â€²
,
j
â€²
)
{\boldsymbol{\sigma}}(i^{\prime},j^{\prime})
. This propagation of state thus happens to 3-hop neighbors, through
i
i
,
j
j
,
i
â€²
i^{\prime}
.
During training, the behavior of the system may, in even longer time scales, result in the propagation of changes of connection weight and structures to graphs
G
x
{G_{x}}
and
G
y
{G_{y}}
, as well as (optionally)
G
s
{G_{s}}
.
Effects captured by the toy-model.
We have described a small local graph kernel, with 3-hop locality, capturing the two key effects of the local graph kernel.
The first effect is the graph form of communication pattern between nodes, and thresholding of updates. (We have omitted direct mention of inhibition from discussion of the toy-model, but it is direct to include.)
The second effect is the placement of attention state on node connections, its update patterns, and the dynamics of its relaxation over time.
We intentionally convey the interpretation of node pulses as a differential (gradient) of state on node connections. This interpretation is consistent with our empirical study from Section
7
. It is worth considering once every how many steps of the operation of the toy-model, a single element of state
ğˆ
â€‹
(
i
,
j
)
{\boldsymbol{\sigma}}(i,j)
is updated. This depends directly on the sparsity of the pulse signals
y
â€‹
(
i
)
y(i)
,
x
â€‹
(
j
)
x(j)
; at least one of them is, generally, sparse. If the pulses where to happen very seldom for such a pair
(
i
,
j
)
(i,j)
, state updates are essentially a â€œsecond-orderâ€ correction effect. By adjusting the frequency of updates, the system can be made to operate exactly at the critical point where this pulse dynamics ceases to be a second-order correction of state
ğˆ
â€‹
(
i
,
j
)
{\boldsymbol{\sigma}}(i,j)
, giving the random variable describing the time between updates of a connection pair
ğˆ
â€‹
(
i
,
j
)
{\boldsymbol{\sigma}}(i,j)
a heavy power-law-like tail distribution (possibly with different distribution parameters for different pairs
(
i
,
j
)
(i,j)
).
In the description of state dynamics, we noted the hop-distance of 3 in the forward propagation of changes to state. Bearing this in mind is helpful when considering how a gradient backpropagation mechanism would follow dependencies between changes of state if such a system were to have its graph weights altered through backpropagation.
Finally, let us clarify the specific choice of kernel we made for BDH. We found it to work well, and we knew how to train BDH models which implement it on GPU (which we will call BDH-GPU). This, with current hardware, made it
10
2
âˆ’
10
5
10^{2}-10^{5}
times more cost- and time-effective to train models and analyze outcomes than kernels, for which we only knew how to train on CPU. Nonetheless, the question of finding optimal kernels according to different criteria (e.g.: minimality of kernel, best training rate per token, closeness to brain function based on known evidence from brain studies), is an extremely pertinent foundational problem. The problem can be phrased in a â€œclosed-endedâ€ way, leaving a finite number of possibilities to be checked, at least when considering small graph kernels. Some kernels may also prove to have superior learning capabilities to the Transformer (and BDH), and if this quality difference is overwhelming, they may eventually prove commercially viable.
In the following, we formalize the choice of kernel for BDH, and also provide a framework to describe other kernels capturing the same effects of graph communication and synaptic attention.
2.5
Expressing BDH using brain models
The results we obtain for BDH provide direct corollaries on the expressiveness of brain models which are capable of emulating the local graph kernels of BDH. Specifically, a distributed system, which is able to efficiently emulate the local kernels of BDH, has sufficient expressiveness to perform language inference and reasoning at least to the same extent as BDH.
Observation 2
.
The local ruleset of BDH (Table
1
) can be expressed through a combination of simple mechanisms: neuron activation with positive state variables, Hebbian learning, and communication through excitatory and inhibitory circuits with thresholding.
âˆ
We note that in the description of the rulesets in Table
1
, RoundÂ (
4
â€‹
l
+
2
4l+2
) and (
4
â€‹
l
+
3
4l+3
) directly describe the use of excitatory and inhibitory circuits with integrate-and-fire thresholding at neurons. RoundÂ (
4
â€‹
l
+
2
4l+2
) additionally includes a form of competition effect between neurons, realized fully locally at a neurons using the multiplication effect of replicator dynamics. The communication rule of RoundÂ (
4
â€‹
l
+
1
4l+1
) involves the potentiation of a synapse based on activations of neurons at its endpoints. As was discussed in Subsection
2.1
, the natural mechanism for implementing increase in synaptic strength is through spiking dynamics, where the execution of the communication rule of RoundÂ (
4
â€‹
l
+
1
4l+1
) is a stochastic AND-gate on signals. Finally, RoundÂ (
4
â€‹
l
4l
) describes the long-term effects of using a strengthened synapse for transmission of signals, and its strength decrease.
We can use the framework of expressiveness, as captured in Observation
2
, to shed light on the capabilities of natural systems through their ability to emulate artificial ones. Specifically, if a natural system A can plausibly emulate some artificial system B by using the resources it has at its disposal, and artificial system B is able to solve a problem P, this can be used to explain: (1) why the natural system A is sufficiently powerful to solve problem P, and (2) plausibly, that the purpose for which system A is equipped with certain mechanisms includes solving problem P, if such mechanisms prove useful in the emulation of B.
The experimental validation of the performance of BDH architecture at Transformer level (Section
4.2
) confirms that BDH is sufficient to provide language and reasoning function at scale. We can thus make the following statement.
Empirical Finding 2
.
The
Hebbian learning mechanism
is plausibly needed, and in combination with neural circuits, sufficient, for performing the
reasoning
function at the scale of the brain. This includes performing language function with attention, and performing thought processes, at a time scale of minutes.
In view of our results, Hebbian learning can be seen as a form of unsupervised learning over time, expressed through graph edge reweighting, to perform reasoning and language inference using the attention mechanism. This type of result can be compared to an analogous interpretation for Hebbian learning in the context of vision, as pioneered in
(Brunel,
1996
)
. With the setting of language and chain-of-thought reasoning, we are able to directly capture effects of time in the brain.
Given the interpretation of neuron activations as carrying the necessary gradients of synaptic state (Section
2.4
), the problem of supervised learning (i.e., taking into account feedback signals) plausibly becomes deferred to a selective transfer and re-encoding of gradients from state into weights, at longer time scales. We return to a discussion of this point in the Conclusions, bearing in mind the fact that the general difficulty of the problem is now reduced through restrictions on the considered edge-reweighting kernel, and the relative rarity of synapse activation events.
Our work also suggests a framework for further discussion of reasoning function, with an anchoring point for this type of investigation in the time-scale of â€˜split-secondsâ€™ to â€˜minutesâ€™. The question of shorter time scales is then one of designing more precise communication and computational primitives for spiking neurons and synaptic plasticity, which can be used to perform primitives for individual rules of graph kernels for the inference dynamics.
9
9
9
While we do not provide direct explanations for effects at shorter time scales and scheduler primitives, we note the type of kernels we rely on are well understood in terms of the ability to work with asynchronous schedulers, and obtaining emergence of synchronization.
(Kosowski and UznaÅ„ski,
2018
; Dudek and Kosowski,
2018
)
The question of longer time scales, and the changes to model structure that follow in a learning process, naturally follows any explanation of unsupervised (Hebbian) learning from the shorter time scale that is considered here, as a mechanism of transfer from state to weights; we come back to this point in the Conclusions.
3
BDH-GPU: a tensor-friendly version of the BDH architecture
We will now introduce BDH-GPU, a variant of the BDH reasoning system, expressed in the language of tensor operations typical for Deep Learning models. BDH-GPU provides a GPU-compatible implementation of BDH. BDH-GPU can be easily implemented in PyTorch, a didactic code listing is provided in Appendix
E
). Furthermore, BDH-GPU can be trained on large text datasets using error backpropagation, and has been shown experimentally to match performance of GPT-based LLMs.
The main steps towards the efficient implementation of BDH-GPU on GPU are:
1.
Express graphs
G
x
G_{x}
and
G
y
G_{y}
a low-rank factorizations of their transition matrices, followed by ReLU nonlinearities
(Nair and Hinton,
2010
)
(we explore graph properties of these approximations in Section
5
). We never materialize these matrices, but maintain instead a low dimensional state per each neuron.
2.
Never materialize the
Ïƒ
\sigma
state matrix, preferring instead to access it using a linear attention operation over low-rank representation of values (we explore the properties of this attention mechanism in Section
6
).
3.
Normalize all state variables using LayerNorm
(Ba etÂ al.,
2016b
)
.
We will refer to the architecture in the final intermediate step, before the introduction of LayerNorm, as BDH-Normfree.
3.1
Notation for BDH-GPU
We consider the
BDH-GPU
â€‹
(
n
,
d
)
\textrm{BDH-GPU}(n,d)
architecture parameterized by positive integers
n
,
d
n,d
. The system scales in dimension
n
n
â€” the number of particles. In what follows, we will use the terms
particle
and
neuron
interchangeably. Dimension
d
d
is a measure of the number of parameters per neuron required to represent the interaction of this neuron with the particle interaction field or interaction graph. For asymptotic analysis, we assume that
n
â†’
+
âˆ
n\to+\infty
is the basis for all asymptotics, and
n
â‰«
d
>
C
â€‹
log
â¡
n
n\gg d>C\log n
holds for some sufficiently large constant
C
>
0
C>0
. For the tensor representation of the model, which is the primary one for implementation and empirical studies here in this paper, vectors in
R
d
R^{d}
have an interpretation as (fuzzy) addresses of a virtual memory space of size
n
n
, hence the assumption
d
=
Î©
â€‹
(
log
â¡
n
)
d=\Omega(\log n)
cannot be dispensed with while using natural (linear-algebraic) arithmetic on real numbers. We later show how to avoid this assumption in graph-based models, by using uniform local graph kernels of smaller degree with a graph communication structure.
Nonlinearities: ReLU and LayerNorm.
In what follows, we assume that a one-dimensional vector is denoted by a lower-case letter, e.g.,
z
z
, with
z
âˆˆ
R
n
Ã—
1
â‰…
R
n
z\in R^{n\times 1}\cong R^{n}
unless otherwise stated. Vectors which appear in dimension
d
d
are named with an asterisk, e.g., as
z
âˆ—
âˆˆ
R
d
Ã—
1
z^{*}\in R^{d\times 1}
. We denote the
ReLU operation
(
z
)
+
:=
max
i
âˆˆ
1
,
â€¦
,
n
â¡
{
0
,
z
i
}
\left(z\right)^{+}:=\max_{i\in{1,\ldots,n}}\{0,z_{i}\}
.
We further define
LayerNorm
of a vector
z
âˆ—
âˆˆ
R
d
Ã—
1
z^{*}\in R^{d\times 1}
in a uniform non-parametric way,
ğ–«ğ–­
â€‹
(
z
âˆ—
)
=
z
âˆ—
âˆ’
ğŸ
â€‹
ğ”¼
d
â€‹
z
âˆ—
Ïƒ
d
â€‹
z
âˆ—
\mathsf{LN}\left(z^{*}\right)=\frac{z^{*}-\mathbf{1}\mathbb{E}_{d}z^{*}}{\sigma_{d}z^{*}}
, where
ğ”¼
d
\mathbb{E}_{d}
and
Ïƒ
d
\sigma_{d}
are estimators of mean and standard deviation in dimension
d
d
, respectively.
Activation vectors and parameter matrices.
In vectors representing activations, each scalar element (element of
R
R
) of the activation vector has the interpretation of a â€˜scalarâ€™ activation state of a single particle. Throughout this text,
R
R
is generally assumed be the field of real numbers
R
:=
â„
R:=\mathbb{R}
, and scalars are represented by a fixed-precision floating point number in experiments.
10
10
10
When only asymptotic analysis is the object, it is sometimes convenient to consider
R
:=
â„
k
R:=\mathbb{R}^{k}
for some
k
=
2
,
3
,
â€¦
k=2,3,\ldots
. Specifically, considering
R
:=
â„
2
R:=\mathbb{R}^{2}
allows
S
â€‹
O
â€‹
(
2
)
SO(2)
rotations on
â„
2
\mathbb{R}^{2}
to be expressed as â€˜scalarâ€™ ones on
R
R
, thus making the
â„
2
â€‹
n
Ã—
2
â€‹
n
\mathbb{R}^{2n\times 2n}
RoPE block-diagonal matrix of a diagonal matrix in
R
n
Ã—
n
R^{n\times n}
(Su etÂ al.,
2024
)
. This provides a consistent formalism for ALiBi
(Press etÂ al.,
2022
)
, RoPE, and extensions such as LieRE
(Ostmeier etÂ al.,
2025
)
as diagonal (communication-free) operations. In all cases, the application of ReLU
(
â‹…
)
+
\left(\cdot\right)^{+}
to a scalar remains coordinate-wise in
â„
\mathbb{R}
.
By convention, in discussions of parameters, matrices denoted
G
x
,
G
y
,
G
s
âˆˆ
R
n
Ã—
n
{G_{x}},{G_{y}},{G_{s}}\in R^{n\times n}
will represent neuron-neuron interaction, encoders
E
âˆˆ
R
d
Ã—
n
E\in R^{d\times n}
reduce dimensionality of activation vectors (e.g.,
a
âˆ—
=
E
â€‹
z
a^{*}=Ez
for
z
âˆˆ
R
n
z\in R^{n}
), and decoders
D
âˆˆ
R
n
Ã—
d
D\in R^{n\times d}
lift them back into
R
n
R^{n}
(e.g.,
z
â€²
=
D
â€‹
a
âˆ—
z^{\prime}=Da^{*}
).
Depending on the architecture variant considered, the state will either have the interpretation of a neuron-neuron correlation matrix
ğˆ
âˆˆ
R
n
Ã—
n
{\boldsymbol{\sigma}}\in R^{n\times n}
, or a compressed form with reduced dimensionality,
ğ†
=
E
â€‹
ğˆ
âˆˆ
R
n
Ã—
d
{\boldsymbol{\rho}}=E{\boldsymbol{\sigma}}\in R^{n\times d}
.
3.2
Definition of BDH-GPU as a state-space system
We now define the main architecture of this paper in its tensor flavor, called BDH-GPU.
Definition 4
(inference dynamics of BDH-GPU)
.
A BDH-GPU state-space system
BDH-GPU
â€‹
(
n
,
d
)
\textrm{BDH-GPU}(n,d)
, given by three parameter matrices:
E
âˆˆ
R
d
Ã—
n
E\in R^{d\times n}
and
D
x
,
D
y
âˆˆ
R
n
Ã—
d
{D_{x}},{D_{y}}\in R^{n\times d}
, performs iteration over time
t
=
0
,
1
,
2
â€‹
â€¦
t=0,1,2\ldots
and layers
l
=
1
,
2
â€‹
â€¦
â€‹
L
l=1,2\ldots L
, governed for any time
t
t
by the following recurrence:
x
t
,
l
:=
x
t
,
l
âˆ’
1
+
(
D
x
â€‹
v
t
,
l
âˆ’
1
âˆ—
)
+
a
t
,
l
âˆ—
:=
âˆ‘
Ï„
<
t
v
Ï„
,
l
âˆ’
1
âˆ—
â€‹
x
Ï„
,
l
T
â€‹
U
t
âˆ’
Ï„
â€‹
x
t
,
l
y
t
,
l
:=
(
D
y
â€‹
ğ–«ğ–­
â€‹
(
a
t
,
l
âˆ—
)
)
+
âŠ™
x
t
,
l
v
t
,
l
âˆ—
:=
ğ–«ğ–­
â€‹
(
E
â€‹
y
t
,
l
)
\displaystyle\begin{split}{x_{t,l}}&:=x_{t,l-1}+\left({D_{x}}{v^{*}_{t,l-1}}\right)^{+}\\
{a^{*}_{t,l}}&:=\sum_{\tau<t}{v^{*}_{\tau,l-1}}{x_{\tau,l}}^{T}U^{t-\tau}{x_{t,l}}\\
{y_{t,l}}&:=\left({D_{y}}\mathsf{LN}\left({a^{*}_{t,l}}\right)\right)^{+}\odot{x_{t,l}}\quad\\
{v^{*}_{t,l}}&:=\mathsf{LN}\left(E{y_{t,l}}\right)\end{split}
(4)
where inputs to the system are provided through the boundary condition
v
Ï„
,
0
âˆ—
v^{*}_{\tau,0}
in layer
0
, for
Ï„
=
0
,
1
,
2
â€‹
â€¦
â€‹
t
\tau=0,1,2\ldots t
.
Here,
U
âˆˆ
R
n
Ã—
n
U\in R^{n\times n}
is a diagonal or block-diagonal matrix representing local rotation or damping of state (such as ALiBi or RoPE),
L
âˆˆ
â„•
L\in\mathbb{N}
is the number of layers.
BDH-GPU as a language model.
BDH-GPU is intended to be used as a language model, processing one token per time step, in which case the input
v
t
,
0
âˆ—
v^{*}_{t,0}
, for
t
âˆˆ
â„•
t\in\mathbb{N}
, is obtained using some (linear) encoding function from the token alphabet
Î©
\Omega
,
f
e
:
Î©
â†’
R
d
f_{e}:\Omega\to R^{d}
, as applied to the
t
t
-th input tokens. Similarly, the logits of the
t
t
-th output token are extracted using some decoding function applied to outputs of the
L
L
-th layer
v
t
,
L
âˆ—
v^{*}_{t,L}
, using a (linear) token decoder function
f
d
:
R
d
â†’
Î©
f_{d}:R^{d}\to\Omega
. The source of language tokens may be external, as is the case for next token prediction tasks, or auto-regressive.
For training, we assume that a model
M
M
trained in the
BDH-GPU
â€‹
(
n
,
d
)
\textrm{BDH-GPU}(n,d)
architecture has the trainable parameter set
M
=
(
E
,
D
x
,
D
y
,
f
e
,
f
d
)
M=(E,{D_{x}},{D_{y}},f_{e},f_{d})
, with all parameters trained together. The model has
3
â€‹
n
â€‹
d
+
2
â€‹
Î©
â€‹
d
=
(
3
+
o
â€‹
(
1
)
)
â€‹
n
â€‹
d
3nd+2\Omega d=(3+o(1))nd
parameters, i.e., the scalable part of the model is concentrated in the total of
3
â€‹
n
â€‹
d
3nd
parameters of the matrices
(
E
,
D
x
,
D
y
)
(E,{D_{x}},{D_{y}})
.
State-space representation.
The notation of Definition
4
is chosen so as to exhibit its direct applicability in a Transformer-like token-parallel training framework. Vector
v
Ï„
,
l
âˆ’
1
âˆ—
v^{*}_{\tau,l-1}
has the interpretation of attention â€˜valueâ€™ inputs at time
Ï„
\tau
in layer
l
l
. Vector
a
t
,
l
âˆ—
a^{*}_{t,l}
represents the result of a linear attention mechanism for time
t
t
in layer
l
l
.
Denoting inÂ (
4
) the modelâ€™s attention state as
ğ†
t
âˆ’
1
,
l
=
âˆ‘
Ï„
<
t
v
Ï„
,
l
âˆ’
1
âˆ—
â€‹
x
Ï„
,
l
T
â€‹
U
t
âˆ’
Ï„
{\boldsymbol{\rho}}_{t-1,l}=\sum_{\tau<t}{v^{*}_{\tau,l-1}}{x_{\tau,l}}^{T}U^{t-\tau}
(5)
we obtain the equivalent but more compact form of representing the inference dynamics of BDH-GPU as a state-space model, presented in Fig.
3
, Eq.Â (
8
).
\@mathmargin
BDH
ğˆ
t
,
l
:=
(
ğˆ
t
âˆ’
1
,
l
+
(
(
y
t
,
l
âˆ’
1
â€‹
x
t
,
l
T
)
âŠ™
G
s
)
)
â€‹
U
x
t
,
l
:=
x
t
,
l
âˆ’
1
+
(
(
G
x
ğ”¢
âˆ’
G
x
ğ”¦
)
â€‹
y
t
,
l
âˆ’
1
)
+
y
t
,
l
:=
(
(
G
y
ğ”¢
âˆ’
G
y
ğ”¦
)
â€‹
ğˆ
t
âˆ’
1
,
l
â€‹
x
t
,
l
)
+
âŠ™
x
t
,
l
\displaystyle\begin{split}{\boldsymbol{\sigma}}_{t,l}&:=\left({\boldsymbol{\sigma}}_{t-1,l}+\left(\left({y_{t,l-1}}{x_{t,l}}^{T}\right)\odot{G_{s}}\right)\right)U\\
{x_{t,l}}&:=x_{t,l-1}+\left(\left({G_{x}}^{\mathfrak{e}}-{G_{x}}^{\mathfrak{i}}\right){y_{t,l-1}}\right)^{+}\\
{y_{t,l}}&:=\left(\left({G_{y}}^{\mathfrak{e}}-{G_{y}}^{\mathfrak{i}}\right){\boldsymbol{\sigma}}_{t-1,l}{x_{t,l}}\right)^{+}\odot{x_{t,l}}\end{split}
(6)
BDH-GPU
ğ†
t
,
l
:=
(
ğ†
t
âˆ’
1
,
l
+
ğ–«ğ–­
â€‹
(
E
â€‹
y
t
,
l
âˆ’
1
)
â€‹
x
t
,
l
T
)
â€‹
U
x
t
,
l
:=
x
t
,
l
âˆ’
1
+
(
D
x
â€‹
ğ–«ğ–­
â€‹
(
E
â€‹
y
t
,
l
âˆ’
1
)
)
+
y
t
,
l
:=
(
D
y
â€‹
ğ–«ğ–­
â€‹
(
ğ†
t
âˆ’
1
,
l
â€‹
x
t
,
l
)
)
+
âŠ™
x
t
,
l
\displaystyle\begin{split}{\boldsymbol{\rho}}_{t,l}&:=\left({\boldsymbol{\rho}}_{t-1,l}+\mathsf{LN}\left(E{y_{t,l-1}}\right){x_{t,l}}^{T}\right)U\\
{x_{t,l}}&:=x_{t,l-1}+\left({D_{x}}\mathsf{LN}\left(E{y_{t,l-1}}\right)\right)^{+}\\
{y_{t,l}}&:=\left({D_{y}}\mathsf{LN}\left({\boldsymbol{\rho}}_{t-1,l}{x_{t,l}}\right)\right)^{+}\odot{x_{t,l}}\end{split}
(8)
â†˜
\searrow
â†—
\nearrow
BDH-Normfree
ğˆ
t
,
l
:=
(
ğˆ
t
âˆ’
1
,
l
+
y
t
,
l
âˆ’
1
â€‹
x
t
,
l
T
)
â€‹
U
ğ†
t
,
l
:=
(
ğ†
t
âˆ’
1
,
l
+
(
E
â€‹
y
t
,
l
âˆ’
1
)
â€‹
x
t
,
l
T
)
â€‹
U
}
alternative
representations
x
t
,
l
:=
x
t
,
l
âˆ’
1
+
(
D
x
â€‹
E
â€‹
y
t
,
l
âˆ’
1
)
+
y
t
,
l
:=
(
D
y
â€‹
E
â€‹
ğˆ
t
âˆ’
1
,
l
âŸ
ğ†
t
âˆ’
1
,
l
â€‹
x
t
,
l
)
+
âŠ™
x
t
,
l
\displaystyle\begin{split}&\hskip-18.49411pt\left.\begin{aligned} {\boldsymbol{\sigma}}_{t,l}&:=\left({\boldsymbol{\sigma}}_{t-1,l}+{y_{t,l-1}}{x_{t,l}}^{T}\right)U\\
{\boldsymbol{\rho}}_{t,l}&:=\left({\boldsymbol{\rho}}_{t-1,l}+(E{y_{t,l-1}}){x_{t,l}}^{T}\right)U\end{aligned}\right\}{\,{}^{\textrm{alternative}}_{\textrm{representations}}}\hskip-56.9055pt\\
{x_{t,l}}&:=x_{t,l-1}+\left({D_{x}}E{y_{t,l-1}}\right)^{+}\\
{y_{t,l}}&:=({D_{y}}\underbrace{E{\boldsymbol{\sigma}}_{t-1,l}}_{{}^{{\boldsymbol{\rho}}_{t-1,l}}}{x_{t,l}})^{+}\odot{x_{t,l}}\end{split}
(7)
Figure 3:
State-space equations of the model architectures introduced in this paper.
All architectures refer to a set of
n
n
interacting particles (neurons), with activation vectors
x
t
,
l
âˆˆ
(
R
+
)
n
x_{t,l}\in(R^{+})^{n}
. Vector
y
t
,
l
âˆˆ
(
R
+
)
n
y_{t,l}\in(R^{+})^{n}
,
y
t
,
l
y_{t,l}
is (typically) sparse in the sense of
â€–
y
t
,
l
â€–
0
\|y_{t,l}\|_{0}
. Variables
ğ†
t
,
l
âˆˆ
R
n
Ã—
d
{\boldsymbol{\rho}}_{t,l}\in R^{n\times d}
or
ğˆ
t
,
l
âˆˆ
R
n
Ã—
n
{\boldsymbol{\sigma}}_{t,l}\in R^{n\times n}
represent hidden state of the system.
â‹„
\diamond
The graph-based BDH dynamics equationÂ (
6
), equivalent to the ruleset from Table
1
, serves as a starting point for development of architectures represented as local graph kernels in a distributed computing system.
â‹„
\diamond
The simplified BDH-Normfree equationÂ (
LABEL:eq:bdhnoln
) is a special case of BDH. Up to lack of LayerNorms, it approximates the inference dynamics of BDH-GPU, with the correspondence
ğ†
t
,
l
=
E
â€‹
ğˆ
t
,
l
{\boldsymbol{\rho}}_{t,l}=E{\boldsymbol{\sigma}}_{t,l}
.
â‹„
\diamond
The tensor-based BDH-GPU architecture is described by equationsÂ (
8
) (mathematically equivalent to Definition
4
, Eq.Â (
4
)Â andÂ (
5
)) and is the primary point of reference for all model training and all empirical results presented in this study. For a discussion of extensions to BDH-GPU such as heads, see Subsection
4.1
. A complete code listing for BDH-GPU is provided in Appendix
E
.
Figure 4:
Scaling of BDH-GPU architecture in dimension
n
n
. The other parameters can be considered fixed during scaling. For example, with choice of
d
=
256
d=256
for low-rank dimension,
k
=
2
k=2
for neuron pairing with RoPE, and
h
=
1
h=1
for a single-head architecture, the model scales linearly in dimension
n
n
in chunks of
d
â€‹
h
â€‹
k
=
256
â‹…
2
â‹…
1
=
512
dhk=256\cdot 2\cdot 1=512
parameters.
In what follows, we will perform analysis focusing on the state-space representation of the architecture given by Eq.Â (
8
).
3.3
Interpretation of BDH-GPU as a local interacting particle system
The BDH-GPU dynamics equationÂ (
8
) has the interpretation of a
n
n
-particle system, with the state
ğ†
t
â€‹
(
i
)
{\boldsymbol{\rho}}_{t}(i)
of the
i
i
-th particle,
i
=
1
,
â€¦
,
n
i=1,\ldots,n
, given at the end of time
t
t
by a vector in
R
d
R^{d}
for each layer:
ğ†
i
(
t
)
:=
(
ğ†
t
,
l
â€‹
(
i
,
â‹…
)
:
l
âˆˆ
(
1
,
â€¦
L
)
)
.
{\boldsymbol{\rho}}_{i}(t):=({\boldsymbol{\rho}}_{t,l\ (i,\cdot)}:l\in(1,\ldots L)).
Overall, as we will see directly, the way particle
i
i
interacts with other particles at time
t
t
is described by the following tuple
Z
i
Z_{i}
:
Z
i
â€‹
(
t
)
:=
(
ğ†
i
â€‹
(
t
)
,
E
(
i
,
â‹…
)
,
D
x
(
â‹…
,
i
)
,
D
y
(
â‹…
,
i
)
)
.
Z_{i}(t):=({\boldsymbol{\rho}}_{i}(t),E_{(i,\cdot)},{D_{x}}_{\,(\cdot,i)},{D_{y}}_{\,(\cdot,i)}).
Here,
ğ†
i
â€‹
(
t
)
{\boldsymbol{\rho}}_{i}(t)
represents the in-context state associated with particle
i
i
(initialized as
ğŸ
\mathbf{0}
at the start of inference), while the other three vectors of length
d
d
associated with this particle are trainable, but do not change during inference.
The system scales in dimension
n
n
and is completely uniform in this dimension, excepting following effect. Let
k
k
denote the size of largest block in the block-diagonal matrix
U
U
; then particles, are bound by this effect into non-uniform
k
k
-tuples when
k
>
1
k>1
(
k
=
1
k=1
when
U
U
is the ALiBi matrix, and
k
=
2
k=2
when
U
U
is the RoPE matrix). Thus the system, in general, scales in the dimension of
n
n
uniformly, in chunks of
k
k
particles (see Fig.
4
).
The interaction between particles is, intuitively, local. To be able to proceed with discussion with rigor and without complicating notation, we assume for the analysis that
k
=
1
k=1
. We also drop LayerNorms from the equations of inference dynamics. (Models generally do not train following BDH-GPU without any LayerNorm, but we observed empirically that there is some flexibility as to where these LayerNorms are placed; they can also be moved to the neuron dimension
n
n
, and they are parameter-free.) The dynamics without LayerNorm are represented under the name BDH-Normfree in Fig.
3
.
We have the following.
Observation 3
(local particle interaction â€˜by mean-fieldâ€™)
.
The BDH-Normfree dynamics have the interpretation of a mean-field interaction between particles, fully characterized at any time by
O
â€‹
(
d
â€‹
L
)
O(dL)
parameters of particle in state, and
O
â€‹
(
d
)
O(d)
parameters in particle representation.
This observation is essential for the subsequent discussion, and it can be expanded in three different ways.
In computing terms, at any time
t
t
and in any layer
l
l
, the action of the system can be represented as an iterated application of the dynamics equationsÂ (
4
), with each of the particles realizing, for each equation in each layer (i.e., a total of
3
â€‹
L
3L
times), a form of micro-program, involving local computation and communication with other particles by broadcast. In a framework of local distributed computing (cf.Â e.g.
(Peleg,
2000
)
), it would be represented as a node performing the following form of local kernel as a part of a networked system:
1.
compute some message vector
m
i
âˆˆ
R
d
m_{i}\in R^{d}
locally (without communication with other particles), based only on current activation
x
t
,
l
,
i
x_{t,l,\,i}
,
y
t
,
l
,
i
y_{t,l,\,i}
and previous state
Z
i
â€‹
(
t
âˆ’
1
)
Z_{i}(t-1)
,
2.
broadcast message
m
i
âˆˆ
R
d
m_{i}\in R^{d}
to other particles,
3.
receive the mean-field message
m
Â¯
=
âˆ‘
j
=
1
n
m
j
âˆˆ
R
d
\bar{m}=\sum_{j=1}^{n}m_{j}\in R^{d}
, identical for all particles,
4.
update local activation variables for the next layer
l
+
1
l+1
, and update new state
Ïƒ
i
â€‹
(
t
)
âŠ†
Z
i
â€‹
(
t
)
\sigma_{i}(t)\subseteq Z_{i}(t)
, based on the received result
m
Â¯
\bar{m}
of the broadcast and local computation.
In Physical terms, we observe that the interaction field of the particles, which realizes the broadcast, is localized, and can at any time
t
t
be expressed as a sum of pairwise particle interaction terms between particles
i
,
j
âˆˆ
1
,
â€¦
,
t
i,j\in 1,\ldots,t
. These pairwise interactions depend only on parameters
Z
i
â€‹
(
t
âˆ’
1
)
Z_{i}(t-1)
and
Z
j
â€‹
(
t
âˆ’
1
)
Z_{j}(t-1)
, and the activation variables of these particles, representing properties of these particles at time
t
t
and expressible through
O
â€‹
(
L
â€‹
d
)
O(Ld)
scalars. This interaction field evolves with time
t
t
together with
Z
i
Z_{i}
and
Z
j
Z_{j}
.
11
11
11
Note that
Z
i
â€‹
(
t
âˆ’
1
)
Z_{i}(t-1)
depends only on
ğ†
t
âˆ’
1
,
l
{\boldsymbol{\rho}}_{t-1,l}
, not
ğ†
t
,
l
{\boldsymbol{\rho}}_{t,l}
. This is because of the stopping index of
Ï„
=
t
âˆ’
1
\tau=t-1
in the definition of attention
a
âˆ—
a^{*}
in Def.
4
, and is intentional.
In Engineering terms, we observe that any transformation of a length-
n
n
vector into another length-
n
n
vector passes through an intermediary low-rank representation of dimension at most
d
d
. An example is the equation for
x
t
,
l
x_{t,l}
inÂ (
LABEL:eq:bdhnoln
), which reduces length-
n
n
vector
y
t
,
l
y_{t,l}
to a length
d
d
-vector through application of the encoder matrix
E
E
, before lifting the dimension back to
n
n
by an application of the decoder
D
x
{D_{x}}
.
3.4
Expressing BDH-GPU using BDH: preserving parameter and state size
BDH-GPU and BDH both represent
n
n
-particle systems. For a special parameter choice (of BDH), they have equivalent patterns of communication and of computation (up to placement of layer norms).
Observation 4
(BDH-Normfree is a special case of the BDH graph model)
.
Models in the BDH-Normfree architecture (Eq.Â (
8
)) and models in the BDH architecture (Eq.Â (
6
)) are formally equivalent (i.e., the same model) subject to the following choice of model parameters of BDH:
G
x
ğ”¢
âˆ’
G
x
ğ”¦
=
D
x
â€‹
E
,
G
y
ğ”¢
âˆ’
G
y
ğ”¦
=
D
y
â€‹
E
,
G
s
=
ğŸ
n
Ã—
n
,
{G_{x}}^{\mathfrak{e}}-{G_{x}}^{\mathfrak{i}}={D_{x}}E,\quad{G_{y}}^{\mathfrak{e}}-{G_{y}}^{\mathfrak{i}}={D_{y}}E,\quad{G_{s}}=\mathbf{1}^{n\times n},
(9)
where
ğŸ
n
Ã—
n
\mathbf{1}^{n\times n}
is the all-ones matrix.âˆ
We discuss in more details below how BDH compares to BDH-Normfree in terms of size of state and number of parameters needed for one architecture to approximate the inference dynamics of the other. In general, BDH is not less expressive than its tensor-based counterpart.
For BDH-GPU parameters and state are naturally expressed using tensors of
O
â€‹
(
n
â€‹
d
)
O(nd)
model parameters. In this section, we discuss how to express model parameters and state of BDH, in such a way as to maintain comparable size of parameter and model space.
3.4.1
Expressing matrices
D
x
,
D
y
,
E
{D_{x}},{D_{y}},E
as graphs
G
x
,
G
y
{G_{x}},{G_{y}}
We start by taking care of the first correspondence, that of parameter spaces of BDH-GPU and BDH. Asymptotically, BDH is strictly more expressive at the same number
O
â€‹
(
n
â€‹
d
)
O(nd)
parameters. Recall from Eq.Â (
8
) that the parameter space of BDH-GPU consists of three matrices
D
y
â€‹
D
x
âˆˆ
R
n
Ã—
d
{D_{y}}{D_{x}}\in R^{n\times d}
,
E
âˆˆ
R
d
Ã—
n
E\in R^{d\times n}
, and (up to shifting of LayerNorms), their role is to encode the pairs of matrices
D
y
E
,
D
x
E
,
âˆˆ
R
n
Ã—
n
{D_{y}}E,{D_{x}}E,\in R^{n\times n}
, as used in Eq.Â (
LABEL:eq:bdhnoln
). In the Claim below, we capture the correct encoding of one such matrix pair in the form of a graph of
O
â€‹
(
n
â€‹
d
)
O(nd)
parameters.
Consider a (directed, weighted) graph
G
âˆˆ
R
+
n
Ã—
n
G\in R+^{n\times n}
on a set of vertices
V
=
{
1
,
â€¦
,
n
}
V=\{1,\ldots,n\}
. We will consider a graph which need be directly a sparse graph, but can be represented as a square of a graph with few edges. Formally, we will say that
G
âˆˆ
ğ’¢
2
â€‹
(
n
,
m
)
G\in\mathcal{G}^{2}(n,m)
, for some
m
âˆˆ
â„•
m\in\mathbb{N}
, if there exists a graph
H
âˆˆ
R
(
n
+
s
)
Ã—
(
n
+
s
)
H\in R^{(n+s)\times(n+s)}
, with vertex set
V
âˆª
S
V\cup S
, where
|
S
|
=
s
|S|=s
, such that
G
=
H
2
â€‹
[
V
]
G=H^{2}[V]
, i.e.,
G
G
is the induced subgraph of
H
2
H^{2}
restricted to vertex set
V
V
, and
H
H
has at most
m
m
(strictly positive) edges.
For a
G
âˆˆ
ğ’¢
2
â€‹
(
n
,
m
)
G\in\mathcal{G}^{2}(n,m)
, we can consider an interpretation of a hidden layer
S
S
between input layer
V
V
and output layer
V
V
. All matrix weights coefficients are restricted to be non-negative, and the two linear layers are sparse with a total of at most
m
m
non-negative connections.
Graphs in
ğ’¢
2
â€‹
(
n
,
m
)
\mathcal{G}^{2}(n,m)
are naturally expressed through the edges of the previously defined graph
H
H
, using
O
â€‹
(
n
â€‹
log
â¡
n
+
m
)
O(n\log n+m)
parameters. The class
ğ’¢
2
â€‹
(
n
,
m
)
\mathcal{G}^{2}(n,m)
is strictly more expressive than the class of sparse (
m
m
-edge) graphs on vertex set
V
V
.
12
12
12
The formal expression in the definition of the class of weighted graphs
ğ’¢
2
â€‹
(
n
,
m
)
\mathcal{G}^{2}(n,m)
can be compared to that of the class of graph distance matrices admitting sparse hub labeling representation
(Abraham etÂ al.,
2011
)
(or closely related landmark labeling). In our case, vertices in the hidden layer
S
S
also have a natural interpretation of landmarks on directed paths connecting nodes of
V
V
.
We will refer to the middle layer of vertices
S
S
that makes such a representation possible as the
sparse synaptic layer
, to the graph
H
H
on vertex set
V
âˆª
S
V\cup S
as the
sparse linear circuit
, and the graph
H
2
â€‹
[
V
]
âˆˆ
ğ’¢
2
â€‹
(
n
,
m
)
H^{2}[V]\in\mathcal{G}^{2}(n,m)
as the
neuron-neuron interaction graph
.
The role of the constructed graphs is to serve for propagating linear dynamics of the form
v
â†¦
G
â€‹
v
v\mapsto Gv
,
v
âˆˆ
(
R
+
)
n
Ã—
1
v\in(R^{+})^{n\times 1}
, for graph-based local models. We have the following Observation.
Observation 5
.
Let
G
âˆˆ
ğ’¢
2
â€‹
(
n
,
m
)
G\in\mathcal{G}^{2}(n,m)
be a neuron-neuron interaction graph, with
G
=
H
2
â€‹
[
V
]
G=H^{2}[V]
, where
H
H
is the sparse linear circuit on vertex set
V
âˆª
S
V\cup S
, which has
m
m
edges. Then, the linear dynamics on graph
G
G
,
v
â†¦
G
â€‹
v
v\mapsto Gv
, can be efficiently expressed through two steps of linear dynamics on graph
H
H
,
v
â†¦
H
2
â€‹
v
v\mapsto H^{2}v
, for
v
âˆˆ
(
R
+
)
n
Ã—
1
v\in(R^{+})^{n\times 1}
. This representation requires
O
â€‹
(
m
)
O(m)
parameters.
âˆ
In the above, thee exact number of parameters needed to represent a graph of
m
m
edges follows from conventions introduced in the Notation (Section
1.4
). In what follows, we will assume that BDH represents its parameter matrices through appropriate sparse linear circuit graphs
H
H
, which it uses to realize the linear neuron-neuron interaction dynamics
G
G
. We illustrate the correspondence between graphs
G
G
and
H
H
in Fig.
5
.
Figure 5:
Neuron-neuron communication using graphs
G
âˆˆ
ğ’¢
2
â€‹
(
n
,
m
)
G\in\mathcal{G}^{2}(n,m)
: correspondence between graph
H
H
with
m
m
edges (left), and neuron-neuron interaction graph
G
=
H
2
G=H^{2}
(right). The approach allows to express linear signal propagation on a broad class of graphs
ğ’¢
2
â€‹
(
n
,
m
)
\mathcal{G}^{2}(n,m)
using two steps of linear dynamics on a sparse circuit
H
H
, i.e.,
G
â€‹
z
=
H
2
â€‹
z
Gz=H^{2}z
for
z
âˆˆ
(
R
+
)
n
z\in(R^{+})^{n}
.
We observe that BDH can express BDH-GPU parameter matrices with the same asymptotic number of parameters. The claim below applies to pairs of matrices
D
â€‹
E
DE
, for
D
=
D
y
D={D_{y}}
and
D
=
D
x
D={D_{x}}
.
Claim 3
.
For any matrices
D
âˆˆ
R
n
,
d
D\in R^{n,d}
,
E
âˆˆ
R
d
,
n
E\in R^{d,n}
, there exist neuron-neuron interaction graphs
G
ğ”¢
,
G
ğ”¦
âˆˆ
ğ’¢
2
â€‹
(
n
,
m
)
G^{\mathfrak{e}},G^{\mathfrak{i}}\in\mathcal{G}^{2}(n,m)
, such that
G
ğ”¢
âˆ’
G
ğ”¦
=
D
â€‹
E
G^{\mathfrak{e}}-G^{\mathfrak{i}}=DE
, with
m
=
O
â€‹
(
n
â€‹
d
)
m=O(nd)
.
In consequence, for the same asymptotic number of parameters
O
â€‹
(
n
â€‹
d
)
O(nd)
, graph-based feed-forward mechanisms of BDH are strictly more expressive than corresponding mechanisms in the tensor-based implementation, BDH-Normfree.
Proof.
The short proof of the Claim is deferred to Appendix
C.3
.
âˆ
We note that the converse implication does not hold: an arbitrary graph
G
ğ”¢
âˆˆ
ğ’¢
2
â€‹
(
n
,
m
)
G^{\mathfrak{e}}\in\mathcal{G}^{2}(n,m)
does not admit an exact low-rank decomposition
G
ğ”¢
=
D
â€‹
E
G^{\mathfrak{e}}=DE
. Indeed, in general any low-rank decomposition introduces a form of noise whose implications we discussed in Section
5.3
: if
G
ğ”¢
G^{\mathfrak{e}}
has a modular (cluster) structure, the low-rank approximation
G
ğ”¢
â‰ˆ
D
â€‹
E
G^{\mathfrak{e}}\approx DE
still allows a form of in-cluster propagation dynamics.
3.4.2
Expressing BDH-GPU attention on graphs: sparsification and trainability of
G
s
{G_{s}}
We recall that by Observation
4
, the equivalence between the attention state
ğˆ
t
,
l
{\boldsymbol{\sigma}}_{t,l}
in BDH and in tensor-based implementation holds for the case of the complete directed graph,
G
s
=
ğŸ
n
Ã—
n
{G_{s}}=\mathbf{1}^{n\times n}
.
This means two things: first, in BDH, graph
G
s
{G_{s}}
can be trainable, while in BDH-GPU it is not. This acts to the potential advantage of BDH for expressiveness.
Second, in BDH, the graph
G
s
{G_{s}}
obtained through the direct correspondence is dense: with
n
n
neurons, BDH would need
n
2
n^{2}
synapses to precisely reflect BDH-Normfree. This aspect is more of a technical nuisance than an actual difference: the expressiveness of the attention mechanism of BDH, equipped with a sparse graph
G
s
{G_{s}}
, is sufficient to represent the attention operation as used in BDH-Normfree. Indeed, in the tensor-based BDH-GPU dynamics, the attention operation is immediately followed by a low-rank operation,
ğ†
t
,
l
=
E
â€‹
ğˆ
t
,
l
{\boldsymbol{\rho}}_{t,l}=E{\boldsymbol{\sigma}}_{t,l}
, where
ğ†
t
,
l
{\boldsymbol{\rho}}_{t,l}
has
n
â€‹
d
nd
parameters. Graph models can instead rely on a sparse graph
G
s
{G_{s}}
to achieve the same form of state compression through sparsification.
Claim 4
.
The attention block of BDH-Normfree can be expressed using the attention block of BDH with a graph
G
s
{G_{s}}
having
O
â€‹
(
n
â€‹
d
)
O(nd)
edges, subject to a natural preparation of attention values entering the attention block of BDH (directly before this attention block).
Proof.
The formal statement of the Claim and its proof are deferred to Appendix
C.4
.
âˆ
Going beyond the formal equivalence between BDH and BDH-GPU from Observation
4
, the above Claim, combined with Claim
3
, shows that BDH has at least the same expressiveness as BDH-GPU even for the same number of parameters
O
â€‹
(
n
â€‹
d
)
O(nd)
and the same size of state
O
â€‹
(
n
â€‹
d
)
O(nd)
per layer.
Independent of graph-based models, in the subsequent analysis of the feed-forward network and attention mechanisms of BDH-GPU, we will show that the matrices
D
x
â€‹
E
,
D
y
â€‹
E
,
Ïƒ
âˆˆ
R
n
Ã—
n
{D_{x}}E,{D_{y}}E,\sigma\in R^{n\times n}
of BDH-GPU admit a natural interpretation as
n
n
-node directed graphs (once appropriate threshold functions are applied). For example, the visualizations in Fig.
11
and Fig.
10
correspond to graph representations of matrices
ğˆ
{\boldsymbol{\sigma}}
and
G
x
:=
D
x
â€‹
E
{G_{x}}:={D_{x}}E
of BDH-GPU, respectively, after thresholding. This graph interpretation of matrices in BDH-GPU
also
defines the neuron-neuron communication graph of the underlying BDH model, given by the equivalence from Eq.Â (
9
).
4
Implementation and scaling laws
A code framework for BDH-GPU, representing the architecture from Definition
4
, is made available in the Appendix
E
. In this Section, we present some guidelines on choice of hyperparameters, and an empirical study of models implemented in the BDH-GPU architecture, as well as a comparison to the Transformer and other language model architectures.
4.1
Implementation characteristics of BDH-GPU
Figure 6:
Diagram of one layer of the BDH-GPU architecture, following Eq.Â (
8
). Layer inputs are
x
l
âˆ’
1
,
y
l
âˆ’
1
âˆˆ
R
n
x_{l-1},y_{l-1}\in R^{n}
, layer outputs are
x
l
,
y
l
âˆˆ
R
n
x_{l},y_{l}\in R^{n}
. Model parameters are contained in the
E
âˆˆ
R
n
Ã—
d
E\in R^{n\times d}
and
D
x
,
D
y
âˆˆ
R
d
Ã—
n
{D_{x}},{D_{y}}\in R^{d\times n}
, and shared across all layers. Each layer has a state
ğ†
l
âˆˆ
R
n
Ã—
d
{\boldsymbol{\rho}}_{l}\in R^{n\times d}
which is used in the Linear Attention block and persisted over time. PyTorch code implementing the model is provided in Appendix
E
Model scaling in neuron dimension
n
n
.
The architecture
BDH-GPU
â€‹
(
n
,
d
)
\textrm{BDH-GPU}(n,d)
has two main dimensions,
n
n
which is the dimension of its concept (
neuronal
) space, and
d
â‰ª
n
d\ll n
, which is its low-rank (
synaptic
) dimension. The model scales primarily with the number of neurons
n
n
. Almost all of the weights of the model are contained in three
n
Ã—
d
n\times d
parameter matrices called
E
,
D
x
,
D
y
E,{D_{x}},{D_{y}}
; thus, the number of parameters is precisely
(
3
+
o
â€‹
(
1
)
)
â€‹
n
â€‹
d
(3+o(1))nd
.
The ratio between the dimensions
n
n
and
d
d
increases rapidly (â€œasymptoticallyâ€) with model size; already for a 25M-parameter model, a sound choice of dimensions is:
d
=
256
d=256
,
n
=
32768
n=32768
, read as
32768
32768
neurons, each characterized by a total of
3
â€‹
d
=
3
â‹…
256
=
768
3d=3\cdot 256=768
scalar parameters.
Layers and heads.
The architecture has
L
L
layers (e.g.,
L
=
10
L=10
). As in the Universal Transformer
(Dehghani etÂ al.,
2019
)
, all layers use the same set of weights for each of the parameter matrices.
The architecture may be equipped with several heads
h
h
, subdividing dimension
n
n
. The role of heads is limited to a single parameter-free LayerNorm, normalizing outcomes of linear attention separately for each head. The optimal number of heads is typically smaller than in the Transformer (e.g.,
h
=
4
h=4
).
Linear attention with state aligned to neurons.
The state space of the model is fixed and large. It has the macro-interpretation of associative memory (like KV-cache, but organized differently), and is used to perform linear attention. For each layer, the state space is independent and has a fixed dimension
n
Ã—
d
n\times d
, the same as the model weight matrices. Thus, a portion of
d
d
parameters of a state is directly associated with each of the
n
n
neurons. With each token processed, a fraction of the modelâ€™s state space is updated. Sharing of state between the
L
L
layers is not performed in the vanilla architecture. As usual with SSMâ€™s, there is no notion of a context window.
Similarly to BDH, BDH-GPU maintains a large recurrent state comparable in size with its total number of parameters (c.f. Fig.
4
). This stems from the fact that both the recurrent state matrix, and parameter matrices are expressed as low rank
d
d
factorizations of
n
Ã—
n
n\times n
graph transition matrices. We believe that this helps the model with generalization with respect to RNNs which have
O
â€‹
(
N
2
)
O(N^{2})
parameters which manipulate a state of size
O
â€‹
(
N
)
O(N)
.
Sparse positive activation.
The architecture relies on a length-
n
n
vector
x
t
,
l
x_{t,l}
passed to the
l
l
-th layer for the
t
t
-th token processed, which can be assimilated to the vector giving rise to keys, values, and queries in the Transformer, but operating in higher dimension. As a crucial design assumption, this vector has all non-negative elements (
x
t
,
l
â‰¥
0
x_{t,l}\geq 0
).
An empirically observed fact is that the activation pattern of
x
t
x_{t}
rapidly becomes sparse (in a typical training run, only
Ï
â‰ˆ
5
%
\rho\approx 5\%
of the
n
n
entries of vector
x
t
x_{t}
are non-zero). This corresponds to the fraction of the state space read and updated for each token.
4.2
Comparison of BDH-GPU to GPT2-like Transformers
Architecture differences.
BDH-GPU in its vanilla form can be compared to the GPT2 architecture
(Radford etÂ al.,
2019
)
with RoPE attention. In this comparison, BDH-GPU retains or strengthens the key advantages of the Transformer (parallel trainability, attention mechanism, scaling laws for loss versus parameter count, learning rate per token) on tests and benchmarks at the model scales we tested (1B parameters), across tasks such as language and translation.
The architecture of a single layer of BDH-GPU is presented in Fig.
6
. The most evident architecture differences between BDH-GPU and the Transformer include the following:
âˆ’
-
BDH-GPU has fewer parameter matrices, allowing for more compact interpretation and analysis.
âˆ’
-
BDH-GPU scales for parameters (and context length) almost exclusively in a single neuronal dimension,
n
n
.
âˆ’
-
Key-value state and parameter matrices have matching dimensions and are highly localized together with state, with portions of these matrices attributable to individual neurons.
âˆ’
-
There is no notion of context length in BDH-GPU, and consequently no hard bound on it.
âˆ’
-
Attention of BDH-GPU is linear, but happens in the modelâ€™s large neuronal dimension.
âˆ’
-
Activation vectors
x
,
y
x,y
of BDH-GPU are positive (after passing through ReLU gates), and vectors
y
y
are observed to be extremely sparse in practice.
Transformer-like scaling laws.
We have experimentally validated the scaling laws of BDH-GPU, expressing loss as a function of parameter count, for next-token-prediction tasks. At the same parameter scale, BDH-GPU generally compares favorably to the Transformer even on relatively short-context tasks requiring use of attention, such as translation, Fig.
7
. In general, on next-token prediction tasks, BDH-GPU appears to show improvement of loss reduction per token of data than the Transformer, i.e.,
learns faster per data token
, both for the natural tasks we tested (see e.g.Â Fig.
7
) and on synthetic puzzles.
Figure 7:
Performance of BDH-GPU and GPTXL versus model size on a translation task. We have tested all models under the same training and evaluation regimes. All models show improved performance with scale. BDH-GPU uses exactly the formulation provided in Appendix
E
, while BDH-GPUâ€™ extends conditional gating of states and logits. All models are trained with truncated backpropagation through time on sequences 2048 characters long, and carry their state (
ğ†
{\boldsymbol{\rho}}
matrix for BDH models and a buffer of last 4096 KV-Cache entries
(Dai etÂ al.,
2019
)
for GPTXL) between minibatches. BDH models are scaled only by varying the number of neurons
n
n
and keep all other hyperparameters fixed, making them easy to scale. On the other hand, GPTXL were scaled in both the embedding dimension and the number of layers and required Dropout
(Srivastava etÂ al.,
2014
)
tuning for optimal performance. We observe that BDH-GPUâ€™ matches the GPT Transformer at all model sizes we have evaluated.
Details on model hyperparameters and training setup are provided in Appendix
B.2
The BDH-GPU architecture appears to be a preferred choice for training setups where: (1) models need to learn from scarce data, or (2) training workloads need to be optimized for makespan. For the first setting, the training rate per token is the decisive factor. For the second setting, BDH-GPU can be used differently than the Transformer in distributed training and distributed inference setups because of the way it scales its dimensions.
FLOPS counts.
The theoretical count of arithmetic operations per token of BDH-GPU during inference is bounded by
O
â€‹
(
n
â€‹
d
â€‹
L
)
O(ndL)
. Each parameter is accessed
O
â€‹
(
L
)
O(L)
times per token (with the typical sufficient number of layers being smaller than in the Transformer), and each element of state is accessed
O
â€‹
(
1
)
O(1)
times per token, with small hidden constants. These are rough bounds for a simple implementation, and do not take advantage of activation sparsity.
For short contexts BDH-GPU is amenable to parallel training with a causal self-attention kernel. The simple code template provided in the Appendix
E
is sufficient to reproduce the empirical results presented in this paper on a single GPU node. For longer contexts (typically above 4096 tokens for
d
=
256
d=256
), a state-space kernel for linear attention is faster and more space-efficient.
4.3
Comparison of BDH-GPU to other sequence processing architectures
Transformers with Linear Attention.
Linear attention works well when used in high dimension, subject to appropriate preparation of key vectors (as we discuss inÂ Subsection
6.1
). An elegant way to eliminate non-linearity of attention, by applying preparation of key vectors through tensor product, was proposed in
(Buckman etÂ al.,
2024
)
. We use a completely different approach to achieve attention in high dimension.
A much broader line of work on linear attention for the Transformer, initiated by
(Katharopoulos etÂ al.,
2020
)
concerns applying linear attention in low dimension after appropriate preparation of keys and values. This is effectively a technique for SSM state compression, and it is not clear whether it relates favorably to other SSM state compression techniques. An empirical study of the amount of information recoverable from SSMâ€™s with compressed state can be found in
(Ben-Kish etÂ al.,
2025
; Liu etÂ al.,
2025
)
.
A general theoretical framework for analyzing the expressiveness of Linear Attention models with attention working with positive vectors can be found in the context of the FAVOR+ framework of the Performer
(Choromanski etÂ al.,
2021
)
. Finally, a general state-space formalism for Transformer models admitting Linear Attention was considered in
(Sun etÂ al.,
2023
; Liu etÂ al.,
2025
)
.
Other types of Transformers.
Variants of the Transformer with identical parameters in all layers, like the Universal Transformer
(Dehghani etÂ al.,
2019
)
, have a number of desirable features, notably in terms of explainability and ease of defining metrics. The downside of sharing parameters between layers in the Universal Transformer is a slight time overhead for the feed-forward network operations, when measured in FLOPS per parameter. The situation is similar in BDH-GPU.
BDH-GPU has sufficient expressiveness to prepare keys and queries for the attention operation, so that the outcome of attention captures a similarity measure between keys and queries corresponding to the outcome of a class of Locality Sensitive Hashing (LSH) functions with a very large number of buckets (cf.Â Subsection
6.1
). The study of LSH-based KV-cache for the Transformer was initiated with the Reformer
(Kitaev etÂ al.,
2020
)
, and the LSHÂ Transformer architecture introduced in the same work. Generally, the LSHÂ Transformer is shown to rapidly approach Transformer baseline behavior in practice as the number of buckets increases. The class of LSH functions considered is not the same, but some intuitions gained in the study of LSH attention may carry over to BDH-GPU.
Finally, several lines of work have been devoted to making the Transformer work with longer context windows. Two distinct approaches, which work notably well, are the soft-rolling context window of the TransformerXL
(Dai etÂ al.,
2019
)
, and hierarchical attention
(Yang etÂ al.,
2016
)
. The BDH-GPU architecture is, generally, amenable to some of these extensions to the Transformerâ€™s attention mechanism, while also providing new ways to extend context length in a more uniform manner.
Networks with sparse activation.
The use of the ReLU gate as a systematic way to achieve sparse activation was, to our knowledge, first exhibited in
(Haziza etÂ al.,
2025
)
.
A recent variant of the Transformer called Spark Transformer
(You etÂ al.,
2025
)
relies on a combination of top-k operations and soft thresholding to provide a reduction in both attention and feed forward network activations compared to the Transformer, achieving neuron sparse activation of 8%. Compared to our work, the method used therein to achieve activation sparsity effects is completely different (and rather involved). Beyond the question of sparsity, BDH-GPU is not more similar to the Spark Transformer than to the Transformer.
Oscillatory SSMâ€™s.
BDH admits an interpretation at the micro-level as an oscillatory state-space network, as we outlined in Subsection
2.4
. The concept of Oscillatory State Space Models has recently been applied to time series analysis
(Rusch and Rus,
2025
)
, with the LinOSS model showing encouraging performance relative to other SSMâ€™s (such as Mamba and LSTMâ€™s) on tasks of long-horizon forecasting and time-series classification. Other than this, the use of SSMâ€™s with the form of an oscillator network has been limited to smaller scale studies. We are not aware of any successful application of oscillatory SSMâ€™s to the area of language models and reasoning in language, nor of oscillator network SSMâ€™s at scale whatsoever, prior to BDH.
BDH unifies multiple lines of intuition found across existing models, offering a coherent framework in which the components naturally align. The result is a biologically plausible reasoning model with an interpretable structure and state-of-the-art performance that has been experimentally verified.
5
Analysis: emergence of modularity and scale-free structure
Large-scale reasoning systems appear to benefit from hierarchical structuring into sub-modules. In Machine Learning, the usual approach has been to design such a modular structure, by way of assigning roles and scales to different sub-modules explicitly. Many works have postulated modules capable of representing hierarchical relationships between features of objects, e.g., capsule networks
(Sabour etÂ al.,
2017
)
. Some models have attempted to capture intelligence by recreating elements of structure recognized in brain study, going so far as to try to map functional sub-networks of the brain with empirically identified function into specific sub-modules in the design of a larger ML system, cf.
(LeCun,
2022
)
.
In this work, we propose a learnable system which ends up with modularity. We show how scale-free modular structure emerges naturally when the model is implemented by a network with local graph dynamics.
In this Section, we discuss the emergence of the structure of inter-neuron connections of BDH during training, while in Section
6
we look at its temporal activation patterns during reasoning inference.
The rest of this section is organized as follows. In Subsection
5.1
, we introduce basic concepts related to modularity and scale-free behavior of networks. We then look at the expressiveness of feedforward networks of BDH-GPU and their usefulness as a signal propagation dynamics in Subsections
5.2
and
5.3
. In Subsection
5.4
, we show theoretically how modular graph structure, with appropriate community voting mechanisms, emerges as a plausibly necessary element for the feed-forward networks
D
x
â€‹
E
{D_{x}}E
and
D
y
â€‹
E
{D_{y}}E
to function correctly. In Subsection
5.5
, we look at the corresponding empirical properties of these matrices, and the scale-free and modularity properties of the corresponding graphs
G
x
ğ”¢
{G_{x}}^{\mathfrak{e}}
and
G
y
ğ”¢
{G_{y}}^{\mathfrak{e}}
of the underlying BDH graph dynamics.
5.1
Background: modularity and scale-free property of systems
Importance of modularity for information propagation.
Graph systems serving a function related to information propagation tend to achieve modular graph structure, and rely on it to obtain the most desirable tradeoff between efficiency and accuracy of the system dynamics. Such emergence of â€œhidden structureâ€ may be observed e.g.Â through topic specialization of system regions, or through the coordinated voting behavior among nodes which organize themselves into communities, admitting higher local density. This type of graph community self-organization has two main advantages over a system with an explicit partition into subsystems. First, it allows nodes to belong to multiple communities, and to act as bridges between them. Second, it allows the scale and relationship between communities to evolve over time, as their relative importance changes or new connections emerge.
Historically, the crucial role of emergent modular structure for systems tasked with efficient knowledge retrieval at scale was first observed in the context of the World Wide Web before the year 2000, notably in the transition from catalogue-based systems (DMOZ Open Directory Project, craigslist, etc.) to naturally evolving systems based on webs of knowledge (Wikipedia, etc.), interlinked topic-based communities (reddit, etc.), and reliance on evolving network link structure for assigning expert weights to nodes in a voting process (Google PageRank, etc.). Formalization of modular properties followed soon after, with the mostly commonly used definition of modularity being proposed by Newman in
2006
. The main theoretical reference for studies of modularity is the Stochastic Block Model
(Holland etÂ al.,
1983
)
and its later generalizations, e.g., to hierarchical settings. While the definition of Newman modularity is not (efficiently) constructive, it can in practice be closely approximated by greedy algorithms
(Blondel etÂ al.,
2008
)
or spectral approaches
(MassouliÃ©,
2014
)
.
Scale-free property.
The scale-free property of natural systems dealing with information processing is generally accepted as a manifestation of their operation at criticality. This refers to operation within a regime where they are both sufficiently stable to enable efficient information retrieval in the short-term, and sufficiently adaptable to be able change their behavior abruptly as new knowledge inputs become available, invalidating previous paths of reasoning or knowledge retrieval. The generally accepted definition of scale-free behavior of such a dynamical system assumes that the likelihood of a new piece of information (or other localized innovation to the system) to affect
n
â€²
n^{\prime}
nodes of the system, for any
n
â€²
<
n
n^{\prime}<n
, should by polynomially large in
1
/
n
â€²
1/n^{\prime}
. For most information propagation dynamics, under certain uniformity assumptions, e.g., that the new piece of information arrives at a uniformly random node of the system, a usual necessary (not sufficient) condition for scale-free property is for the distribution of node degrees to follow a power-law distribution.
In the practice of applied sciences studying real-world network phenomena, and in the absence of the possibility to perform more in-depth analysis, power-law degree distributions are sometimes equated with scale-free behavior. One notable research application involves modeling of extreme events: understanding scale-free behavior allows researchers to make predictions about rare, large events from data on smaller, more common ones.
For systems with known local graph dynamics, like those considered here, more refined analysis of scale-free properties are possible. We nonetheless also report heavy-tailed degree behavior as the most obvious lithmus test indicator of scale-free operation of the system.
5.2
BDH-GPU feed-forward network with the â€˜ReLU-lowrankâ€™ block
Low-rank matrices have been considered in multiple contexts of Machine Learning, from preference vectors to Internet latency estimation. In the setting of the Transformer, low-rank matrices form the basis of weight-matrix approximations such as LoRA
(Hu etÂ al.,
2021
)
.
The ReLU-lowrank block of BDH-GPU captures different properties than the above settings. Its most important effects for BDH-GPU are related to noise reduction, and faithful representation of a certain class of affinity functions on sparse positive vectors. This makes it suitable for use in combination with Linear Attention blocks. We discuss this point further in this Section.
Definition of ReLU-lowrank.
The parameters of BDH-GPU are concentrated in three matrices
E
,
D
x
,
D
y
E,{D_{x}},{D_{y}}
. The encoder matrix
E
E
transforms length-
n
n
vectors in the neuronal layer into length-
d
d
vectors in the hidden layer. The two decoder matrices
D
âˆˆ
{
D
x
,
D
y
}
D\in\{{D_{x}},{D_{y}}\}
transform length-
d
d
vectors in the hidden layer back to the neuronal layer.
We consider the
ReLU-lowrank
operation of passing through the encoder, one of the decoders, and a ReLU gate (cf. Eq.Â (
LABEL:eq:bdhnoln
)), mapping vectors
z
âˆˆ
R
n
z\in R^{n}
into
f
D
â€‹
E
â€‹
(
z
)
âˆˆ
R
n
f_{DE}(z)\in R^{n}
as follows:
z
â†¦
f
D
â€‹
E
â€‹
(
z
)
:=
(
D
â€‹
E
â€‹
z
)
+
.
z\mapsto f_{DE}(z):=\left(DEz\right)^{+}.
(10)
We note that the output
f
D
â€‹
E
â€‹
(
z
)
âˆˆ
(
R
+
)
n
f_{DE}(z)\in(R^{+})^{n}
always, and that in BDH-GPU we also always have
z
âˆˆ
(
R
+
)
n
z\in(R^{+})^{n}
.
Expressiveness of ReLU-lowrank in BDH-GPU and MLP in the Transformer.
A single ReLU-lowrank block can be compared to a single MLP block of the Transformer. A different comparison provides closer matching of dimensions and structure of nonlinearities, by considering a single ReLU-lowrank with respect to a portion of the Transformer corresponding to the second MLP layer in an MLP block, i.e., starting with the hidden layer of neurons of the MLP in some layer
l
l
, skipping attention blocks, and followed by the â€˜firstâ€™ linear layer of the MLP in layer
l
+
1
l+1
, finally followed by the non-linearity (typically GeLU) applied in the hidden layer of neurons in layer
l
+
1
l+1
. Either approach to expressiveness is valid to the extent where we analyze similarities between one architecture with
L
L
layers and the other with â€œ
O
â€‹
(
L
)
O(L)
â€ layers.
In the spirit of universal approximation theorem frameworks, a (deep) layer-
L
L
stacking of Transformerâ€™s MLP block with ReLU activation, for Transformer latent dimension
D
D
and MLP hidden layer dimension
c
â€‹
D
cD
(e.g., for
c
=
4
c=4
), is eventually (i.e., for
L
â†’
+
âˆ
L\to+\infty
) a universal approximator for all vector functions up to dimension
D
âˆ’
O
â€‹
(
1
)
D-O(1)
(Shen etÂ al.,
2022
)
. A similar universal approximation result eventually (i.e., for
L
â†’
+
âˆ
L\to+\infty
) holds up to function dimension
n
n
for residual ReLU-lowrank networks
(Lin and Jegelka,
2018
)
, however the convergence rate in
L
L
is slower due to the smaller size of the hidden layer. These results translate directly to BDH-GPU architecture which also relies on ReLU with residual connections between layers. To summarize informally, for a Transformer with latent dimension
D
D
and BDH-GPU with hidden dimension
d
d
, we expect their feed-forward networks to be comparably expressive (though usually without strict mathematical equivalence) as function approximators for functions up to some dimension
d
â€²
,
d
<
d
â€²
<
D
d^{\prime},d<d^{\prime}<D
, between
d
â€²
d^{\prime}
and
D
D
the Transformer can express a richer class of functions, and between
D
D
and
n
n
, BDH-GPU can approximate some functions, whereas the Transformer does not use such high dimension in its vector representations.
We remark that in all cases, regardless of expressiveness of feed-forward mechanisms, BDH-GPU is set up so that it is only using inputs and producing outputs within the positive orthant,
(
R
+
)
n
â†¦
(
R
+
)
n
(R^{+})^{n}\mapsto(R^{+})^{n}
.
The main point to consider is:
what classes of useful high-dimensional functions in the positive orthant does ReLU-lowrank naturally express?
5.3
ReLU-lowrank as a signal propagation dynamics
Error of low-rank approximation (without ReLU).
Consider
R
n
R^{n}
as a space spanned by a fixed set of
n
n
orthogonal unit basis vectors
V
=
{
v
1
,
â€¦
,
v
n
}
V=\{v_{1},\ldots,v_{n}\}
, called
nodes
.
The low-rank operation can be used to approximate affinities between pairs of nodes, in the following sense. For a given matrix
G
â€²
âˆˆ
R
n
Ã—
n
G^{\prime}\in R^{n\times n}
, consider low-rank matrices
D
âˆˆ
R
n
Ã—
d
,
E
âˆˆ
R
d
Ã—
n
D\in R^{n\times d},E\in R^{d\times n}
, such that
G
:=
D
â€‹
E
G:=DE
approximates
G
â€²
G^{\prime}
pointwise.
13
13
13
Elements of
G
G
can be computed pointwise by each pair of nodes:
V
Ã—
V
âˆ‹
(
v
1
,
v
2
)
â†¦
G
:=
v
1
T
â€‹
D
â€‹
E
â€‹
v
2
âˆˆ
R
V\times V\ni(v_{1},v_{2})\mapsto G:={v_{1}}^{T}DE{v_{2}}\in R
.
Assume
â€–
G
â€²
â€–
1
,
âˆ
â‰¤
1
\|G^{\prime}\|_{1,\infty}\leq 1
. An application of the Johnson-Lindenstrauss lemma shows that the following bound holds in the infinity norm:
â€–
G
â€²
âˆ’
G
â€–
max
=
O
â€‹
(
log
â¡
n
/
d
)
\|G^{\prime}-G\|_{\max}=O(\sqrt{\log n\ /\ d})
(cf. e.g.
(Udell and Townsend,
2019
; Budzinskiy,
2025
)
). Then, for
z
âˆˆ
R
n
=
R
|
V
|
z\in R^{n}=R^{|V|}
with
â€–
z
â€–
1
â‰¤
1
\|z\|_{1}\leq 1
, we have:
â€–
G
â€²
â€‹
z
âˆ’
G
â€‹
z
â€–
+
âˆ
=
O
â€‹
(
log
â¡
n
/
d
)
\|G^{\prime}z-Gz\|_{+\infty}=O(\sqrt{\log n\ /\ d})
(11)
However, no similar bound holds for
â€–
G
â€²
â€‹
z
âˆ’
G
â€‹
z
â€–
2
\|G^{\prime}z-Gz\|_{2}
. Even for â€˜simpleâ€™ scenarios like the identity transformation
G
â€²
=
I
n
G^{\prime}=I_{n}
, the best low-rank approximation admits O(1) additive error in the L2-norm for almost all inputs, and even greater distortion (approaching
n
\sqrt{n}
) may appear in the L1-norm.
This makes the low-rank operation useful for determining affinity of pairs of coordinates in dimension
n
n
, but more problematic as a vector transformation function. However, the ReLU-lowrank mechanism (Eq.Â (
10
) is able to suppress a part of the noise of the linear low-rank map, allowing to approximate a sufficiently broad class of non-linear operations.
Expressiveness of ReLU-lowrank for Markov chain propagation.
We will consider positive inputs
z
âˆˆ
R
+
n
z\in R^{+n}
, focusing on sparse vectors.
One important case concerns approximating a Markov chain transformation
z
â†¦
G
â€²
â€‹
z
z\mapsto G^{\prime}z
, for some
G
â€²
âˆˆ
R
+
n
Ã—
n
G^{\prime}\in R+^{n\times n}
. For such a transformation in the positive orthant, adding the ReLU operation to the linear map does not change anything directly,
G
â€²
â€‹
z
=
(
G
â€²
â€‹
z
)
+
G^{\prime}z=\left(G^{\prime}z\right)^{+}
. However, when considering a low-rank matrix
G
G
, the non-linear transformation
(
G
â€‹
z
)
+
\left(Gz\right)^{+}
can provide a closer approximation of
G
â€²
â€‹
z
G^{\prime}z
for some classes of input vectors
z
z
, than the low-rank linear operation
G
â€‹
z
Gz
.
We start with the following illustrative example.
Claim 5
(propagating a Markov chain)
.
Let
G
â€²
G^{\prime}
be the random walk matrix of a directed graph with out-degree
r
r
(i.e., a stochastic matrix with
r
r
non-zero entries of
1
/
r
1/r
in each row), and let
v
âˆˆ
V
v\in V
be a node (basis vector),
â€–
v
â€–
1
=
â€–
v
â€–
2
=
1
\|v\|_{1}=\|v\|_{2}=1
. Then, for any
Îµ
>
0
\varepsilon>0
, there exists
d
=
O
â€‹
(
r
3
â€‹
log
â¡
n
/
Îµ
)
d=O(r^{3}\log n/\varepsilon)
such that for some matrices
D
âˆˆ
R
n
Ã—
d
,
E
âˆˆ
R
d
Ã—
n
D\in R^{n\times d},E\in R^{d\times n}
, we have
â€–
G
â€²
â€‹
v
âˆ’
f
D
â€‹
E
â€‹
(
v
)
â€–
1
=
O
â€‹
(
Îµ
)
\|G^{\prime}v-f_{DE}(v)\|_{1}=O(\varepsilon)
.
Proof (sketch).
Let
D
âˆ—
âˆˆ
R
n
Ã—
(
d
âˆ’
1
)
D^{*}\in R^{n\times(d-1)}
,
E
âˆ—
âˆˆ
R
(
d
âˆ’
1
)
Ã—
n
E^{*}\in R^{(d-1)\times n}
denote matrices
D
D
,
E
E
restricted to all but the last coordinate in dimension
d
d
. Pick
D
,
E
D,E
so that
â€–
G
â€²
â€‹
v
âˆ’
D
âˆ—
â€‹
E
âˆ—
â€‹
v
â€–
âˆ
<
Îµ
âˆ—
\|G^{\prime}v-D^{*}E^{*}v\|_{\infty}<\varepsilon^{*}
, where
Îµ
âˆ—
=
Îµ
/
r
\varepsilon^{*}=\varepsilon/r
, following Eq.Â (
11
) (we have
â€–
G
â€²
â€–
1
,
âˆ
â‰¤
1
\|G^{\prime}\|_{1,\infty}\leq 1
by stochasticity of
G
â€²
G^{\prime}
). Further, set a fixed bias, placing
1
1
on all entries of the last coordinate in dimension
d
d
of
D
D
, and
âˆ’
Îµ
âˆ—
-\varepsilon^{*}
on all entries of the corresponding last coordinate in dimension
d
d
of
E
E
. Taking into account this bias, we now have
â€–
(
G
â€²
â€‹
v
âˆ’
Îµ
âˆ—
â€‹
ğŸ
)
âˆ’
D
â€‹
E
â€‹
v
â€–
âˆ
<
Îµ
âˆ—
\|(G^{\prime}v-\varepsilon^{*}\mathbf{1})-DEv\|_{\infty}<\varepsilon^{*}
.
For all coordinates
v
j
âˆˆ
V
v_{j}\in V
such that
v
j
T
â€‹
G
â€²
â€‹
v
=
0
{v_{j}}^{T}G^{\prime}v=0
, we now have
v
j
T
â€‹
D
â€‹
E
â€‹
v
<
0
{v_{j}}^{T}DEv<0
, hence also
v
j
T
â€‹
f
D
â€‹
E
â€‹
(
v
)
=
0
{v_{j}}^{T}f_{DE}(v)=0
. For all other coordinates
v
j
v_{j}
, we have
v
j
T
â€‹
G
â€²
â€‹
v
=
1
/
r
{v_{j}}^{T}G^{\prime}v=1/r
, and
1
/
r
âˆ’
2
â€‹
Îµ
âˆ—
<
v
j
T
â€‹
f
D
â€‹
E
â€‹
(
v
)
â‰¤
1
/
r
1/r-2\varepsilon^{*}<{v_{j}}^{T}f_{DE}(v)\leq 1/r
. Thus,
â€–
G
â€²
â€‹
v
âˆ’
f
D
â€‹
E
â€‹
(
v
)
â€–
1
â‰¤
2
â€‹
Îµ
âˆ—
â€‹
r
\|G^{\prime}v-f_{DE}(v)\|_{1}\leq 2\varepsilon^{*}r
, and the claim follows.
14
14
14
As a point of elegance, we note that in this proof,
v
j
T
â€‹
f
D
â€‹
E
â€‹
(
v
)
â‰¤
1
/
r
{v_{j}}^{T}f_{DE}(v)\leq 1/r
, so
f
D
â€‹
E
â€‹
(
v
)
f_{DE}(v)
was not an
unbiased
estimator of
G
â€²
â€‹
v
G^{\prime}v
. This is easily fixed in the first-order by introducing a global multiplicative bias of
(
1
+
Îµ
âˆ—
)
(1+\varepsilon^{*})
to the approximation, for example, substituting:
(
1
+
Îµ
âˆ—
)
â€‹
D
â†¦
D
(1+\varepsilon^{*})D\mapsto D
.
âˆ
The above observation shows how ReLU-lowrank deals with one specific class of graph affinity functions (random walks of adjacency of sparse graphs), for transformations of vectors which are nodes in our distinguished basis. We use this example as it is the simplest case which exhibits the benefit of threshold non-linearity: for basis vectors, the operation
f
D
â€‹
E
f_{DE}
captures a basic propagation effect which is well known (in general) to require a
full-rank
matrix
G
â€²
âˆˆ
R
n
Ã—
n
G^{\prime}\in R^{n\times n}
if relying only on linear operations.
Propagation and reinforcement of signal.
The same thresholding approach, as discussed for Markov chains, turns out to be applicable to a wider class of signal propagation dynamics. It consists in first obtaining a positive-valued signal with heavy random noise, then applying a negative bias, and finally using the ReLU gate to act as a noise threshold.
Any linear function
G
â€²
G^{\prime}
can be represented with a hidden layer of
s
â‰¤
n
2
s\leq n^{2}
nodes, through two matrices
D
â€²
âˆˆ
R
+
n
Ã—
s
D^{\prime}\in R^{+n\times s}
and
E
â€²
âˆˆ
R
+
n
Ã—
s
E^{\prime}\in R^{+n\times s}
, such that:
G
â€²
=
D
â€²
â€‹
E
â€²
.
G^{\prime}=D^{\prime}E^{\prime}.
The above holds in general, and we will refer to such a representation of
G
â€²
G^{\prime}
as having a sparse hidden (synaptic) layer. We will consider now the question of expressing non-negative functions,
G
â€²
âˆˆ
(
R
+
)
n
Ã—
n
G^{\prime}\in(R^{+})^{n\times n}
. An example of a valid representation of
G
â€²
G^{\prime}
is given through a node-edge incidence representation,
D
i
,
(
i
âˆ’
1
)
â€‹
n
+
j
â€²
=
E
(
i
âˆ’
1
)
â€‹
n
+
j
,
j
â€²
=
G
i
â€‹
j
â€²
D^{\prime}_{i,(i-1)n+j}=E^{\prime}_{(i-1)n+j,j}=\sqrt{G^{\prime}_{ij}}
, but usually this representation is not optimal in terms of the number of non-zero entries of
D
â€²
D^{\prime}
and
E
â€²
E^{\prime}
.
In general, any low-rank approximation of
G
G
can be equivalently expressed as
G
â‰ˆ
D
â€²
â€‹
P
D
â€‹
P
E
T
â€‹
E
â€²
G\approx D^{\prime}P_{D}P_{E}^{T}E^{\prime}
, for some two matrices,
P
D
,
P
E
âˆˆ
R
s
Ã—
d
P_{D},P_{E}\in R^{s\times d}
. We will consider the most common class of low-rank approximations obtained by taking
P
D
=
P
E
=
P
âˆ¼
ğ’©
â€‹
(
0
,
1
)
s
Ã—
d
/
d
P_{D}=P_{E}=P\sim\mathcal{N}(0,1)^{s\times d}/\sqrt{d}
. Consider a vector
z
z
passing through the ReLU-lowrank operation, and the following vectors
u
âˆˆ
R
s
u\in R^{s}
,
w
âˆˆ
R
n
w\in R^{n}
:
u
\displaystyle u
:=
E
â€²
â€‹
z
\displaystyle:=E^{\prime}z
w
\displaystyle w
:=
D
â€²
â€‹
P
â€‹
P
T
â€‹
u
\displaystyle:=D^{\prime}PP^{T}u
If
v
i
T
â€‹
z
v_{i}^{T}z
has the interpretation of a signal being sent by node
v
i
v_{i}
, then
u
u
is the encoded message being passed through the hidden layer of the network, and
v
j
T
â€‹
w
v_{j}^{T}w
is the message received by node
v
j
v_{j}
.
5.4
Modularity in BDH-GPU signal propagation
We are now ready to capture the essence of the signal propagation and reinforcement capability of the ReLU-lowrank system. To describe the conditions under which a neuron is able to decide whether it should, or should not activate. By a standard analysis of independent Gaussians, we have the following probabilistic statement, under random choice of
P
P
.
Claim 6
(selective neuron activation)
.
Suppose that the signal of
u
u
is uniformly concentrated on a set of nodes
A
A
of the hidden layer, i.e., for some subset
A
A
of indexes of the hidden layer, we have
u
Î±
Â¯
=
0
u_{\bar{\alpha}}=0
for
Î±
Â¯
âˆ‰
A
\bar{\alpha}\not\in A
, and
u
Î±
Â¯
âˆˆ
[
1
âˆ’
Îº
|
A
|
,
1
+
Îº
|
A
|
]
u_{\bar{\alpha}}\in[\frac{1-\kappa}{\sqrt{|A|}},\frac{1+\kappa}{\sqrt{|A|}}]
for
Î±
Â¯
âˆˆ
A
\bar{\alpha}\in A
, so that
â€–
u
â€–
2
âˆˆ
[
1
âˆ’
Îº
,
1
+
Îº
]
\|u\|_{2}\in[1-\kappa,1+\kappa]
for some small constant
Îº
â‰¥
0
\kappa\geq 0
. Suppose each node
v
j
âˆˆ
V
v_{j}\in V
is connected in
D
â€²
D^{\prime}
to some set of nodes
B
j
B_{j}
in the hidden layer,
B
j
=
{
Î²
Â¯
:
D
j
,
Î²
Â¯
â€²
â‰ 
0
}
B_{j}=\{\bar{\beta}:D^{\prime}_{j,\bar{\beta}}\neq 0\}
, and let these connections weight be drawn uniformly
D
j
,
Î²
Â¯
â€²
âˆˆ
[
1
âˆ’
Îº
|
B
j
|
,
1
+
Îº
|
B
j
|
]
D^{\prime}_{j,\bar{\beta}}\in[\frac{1-\kappa}{\sqrt{|B_{j}|}},\frac{1+\kappa}{\sqrt{|B_{j}|}}]
for
Î²
Â¯
âˆˆ
B
j
\bar{\beta}\in B_{j}
. Let
C
j
=
A
âˆ©
B
j
C_{j}=A\cap B_{j}
. Define the ratio:
Ï±
:=
|
C
j
|
|
A
|
â‹…
|
C
j
|
|
B
j
|
.
\varrho:=\left.\sqrt{\frac{|C_{j}|}{|A|}\cdot\frac{|C_{j}|}{|B_{j}|}}.\right.
Then, there exists an absolute constant
c
>
0
c>0
, such that for any value of
w
j
w_{j}
(where we recall that
w
:=
D
â€²
â€‹
P
â€‹
P
T
â€‹
u
w:=D^{\prime}PP^{T}u
), we have:
Pr
â¡
[
w
j
â‰¥
(
1
âˆ’
Îº
)
2
â€‹
Ï±
âˆ’
c
â€‹
log
â¡
n
/
d
]
=
1
âˆ’
O
â€‹
(
1
/
n
)
and
Pr
â¡
[
w
j
â‰¤
(
1
+
Îº
)
2
â€‹
Ï±
+
c
â€‹
log
â¡
n
/
d
]
=
1
âˆ’
O
â€‹
(
1
/
n
)
.
\Pr\left[w_{j}\geq(1-\kappa)^{2}\varrho-c\sqrt{\log n\ /\ d}\right]=1-O(1/n)\quad\textrm{and}\quad\Pr\left[w_{j}\leq(1+\kappa)^{2}\varrho+c\sqrt{\log n\ /\ d}\right]=1-O(1/n).
(12)
Thus, the value of
w
j
w_{j}
can be used by a neuron to obtain an estimation of
Ï±
\varrho
, and apply a threshold to activate accordingly.
âˆ
Proof.
Observe that
w
j
=
(
P
T
â€‹
D
j
,
â‹…
â€²
)
T
â€‹
(
P
T
â€‹
u
)
w_{j}={(P^{T}D^{\prime}_{j,\cdot})}^{T}{(P^{T}u)}
. As
â€–
D
j
,
â‹…
â€²
â€–
2
âˆˆ
[
1
âˆ’
Îº
,
1
+
Îº
]
\|D^{\prime}_{j,\cdot}\|_{2}\in[1-\kappa,1+\kappa]
, a standard application of Johnson-Lindenstrauss to vector inner products gives
Pr
â¡
[
|
w
j
âˆ’
D
j
,
â‹…
â€²
T
â€‹
u
|
â‰¤
c
â€‹
log
â¡
n
/
d
]
=
1
âˆ’
O
â€‹
(
1
/
n
)
\Pr\left[|w_{j}-{D^{\prime}_{j,\cdot}}^{T}{u}|\leq c\sqrt{\log n\ /\ d}\right]=1-O(1/n)
for
c
c
large enough. Since
D
j
,
â‹…
â€²
T
â€‹
u
âˆˆ
[
(
1
âˆ’
Îº
)
2
â€‹
Ï
,
(
1
+
Îº
)
2
â€‹
Ï
]
{D^{\prime}_{j,\cdot}}^{T}{u}\in[(1-\kappa)^{2}\rho,(1+\kappa)^{2}\rho]
, the claim follows.
âˆ
Figure 8:
The ReLU-lowrank feedforward network of BDH-GPU allows neurons to activate when triggered by activation signals in its own community. (a) Illustration of the selective neuron activation pattern in the proof of Claim
6
, showing the activation decision of node
v
j
v_{j}
(left) based on active set
A
A
in the sparse hidden layer. (b) Illustration of Eq.Â (
12
) showing the relationship between sizes of sets in the sparse hidden layer: active set
A
A
, set
B
j
B_{j}
connected to neuron
v
j
v_{j}
, and the intersection
C
j
=
A
âˆ©
B
j
C_{j}=A\cap B_{j}
: neuron
v
j
1
v_{j_{1}}
becomes active, but neuron
v
j
2
v_{j_{2}}
does not.
The ReLU-lowrank operation
f
D
â€‹
E
f_{DE}
, after adding appropriate negative bias, can thus be used to propagate positive affinity functions
G
â€²
G^{\prime}
on input vectors, performing the following form of thresholding: neurons
j
j
in the output layer individually compute a form of local â€œF-scoreâ€
Ï±
\varrho
given byÂ Eq.Â (
12
) of the activation of the positive sparse hidden layer, and decide based on it whether they are good match for the output activation; if the threshold condition on
Ï±
\varrho
is not met, the neuron
j
j
does not activate in the output vector (see Fig.
8
for an illustration).
EquationÂ (
12
) naturally coincides with a pattern of communication within network graphs
G
â€²
G^{\prime}
admitting positive Newman modularity
(Newman,
2006
)
, allowing nodes
v
j
v_{j}
to correctly receive messages
u
u
which in the hidden layer primarily reached a denser cluster of
G
â€²
G^{\prime}
containing
v
j
v_{j}
. For a specific illustration, let
H
H
be an undirected
k
k
-block stochastic block model (SBM) network
(Karrer and Newman,
2011
)
with
k
âˆˆ
â„•
k\in\mathbb{N}
blocks of
n
/
k
n/k
nodes each, in-block edge density
p
p
and out-of-block edge density
q
<
p
q<p
. We put
G
â€²
:=
D
â€²
â€‹
E
â€²
=
H
2
G^{\prime}:=D^{\prime}E^{\prime}=H^{2}
, i.e., the first connection layer of
G
â€²
G^{\prime}
is
E
â€²
=
H
E^{\prime}=H
and the second connection layer is also
D
â€²
=
H
D^{\prime}=H
. Suppose that
H
H
is a random SBM graph with positive Newman modularity separated from
0
, i.e., let
Î¼
=
k
âˆ’
1
k
â€‹
p
âˆ’
q
p
+
(
k
âˆ’
1
)
â€‹
q
>
0
\mu=\frac{k-1}{k}\frac{p-q}{p+(k-1)q}>0
. Following ClaimÂ (
6
) with
Îº
=
0
\kappa=0
, we can find a ReLU-lowrank representation
G
G
to achieve a communication scheme on
G
â€²
G^{\prime}
, such that a message sent from one node
z
=
v
i
z=v_{i}
activates a node
v
j
v_{j}
when
i
i
and
j
j
are in the same block with probability
1
âˆ’
O
â€‹
(
1
/
n
)
1-O(1/n)
, and with probability
O
â€‹
(
1
/
n
)
O(1/n)
otherwise, when
Î¼
>
1
p
â€‹
log
â¡
n
/
d
\mu>\frac{1}{p}\sqrt{\log n\ /\ d}
.
We thus make the following intuitive observation.
Observation 6
(in-cluster signal reinforcement)
.
The ReLU-lowrank representation of
BDH-GPU
â€‹
(
n
,
d
)
\textrm{BDH-GPU}(n,d)
is sufficient to represent in-cluster information spreading dynamics in models of graphs with constant in-cluster density and arbitrarily small positive modularity (such as the
k
k
-cluster Stochastic Block Model) when
d
/
log
â¡
n
=
Ï‰
â€‹
(
1
)
d/\log n=\omega(1)
is an arbitrarily slowly growing function.
While Claim
6
and Observation
6
are made with reference to an almost-uniform distribution of signal
u
u
on the set of nodes of the middle layer,
u
u
can have (and in practice does have) a distribution of density which is non-uniform, e.g., going across
a
=
O
â€‹
(
log
â¡
n
)
a=O(\log n)
different clustering scales, with a
(
1
/
a
)
(1/a)
-fraction of the signal represented at each scale. This allows neurons in the output layer to combine a smaller number of strong signals in its local cluster, with a larger number of weaker ones spread more globally. Such an approach coincides with the observed structure of the graph
D
â€²
â€‹
E
â€²
D^{\prime}E^{\prime}
, discussed in Subsection
5.5
.
Supermodularity on input perturbation.
We clarify how the properties of function
f
D
â€‹
E
:
(
R
+
)
n
â†’
(
R
+
)
n
f_{DE}:(R^{+})^{n}\to(R^{+})^{n}
relate to the previously discussed ability to make an input signal resonate â€œwithin a moduleâ€ in a graph with hidden modular structure. First, note that
f
D
â€‹
E
f_{DE}
is a subadditive function, but is not submodular in general
with respect to the set of
n
n
coordinates of its input vector. In some of the regimes in which it appears to be operating, locally
f
D
â€‹
E
f_{DE}
exhibits a form of behavior opposite to submodularity, referred to as â€˜supermodularityâ€™, or â€˜increasing returnsâ€™ of adding new coordinates to the input vector. This is already implicitly captured by Claim
6
, but we can consider a simpler example.
Take a variant of the setting from Observation
5
with the same choice of
G
â€²
G^{\prime}
, and let
z
âˆˆ
(
R
+
)
n
z\in(R^{+})^{n}
and biases of
D
D
be chosen so that all coordinates of
D
â€‹
E
â€‹
z
DEz
are approximately equal to
âˆ’
1.5
/
r
Â±
o
â€‹
(
1
)
-1.5/r\pm o(1)
(this can be done by choosing e.g.
z
j
=
1
/
n
z_{j}=1/n
). Then,
f
D
â€‹
E
â€‹
(
z
)
=
0
f_{DE}(z)=0
, and for any
v
i
,
v
j
âˆˆ
V
v_{i},v_{j}\in V
,
f
D
â€‹
E
â€‹
(
z
+
v
i
)
=
0
f_{DE}(z+v_{i})=0
a.s.,
f
D
â€‹
E
â€‹
(
z
+
v
j
)
=
0
f_{DE}(z+v_{j})=0
a.s., but
f
D
â€‹
E
â€‹
(
z
+
v
i
+
v
j
)
f_{DE}(z+v_{i}+v_{j})
has non-zero coordinates a.s. with values approximately
1
/
2
â€‹
r
1/{2r}
, for all nodes
v
k
v_{k}
which are common out-neighbor nodes of
v
i
v_{i}
and
v
j
v_{j}
, i.e., for all
k
k
such that
G
â€²
â€‹
(
v
i
,
v
k
)
=
G
â€²
â€‹
(
v
j
,
v
k
)
=
1
/
r
G^{\prime}(v_{i},v_{k})=G^{\prime}(v_{j},v_{k})=1/r
. This mechanism generalizes to finding common neighborhoods which have many connections to two given subsets of nodes,
V
a
V_{a}
and
V
b
V_{b}
. In a setting where the considered affinity
G
â€²
G^{\prime}
is bi-directional (e.g., a symmetric matrix), this corresponds to finding shortcut nodes, allowing to go from
V
a
V_{a}
to
V
b
V_{b}
.
It follows that the neighborhood-reinforcing nature of the threshold dynamics of BDH-GPU, which plausibly follows from the logic of its role in inference and from the needs for an efficient computational process, is starkly different from the more often studied submodular behavior of threshold and cascade dynamics on real-world networks
(Kempe etÂ al.,
2003
)
, and plausibly, much less smooth when considered as a dynamical process.
5.5
Empirical findings: parameter distribution in ReLU-lowrank matrix products
We consider the
D
D
matrices (in the same way
D
y
{D_{y}}
and
D
x
{D_{x}}
) and
E
E
matrix obtained after training of BDH-GPU models, and used in the ReLU-lowrank operation Eq.Â (
10
),
f
D
â€‹
E
â€‹
(
z
)
=
(
D
â€‹
E
â€‹
z
)
+
f_{DE}(z)=\left(DEz\right)^{+}
.
Choice of prior of matrix parameter distributions.
Following the discussion in Section
5.4
, we expect matrix
G
:=
D
â€‹
E
G:=DE
to reflect the clustering (modularity) structure of the neuron-neuron communication graph. Any plausible parameter distribution of matrix
G
G
must therefore allow heavy-tailed distribution of entries. At the same time, a Gaussian noise term is inherent to low-rank matrix representation, and needs to be taken into account together with this heavy-tailed distribution.
We now provide a somewhat more fine-grained explanation, which leads to the prior on the structure of matrix
G
G
as given by Eq.Â (
13
). Consider a training set-up in which the ReLU-lowrank operation described by matrix
G
G
is treated as an approximation of the same operation, governed by a high-rank matrix
G
â€²
G^{\prime}
, with
f
â€²
â€‹
(
z
)
:=
(
G
â€²
â€‹
z
)
+
f^{\prime}(z):=\left(G^{\prime}z\right)^{+}
. Considering this block in isolation from the rest of the training system, the training of matrices
D
D
,
E
E
goal corresponds to learning an approximation of
f
â€²
f^{\prime}
, with
D
âˆˆ
R
n
,
d
,
E
âˆˆ
R
n
,
d
D\in R^{n,d},E\in R^{n,d}
, such that
f
â€‹
(
z
)
â‰ˆ
f
â€²
â€‹
(
z
)
f(z)\approx f^{\prime}(z)
holds for some class of vectors
z
z
.
For the rest of this analysis, we will consider the function
f
â€²
f^{\prime}
as a ground truth reference for the intended operation of the ReLU-lowrank block. This type of analysis can be seen as plausible over short time spans in later phases of training of a BDH-GPU model, i.e., once individual neurons in
R
n
R^{n}
have started to admit semantic or functional meaning, and so when function
D
â€²
â€‹
E
â€²
D^{\prime}E^{\prime}
describes a property of the problem being solved in a (frozen) concept space, and not a co-learning process between the representation of the concept space in
R
n
R^{n}
and the functions applied to it.
We can represent
G
â€²
:=
D
â€²
â€‹
E
â€²
G^{\prime}:=D^{\prime}E^{\prime}
, where
D
â€²
âˆˆ
R
n
,
s
D^{\prime}\in R^{n,s}
,
E
â€²
âˆˆ
R
s
,
n
E^{\prime}\in R^{s,n}
, with
s
=
O
â€‹
(
n
2
)
s=O(n^{2})
, are in general matrices of rank
n
n
; we have
f
â€²
â€‹
(
z
)
:=
(
D
â€²
â€‹
E
â€²
â€‹
z
)
+
f^{\prime}(z):=\left(D^{\prime}E^{\prime}z\right)^{+}
. Without loss of generality, we can choose from among the possible representations one with the following distribution of positive and negative elements:
D
â€²
âˆˆ
(
R
+
)
n
,
s
D^{\prime}\in(R^{+})^{n,s}
,
E
â€²
=
E
â€²
ğ”¢
âˆ’
E
â€²
ğ”¦
E^{\prime}={E^{\prime}}^{\mathfrak{e}}-{E^{\prime}}^{\mathfrak{i}}
, with
E
â€²
ğ”¢
,
E
â€²
ğ”¦
âˆˆ
(
R
+
)
s
,
n
{E^{\prime}}^{\mathfrak{e}},{E^{\prime}}^{\mathfrak{i}}\in(R^{+})^{s,n}
. We will write:
G
â€²
=
G
â€²
ğ”¢
âˆ’
G
â€²
ğ”¦
G^{\prime}={G^{\prime}}^{\mathfrak{e}}-{G^{\prime}}^{\mathfrak{i}}
, where
G
â€²
ğ”¢
=
D
â€²
â€‹
E
â€²
ğ”¢
{G^{\prime}}^{\mathfrak{e}}=D^{\prime}{E^{\prime}}^{\mathfrak{e}}
, and
G
â€²
ğ”¦
=
D
â€²
â€‹
E
â€²
ğ”¦
{G^{\prime}}^{\mathfrak{i}}=D^{\prime}{E^{\prime}}^{\mathfrak{i}}
. The main purpose of the chosen representation
G
â€²
=
D
â€²
â€‹
E
â€²
=
D
â€²
â€‹
(
E
â€²
ğ”¢
âˆ’
E
â€²
ğ”¦
)
G^{\prime}=D^{\prime}E^{\prime}=D^{\prime}({E^{\prime}}^{\mathfrak{e}}-{E^{\prime}}^{\mathfrak{i}})
is to have matrices
D
â€²
D^{\prime}
,
E
â€²
ğ”¦
{E^{\prime}}^{\mathfrak{i}}
,
E
â€²
ğ”¢
{E^{\prime}}^{\mathfrak{e}}
with much smaller outlying elements compared to matrix
G
â€²
G^{\prime}
, which leads to more justified conclusions about the uniform nature of the noise introduced by the low-rank decomposition.
15
15
15
For a specific example, one very broad class of matrices
G
â€²
G^{\prime}
is given by the product of sparse matrices
D
â€²
D^{\prime}
,
E
â€²
{E^{\prime}}
, in which each
s
s
-element row of
D
â€²
D^{\prime}
(column of
E
â€²
{E^{\prime}}
) has at most
Î”
â‰ª
n
\Delta\ll n
non-zero elements, each with value bounded by
O
â€‹
(
1
/
Î”
)
O(1/\sqrt{\Delta})
, and all remaining
s
âˆ’
Î”
s-\Delta
elements of these matrices are equal to
0
. The resulting elements,
G
â€²
i
â€‹
j
=
âˆ‘
Î±
D
i
,
Î±
â€²
â€‹
{
E
â€²
}
Î±
,
j
{G^{\prime}}_{i}j=\sum_{\alpha}D^{\prime}_{i,\alpha}\{E^{\prime}\}_{\alpha,j}
, may be much less uniform, only satisfying
G
â€²
i
â€‹
j
=
O
â€‹
(
1
)
{G^{\prime}}_{i}j=O(1)
. This type of scenario captures the expressiveness of set intersection for â€œbag-of-wordsâ€ models for language, or expressiveness of â€œhub labelâ€ representations for a measure of node proximity in a directed graph.
Assume now that we learn to approximate function
f
â€²
f^{\prime}
with
f
D
â€‹
E
f_{DE}
by trainable matrices
D
,
E
D,E
through the following low-rank scheme:
G
=
D
â€‹
E
:=
(
B
D
+
D
â€²
â€‹
P
)
â€‹
(
P
T
â€‹
E
â€²
+
B
E
T
)
,
G=DE:=(B_{D}+D^{\prime}P)(P^{T}E^{\prime}+B_{E}^{T}),
where
P
âˆˆ
R
s
,
d
P\in R^{s,d}
is
non-parametric
and the result of random sampling an almost-orthonormal random projection so that
P
â€‹
P
T
â‰ˆ
I
s
PP^{T}\approx I_{s}
(e.g.
P
âˆ¼
ğ’©
â€‹
(
0
,
1
/
d
)
s
,
d
P\sim\mathcal{N}(0,1/\sqrt{d})^{s,d}
), and
B
D
,
B
E
âˆˆ
R
n
,
d
B_{D},B_{E}\in R^{n,d}
represent
trainable
additional terms for compensating error or introducing bias, with the goal of minimizing some loss function
â„’
â€‹
(
f
â€²
,
f
D
â€‹
E
)
\mathcal{L}(f^{\prime},f_{DE})
. The terms
B
D
,
B
E
B_{D},B_{E}
compensate the error introduced by the approximation
P
â€‹
P
T
â‰ˆ
I
s
PP^{T}\approx I_{s}
, after the ReLU operation.
Let
Q
:=
P
â€‹
P
T
=
I
s
+
Î´
I
+
Î´
Q
Q:=PP^{T}=I_{s}+\delta_{I}+\delta_{Q}
, where
Î´
I
âˆˆ
R
s
Ã—
s
\delta_{I}\in R^{s\times s}
is a diagonal error matrix, and
Î´
Q
âˆˆ
R
s
Ã—
s
\delta_{Q}\in R^{s\times s}
is a non-diagonal (hollow) matrix. We have:
G
=
D
â€‹
E
=
(
G
â€²
ğ”¢
âˆ’
G
â€²
ğ”¦
)
+
D
â€²
â€‹
Î´
I
â€‹
(
E
â€²
ğ”¢
âˆ’
E
â€²
ğ”¦
)
+
D
â€²
â€‹
Î´
Q
â€‹
E
â€²
âŸ
Îµ
Q
+
(
B
D
â€‹
E
+
D
â€‹
B
E
T
)
âŸ
Îµ
B
.
G=DE=({G^{\prime}}^{\mathfrak{e}}-{G^{\prime}}^{\mathfrak{i}})+D^{\prime}\delta_{I}({E^{\prime}}^{\mathfrak{e}}-{E^{\prime}}^{\mathfrak{i}})+\underbrace{D^{\prime}\delta_{Q}E^{\prime}}_{\varepsilon_{Q}}+\underbrace{(B_{D}E+DB_{E}^{T})}_{\varepsilon_{B}}.
Since all elements of
D
â€²
,
E
â€²
ğ”¢
,
E
â€²
ğ”¦
D^{\prime},{E^{\prime}}^{\mathfrak{e}},{E^{\prime}}^{\mathfrak{i}}
are non-negative and
I
Î´
I_{\delta}
is diagonal, we can represent elements
G
i
â€‹
j
G_{ij}
, for
i
,
j
âˆˆ
1
,
â€¦
,
n
i,j\in 1,\ldots,n
, as follows:
G
i
â€‹
j
=
(
1
+
Îµ
Î´
â€‹
i
â€‹
j
ğ”¢
)
â€‹
G
â€²
i
â€‹
j
ğ”¢
âˆ’
(
1
+
Îµ
Î´
â€‹
i
â€‹
j
ğ”¦
)
â€‹
G
â€²
i
â€‹
j
ğ”¦
+
Îµ
Q
â€‹
i
â€‹
j
+
Îµ
B
â€‹
i
â€‹
j
G_{ij}=(1+\varepsilon_{\delta\,ij}^{\mathfrak{e}}){G^{\prime}}^{\mathfrak{e}}_{ij}-(1+\varepsilon_{\delta\,ij}^{\mathfrak{i}}){G^{\prime}}^{\mathfrak{i}}_{ij}+\varepsilon_{Q\,ij}+\varepsilon_{B\,ij}
(13)
where
|
Îµ
Î´
â€‹
i
â€‹
j
ğ”¢
|
=
O
â€‹
(
log
â¡
n
/
d
)
|\varepsilon_{\delta\,ij}^{\mathfrak{e}}|=O(\sqrt{\log n\ /\ d})
and
|
Îµ
Î´
â€‹
i
â€‹
j
ğ”¦
|
=
O
â€‹
(
log
â¡
n
/
d
)
|\varepsilon_{\delta\,ij}^{\mathfrak{i}}|=O(\sqrt{\log n\ /\ d})
have the interpretation of small multiplicative distortion.
FollowingÂ (
13
), we expect the elements of
G
G
to be distributed as the sum of four different distributions.
The term
G
â€²
i
â€‹
j
ğ”¢
{G^{\prime}}^{\mathfrak{e}}_{ij}
has the interpretation of positive ground truth elements of
G
â€²
G^{\prime}
. The term
âˆ’
G
â€²
i
â€‹
j
ğ”¦
-{G^{\prime}}^{\mathfrak{i}}_{ij}
has the interpretation of negative ground truth elements of
G
â€²
G^{\prime}
; its use in combination with the ReLU mechanism can be interpreted as inhibitory action. Both of these terms are subject to slight multiplicative distortion.
The term
Îµ
Q
â€‹
i
â€‹
j
\varepsilon_{Q\,ij}
has the interpretation of non-trainable noise (which depends only on
D
â€²
D^{\prime}
,
E
â€²
E^{\prime}
and the random choice of
P
P
). Under reasonable assumptions on outlying elements of
D
â€²
,
E
â€²
D^{\prime},E^{\prime}
, it is a form of almost-Gaussian symmetric noise inherent to the considered class of low-rank projections,
Îµ
Q
â€‹
i
â€‹
j
â†’
N
â€‹
(
0
,
Ïƒ
Q
)
\varepsilon_{Q\,ij}\rightarrow N(0,\sigma_{Q})
, for some
Ïƒ
Q
âˆˆ
R
+
\sigma_{Q}\in R^{+}
, and the expected value of this noise is typically very close to
0
, even when considering the expectation of
Îµ
Q
â€‹
i
â€‹
j
\varepsilon_{Q\,ij}
conditioned on known values of
Îµ
Q
â€‹
i
â€²
â€‹
j
â€²
\varepsilon_{Q\,i^{\prime}j^{\prime}}
for a small number of indexes
(
i
â€²
,
j
â€²
)
(i^{\prime},j^{\prime})
in the matrix.
Finally,
Îµ
B
â€‹
i
â€‹
j
\varepsilon_{B\,ij}
is a trainable term, whose norm tends to
0
as
d
d
increases. We expect it to have the interpretation of bias used to offset the low-rank Gaussian noise and perform denoising in the ReLU-gate, as previously discussed in Section
5.3
. Because of the action of the ReLU gate, we plausibly expect the distribution of
Îµ
B
â€‹
i
â€‹
j
\varepsilon_{B\,ij}
to be skewed towards negative numbers, with
0
>
ğ”¼
â€‹
Îµ
B
â€‹
i
â€‹
j
â‰«
Ïƒ
Q
0>\mathbb{E}\varepsilon_{B\,ij}\gg\sigma_{Q}
.
From the above discussion of the four terms of the sum in Eq.Â (
13
), we see that only one of these terms,
G
â€²
i
â€‹
j
ğ”¢
{G^{\prime}}^{\mathfrak{e}}_{ij}
, is expected to take values much larger than
Ïƒ
Q
\sigma_{Q}
with non-negligible probability. We reach the conclusion that a part of the relevant signal of
G
â€²
G^{\prime}
is concentrated in the right tail of large positive matrix entries of
G
G
.
Hypothesis 1
(right tail contains signal)
.
Consider the interpretation that the ReLU-lowrank transformation
z
â†¦
(
G
â€‹
z
)
+
z\mapsto\left(Gz\right)^{+}
, with
G
=
D
â€‹
E
G=DE
, has learned to act as an approximation of some other operation
z
â†¦
(
G
â€²
â€‹
z
)
+
z\mapsto\left(G^{\prime}z\right)^{+}
, where
G
â€²
G^{\prime}
has no low-rank constraint imposed on it. Then the right tail of the distribution of matrix elements of
G
G
corresponds to the right tail of the distribution of elements of
G
â€²
G^{\prime}
, starting from some positive threshold value
Ïƒ
Q
\sigma_{Q}
, associated with the noise of the low-rank decomposition. Formally, for almost all pairs of indices
i
,
j
âˆˆ
1
,
â€¦
,
n
i,j\in 1,\ldots,n
such that
G
i
â€‹
j
â‰«
Ïƒ
Q
G_{ij}\gg\sigma_{Q}
, we also have
G
â€²
i
â€‹
j
ğ”¢
â‰«
Ïƒ
Q
{G^{\prime}}^{\mathfrak{e}}_{ij}\gg\sigma_{Q}
.
The converse implication, that
G
â€²
i
â€‹
j
ğ”¢
â‰«
Ïƒ
Q
{G^{\prime}}^{\mathfrak{e}}_{ij}\gg\sigma_{Q}
implies
G
i
â€‹
j
â‰«
Ïƒ
Q
{G}_{ij}\gg\sigma_{Q}
, also plausibly holds under some stronger assumptions on the form of biases
Îµ
B
â€‹
i
â€‹
j
\varepsilon_{B\,ij}
which may follow from minimizing training error for the specific inference task considered.
This direct method of decoding
G
G
from
G
â€²
G^{\prime}
does not extend from the right tail towards the center of the distribution. For the choices of
n
,
d
n,d
we make, we expect the term dominating most elements of matrix
G
G
to be
Îµ
Q
â€‹
i
â€‹
j
\varepsilon_{Q\,ij}
. For example, when
G
â€²
G^{\prime}
is a stochastic matrix, we expect to have
Ïƒ
Q
=
O
â€‹
(
1
/
d
)
\sigma_{Q}=O(1/\sqrt{d})
(cf. Eq.Â (
11
) for the corresponding infinity-norm bound,
|
Îµ
Q
â€‹
i
â€‹
j
|
=
O
â€‹
(
log
â¡
n
/
d
)
|\varepsilon_{Q\,ij}|=O(\sqrt{\log n\ /\ d})
). With
âˆ‘
i
,
j
|
G
â€²
i
,
j
ğ”¢
|
=
n
\sum_{i,j}|{G^{\prime}}^{\mathfrak{e}}_{i,j}|=n
for a stochastic matrix,
we expect the right heavy tail of the element distribution of
G
G
to have
Î©
â€‹
(
n
â€‹
d
)
\Omega(n\sqrt{d})
elements (out of the
n
2
n^{2}
matrix elements of
G
G
) which are clearly separated from the Gaussian noise.
We confirm empirically that the right tail of
G
G
, defined as above with respect to threshold
Ïƒ
Q
\sigma_{Q}
, turns out to contain a non-negligible portion of the parameter capacity of matrices
D
D
,
E
E
, even for very small models (10M to 100M parameters).
Experimental setup.
We prepared parameter matrices of a 24M-parameter BDH-GPU model configured with
h
=
4
h=4
heads and
L
=
8
L=8
layers,
n
=
h
â‹…
2
13
=
2
15
n=h\cdot 2^{13}=2^{15}
neurons, and hidden low-rank dimension
d
=
256
d=256
. We considered the weighted neuron-neuron interaction graph, having the encoder-decoder matrix pair
G
=
D
x
â€‹
E
G={D_{x}}E
as its node adjacency matrix on the set of neurons
V
=
1
,
â€¦
,
n
V=1,\ldots,n
. For uniformity, we subsampled
G
G
by picking node subsets
V
(
a
)
V^{(a)}
,
a
âˆˆ
{
1
,
2
,
3
,
4
}
a\in\{1,2,3,4\}
, associated with each head, and considered the weighted subgraphs
G
(
a
â€‹
b
)
=
{
V
,
{
(
u
,
v
,
G
u
â€‹
v
)
:
u
âˆˆ
V
(
a
)
,
v
âˆˆ
V
(
b
)
}
}
G^{(ab)}=\{V,\{(u,v,G_{uv}):u\in V^{(a)},v\in V^{(b)}\}\}
, with
G
(
a
â€‹
b
)
âˆˆ
R
n
âˆ—
Ã—
n
âˆ—
G^{(ab)}\in R^{n^{*}\times n^{*}}
where
n
âˆ—
=
n
/
h
=
2
13
n^{*}=n/h=2^{13}
, each having
(
n
âˆ—
)
2
=
2
26
(n^{*})^{2}=2^{26}
weighted edges.
We repeated the experiment
5
5
times using models pretrained with different random seeds.
Findings.
For all of the
5
5
models we pretrained for this purpose, exactly
3
3
out of the
4
4
encoder heads and all decoder heads adhered to the prior on parameter distribution given byÂ Eq.Â (
13
), showing a good correspondence for
12
12
out of
16
16
of their parameter sub-matrices
G
(
a
â€‹
b
)
G^{(ab)}
.
We continue the discussion in this Section for one specific matrix
G
(
a
â€‹
b
)
G^{(ab)}
of one specific pretrained models, which was chosen as representative. The example we choose has
a
=
b
a=b
; and so the matrix
G
(
a
â€‹
b
)
G^{(ab)}
has an interpretation as
G
â€‹
[
V
a
]
G[V_{a}]
, i.e., the subgraph of
G
G
induced by vertex set
V
a
V_{a}
, which enables us to visualize the graph
G
(
a
â€‹
a
)
G^{(aa)}
more easily on its vertex set
V
a
V_{a}
.
We refer to the representative object of our study, i.e., to the matrix
G
(
a
â€‹
a
)
G^{(aa)}
of the selected model, as
G
âˆ—
G^{*}
. For any matrix
A
A
and
Î²
â‰¥
0
\beta\geq 0
, we denote by
A
â‰¥
Î²
A_{\geq\beta}
the matrix
A
A
cut off at threshold
Î²
\beta
, i.e.,
A
â‰¥
Î²
i
â€‹
j
=
A
i
â€‹
j
{A_{\geq\beta}}_{ij}=A_{ij}
if
A
i
â€‹
j
â‰¥
Î²
A_{ij}\geq\beta
, and
A
â‰¥
Î²
i
â€‹
j
=
0
{A_{\geq\beta}}_{ij}=0
otherwise.
The distribution of elements
G
i
,
j
âˆ—
G^{*}_{i,j}
is presented in Fig.
9
(a).
Figure 9:
(a) Heavy-tailed element distribution and modularity analysis of the excitatory neuron-neuron connection graph contained the encoder-decoder matrix
G
âˆ—
G^{*}
. Distribution of elements of the encoder-decoder matrix
G
âˆ—
âˆˆ
R
n
âˆ—
Ã—
n
âˆ—
G^{*}\in R^{n^{*}\times n^{*}}
of a BDH-GPU model with
n
âˆ—
=
8192
n^{*}=8192
neurons and
d
=
256
d=256
: histogram
freq
G
âˆ—
â€‹
(
x
)
\mathrm{freq_{G^{*}}}(x)
, its symmetric part
freq
âˆ’
symmetric
G
âˆ—
â€‹
(
x
)
:=
min
â¡
{
freq
G
âˆ—
â€‹
(
x
)
,
freq
G
âˆ—
â€‹
(
âˆ’
x
)
}
\mathrm{freq-symmetric_{G^{*}}}(x):=\min\{\mathrm{freq_{G^{*}}}(x),\mathrm{freq_{G^{*}}}(-x)\}
, and distribution skew
freq
âˆ’
skew
G
âˆ—
â€‹
(
x
)
:=
freq
G
âˆ—
â€‹
(
x
)
âˆ’
freq
âˆ’
symmetric
G
âˆ—
â€‹
(
x
)
\mathrm{freq-skew_{G^{*}}}(x):=\mathrm{freq_{G^{*}}}(x)-\mathrm{freq-symmetric_{G^{*}}}(x)
.
â‹„
\diamond
(b) Estimate (lower bound) of Newman modularity of matrix
G
â‰¥
Î²
âˆ—
G^{*}_{\geq\beta}
for different values of
Î²
\beta
, plotted as a function of the number of non-zero elements (edges) of
G
â‰¥
Î²
âˆ—
G^{*}_{\geq\beta}
. Modularity of random graph baselines are provided for reference, for the
G
â€‹
(
n
âˆ—
,
m
)
G(n^{*},m)
model with the same number of edges as
G
â‰¥
Î²
âˆ—
G^{*}_{\geq\beta}
, and for a matrix
(
P
1
â€‹
P
2
T
)
â‰¥
Î²
â€²
(P_{1}P_{2}^{T})_{\geq\beta^{\prime}}
with the same number of edges as
G
â‰¥
Î²
âˆ—
G^{*}_{\geq\beta}
, where
P
1
,
P
2
âˆ¼
ğ’©
â€‹
(
0
,
1
)
n
âˆ—
Ã—
d
P_{1},P_{2}\sim\mathcal{N}(0,1)^{n^{*}\times d}
. The modularity estimates were obtained using the community structures returned by the Louvain algorithm, in the best of 5 clustering runs with different random seeds.
We find that the observed distribution corresponds well to the prior expected of it byÂ Eq.Â (
13
). We determine the threshold value
Î²
â‰¥
0
\beta\geq 0
at which we expect to capture signal,
G
â‰¥
Î²
âˆ—
â‰ˆ
G
â‰¥
Î²
â€²
{G^{*}_{\geq\beta}}\approx{G^{\prime}_{\geq\beta}}
, following Hypothesis
1
. We find (from Fig.
9
(a)) that the separation from noise happens for this specific matrix
G
âˆ—
G^{*}
at
Î²
1
â‰ˆ
1.2
\beta_{1}\approx 1.2
, at which point the right heavy tail begins to dominate. However, already for much smaller values of
Î²
\beta
we find that
G
â‰¥
Î²
âˆ—
{G^{*}_{\geq\beta}}
has high modularity, and this actually increases as more non-zero values are added to
G
â‰¥
Î²
âˆ—
{G^{*}_{\geq\beta}}
for smaller
Î²
\beta
, up to a maximum at
Î²
2
â‰ˆ
1.0
\beta_{2}\approx 1.0
(Fig.
9
(b)). Even for much smaller values of
Î²
\beta
, the modularity of
G
â‰¥
Î²
âˆ—
{G^{*}_{\geq\beta}}
remains almost constant up to well above
2
20
2^{20}
non-zero matrix entries on the
n
âˆ—
=
2
13
n^{*}=2^{13}
nodes considered. The modularity of the baselines, of random graphs or random low-rank matrix products, quickly drops to 0 in this regime. This should be compared to the total number of parameters of the matrices
D
x
,
E
{D_{x}},E
corresponding to
G
âˆ—
G^{*}
, i.e.,
2
â‹…
2
13
â‹…
2
8
=
2
22
2\cdot 2^{13}\cdot 2^{8}=2^{22}
parameters. A complementary analysis of the inhibitory signal, for a similarly defined matrix
|
G
â‰¤
âˆ’
Î²
âˆ—
|
|G^{*}_{\leq-\beta}|
, also finds that this structure has high modularity.
In auxiliary experiments, we looked at basic graph parameters of matrix
G
â‰¥
Î²
âˆ—
G^{*}_{\geq\beta}
, treated as a directed graph on its set of nodes. We set
Î²
=
1.2
\beta=1.2
, obtaining
m
=
46820
m=46820
non-zero entries (edges) in
G
â‰¥
Î²
âˆ—
G^{*}_{\geq\beta}
.
We found that
G
âˆ—
G^{*}
has a heavy-tailed, power-law-like degree distribution, with generally more concentrated out-degree than in-degree (Fig.
10
(a)).
(a)
(b)
Figure 10:
(a) Unweighted in-degree and out-degree distribution for the
n
âˆ—
=
8192
n^{*}=8192
neuron nodes and
m
=
46820
m=46820
edges of matrix
G
â‰¥
Î²
âˆ—
G^{*}_{\geq\beta}
with
Î²
=
1.2
\beta=1.2
. The distributions exhibit power law distributions, with different exponents, the out-degree distribution being more concentrated. (b) Visualization of graph
G
â‰¥
Î²
âˆ—
G^{*}_{\geq\beta}
, hinting at its core-periphery structure.
Generally, this finding is consistent with expectations as to the structure of a network with positive modularity. The difference of in- and out-degree distributions, while plausible and prevalent in real-world information dissemination networks, was not considered in Subsection
5.3
.
Finally, a visualization of
G
â‰¥
Î²
âˆ—
G^{*}_{\geq\beta}
(Fig.
10
(b)) exhibits a core-periphery structure. This is again consistent with the expected modular structure.
Empirical Finding 3
.
We confirmed that during training,
a graph structure with positive modularity
appears in BDH-GPU model parameter matrices
D
x
â€‹
E
{D_{x}}E
and
D
y
â€‹
E
{D_{y}}E
. This modular structure plausibly follows from the networkâ€™s inference function, and specifically from the cluster-aware information propagation dynamics supported by the ReLU-lowrank mechanism (Observation
6
).
We also observed that for all of the studied models with
h
=
4
h=4
heads,
1
1
encoder sub-matrix out of
4
4
has no heavy positive tail, and generally appears to capture a form of inhibitory structure
G
â€²
ğ”¦
{G^{\prime}}^{\mathfrak{i}}
from Eq.Â (
13
). Since we have not provided convincing mechanisms for isolating negative signals in
G
âˆ—
G^{*}
and these are easily confounded with the bias term
Îµ
B
\varepsilon_{B}
, we omit this case from discussion. We remark that the apparent need for passing activations through such a separate â€œinhibitory circuitâ€ is one of the most evident explanations for why introducing (a small number of) heads to BDH-GPU provides an improvement in model quality.
6
Analysis: linear attention, sparse positive activation, and monosemanticity
6.1
Macro-expressiveness of attention in BDH-GPU
The attention mechanism of BDH-GPU can be described at a coarse-grained level as a transformation mechanism for key-query-value vectors, similar to that in the Transformer. This description is complementary to the interpretation of the BDH-GPU attention mechanism at the micro-level of correlations between neuron pairs, which we defer to Section
6.2
, which provides more insight into the way activation vectors used by BDH-GPU relate to the concept space of the model.
We compare the attention mechanism of BDH-GPU with the attention mechanism of the Transformer, describing both as reflections of a general attention mechanism. Specifically, we explain why, and up to what context length, the linear attention mechanism of BDH-GPU plausibly fits into macro-expressiveness frameworks of attention designed for the Transformer (based on RASP).
Basic properties of BDH-GPU attention.
The key-query space for BDH-GPU is
R
n
R^{n}
, the same as its neuron dimension, rather than the small dense dimension used by the Transformer. The keys and queries used by BDH-GPU are given by positive vectors, in
(
R
+
)
n
(R^{+})^{n}
, and are expressed by the same vector
x
t
,
l
x_{t,l}
(noting that at time
t
t
,
x
t
,
l
x_{t,l}
is used as a query, and only
x
Ï„
,
l
x_{\tau,l}
, for
Ï„
â‰¤
t
âˆ’
1
\tau\leq t-1
, are used as keys).
â€˜Valueâ€™ vectors of BDH-GPU remain in the small dimension,
R
d
R^{d}
, which at some model scales is comparable to the dimension used for attention â€˜valuesâ€™ in common configurations of the Transformer.
The relationship between softmax-based attention of the Transformer, regarded as a low-dimensional kernel for general linear attention, and linear attention for vectors in the positive orthant, was considered in a framework called FAVOR+
(Choromanski etÂ al.,
2021
)
. Here, we provide a few complementary (simpler) observations, sufficient to grasp the main effects of the ability of Linear Attention to distinguish facts in context.
State capacity vs. distinction capacity.
The matrix
ğ†
âˆˆ
R
n
Ã—
d
{\boldsymbol{\rho}}\in R^{n\times d}
, which is used to represent state for each layer of BDH-GPU, should theoretically have sufficient capacity to store
O
â€‹
(
n
)
O(n)
â€˜valueâ€™ vectors in
R
d
R^{d}
if considered as a lookup table for values. We now remark that its actual capability of
distinguishing facts
using the linear attention mechanism is also asymptotically close to
n
n
.
Attention is a mechanism of associative memory which, given a series of key-value pairs
(
(
k
1
,
v
1
)
â€‹
â€¦
,
(
k
t
,
v
t
)
)
âˆˆ
(
Î›
k
Ã—
R
d
)
t
((k_{1},v_{1})\ldots,(k_{t},v_{t}))\in(\Lambda_{k}\times R^{d})^{t}
, a query
q
âˆˆ
Î›
q
q\in\Lambda_{q}
and an affinity function
Ï•
â€‹
(
â‹…
,
â‹…
)
:
Î›
q
Ã—
Î›
k
â†’
[
0
,
1
]
\phi(\cdot,\cdot):\Lambda_{q}\times\Lambda_{k}\to[0,1]
between the space of queries and keys, returns the attention value:
a
t
=
âˆ‘
Ï„
=
1
t
âˆ’
1
Ï•
â€‹
(
q
,
k
Ï„
)
â€‹
v
Ï„
a_{t}=\sum_{\tau=1}^{t-1}\phi(q,k_{\tau})v_{\tau}
(or a normalization thereof). With BDH-GPU, we consider â€˜valueâ€™ vectors
v
âˆˆ
R
d
v\in R^{d}
, where
d
d
is small. The spaces of keys and queries may be assumed to coincide as
Î›
=
Î›
k
=
Î›
q
\Lambda=\Lambda_{k}=\Lambda_{q}
, and we consider in general a single key-query sequence, given by
(
k
t
)
t
âˆˆ
â„•
(k_{t})_{t\in\mathbb{N}}
:
16
16
16
This assumption is known to have moderate practical implications for trainability. In this specific discussion, it is â€˜without loss of generalityâ€™, since one can consider
Î›
=
Î›
1
âŠ—
Î›
2
âŠ—
â€¦
âŠ—
Î›
t
\Lambda=\Lambda_{1}\otimes\Lambda_{2}\otimes\ldots\otimes\Lambda_{t}
, and consider each
k
i
k_{i}
as chosen from
Î›
i
\Lambda_{i}
, defining affinity
Ï•
â€‹
(
k
t
,
k
Ï„
)
:
Î›
t
Ã—
Î›
Ï„
â†’
[
0
,
1
]
\phi(k_{t},k_{\tau}):\Lambda_{t}\times\Lambda_{\tau}\to[0,1]
appropriately to handle successive keys and queries (effectively describing a general form of positional embedding).
a
t
=
âˆ‘
Ï„
=
1
t
âˆ’
1
Ï•
â€‹
(
k
t
,
k
Ï„
)
â€‹
v
Ï„
a_{t}=\sum_{\tau=1}^{t-1}\phi(k_{t},k_{\tau})v_{\tau}
(14)
This key-query space
Î›
\Lambda
may be considered as an abstract space, and represented in any way which is convenient, for as long as the affinity function
Ï•
â€‹
(
k
t
,
k
Ï„
)
\phi(k_{t},k_{\tau})
is preserved. For example, when the keys and queries are sampled from a finite (though possibly extremely large) set, there also exists some vector space dimension
Î½
\nu
(possibly extremely large) and a function mapping
f
:
Î›
â†’
S
Î½
f:\Lambda\to S^{\nu}
, where
S
Î½
=
{
z
âˆˆ
R
Î½
:
â€–
z
â€–
=
1
}
S^{\nu}=\{z\in R^{\nu}:\|z\|=1\}
is the unit sphere, such that the scalar (dot, cosine) product in
S
Î½
S^{\nu}
satisfies
f
â€‹
(
k
t
)
â‹…
f
â€‹
(
k
Ï„
)
=
Ï•
â€‹
(
k
t
,
k
Ï„
)
f(k_{t})\cdot f(k_{\tau})=\phi(k_{t},k_{\tau})
. In other words, any affinity function
Ï•
\phi
becomes linear when represented in sufficiently high dimension, subject to suitable preparation of its arguments with function
f
f
. With
Î½
\nu
extremely large,
S
Î½
S^{\nu}
is a sort of Platonic ideal of a space in which the attention keys and queries live, with no relation to any specific model.
This type of argument, often used in considerations of Support Vector Machines, is linked to two challenges: (1) ensuring that the dimension actually considered by the network (in our case
n
n
) is high enough compared to the hypothetical dimension
(
Î½
)
(\nu)
, and (2) ensuring that a suitable preparation function
f
f
exists and is easy to learn for the model.
17
17
17
The Transformer can also be positioned in the same SVM framework: the Transformerâ€™s attention represents a form of â€œkernel trickâ€ for one specific affinity function
Ï•
\phi
, with the kernel used to approximate it being the exponential function (in the case of softmax attention).
We now explain when the dimension
n
n
can be considered sufficient, and what types of keys can be prepared by BDH-GPU.
Expressiveness of linear attention in dimension
n
n
.
The Linear Attention mechanism aggregates key-value correlations over time. In general, the associated rate of accumulation of noise is manageable, up to the approximate scale of between
t
=
Î©
~
â€‹
(
n
)
t=\tilde{\Omega}(\sqrt{n})
and
t
=
O
~
â€‹
(
n
)
t=\tilde{O}(n)
key-value â€˜factsâ€™ stored in the attention of a given layer. We make the following statement about the Linear Attention mechanism in general.
Claim 7
(informal statement)
.
The mechanism of Linear Attention, applied in dimension
R
n
R^{n}
, can approximately express an attention affinity function for up to
t
=
O
~
â€‹
(
n
)
t=\tilde{O}(n)
â€˜key-valueâ€™ pairs in context, with â€˜valuesâ€™ having comparable L2-norm, under moderate assumptions on weak correlation of historical keys and uniformity of the expressed affinity function. Without such assumptions, Linear Attention can compute the correct affinity up to at least
t
=
Î©
~
â€‹
(
n
)
t=\tilde{\Omega}(\sqrt{n})
â€˜key-valueâ€™ pairs in context, except for a negligible fraction of possible inputs. Keys and queries need to be suitably prepared beforehand.
The formal statement and proof is provided in Appendix
C.2
.
âˆ
The above claim captures the expressiveness of Linear Attention in dimension
R
n
R^{n}
, subject to some way of preparing keys and queries in
R
n
R^{n}
by the model in blocks preceding the attention block. A model using Linear Attention has to learn its own way to prepare keys. In fact, different
natural
approaches to key preparation, for example using random projections or hashing on a set of
t
t
vectors, lead to the same asymptotic statement of Claim
7
. (In the proof in the Appendix, we chose to use a particularly simple one.)
The specific way of preparing keys used (learned) by BDH-GPU for its Linear Attention is particularly interesting. Except for the effect of RoPE rotation, which introduces a negative positional effect in the affinity of keys and queries, BDH-GPU uses activation vectors (keys, queries) with only positive coordinates to represent its keys.
We discuss some aspects of how the positive activation vectors of BDH-GPU relate to Linear Attention.
Preparation of positive keys for Linear Attention.
Activation vectors of BDH-GPU belong to the positive orthant, and are often sparse. The interpretation of such vectors depends on whether we consider the positive orthant to be a â€œvalid shapeâ€ for the latent concept space of the considered task (in this case, language and reasoning), or whether the task has to be embedded into such a space. For language, this would be a question of whether a
word2vec
-like internal representation of the concept space by the model has an inherent advantage over a
bag-of-words
-like representation, especially when expressing concept affinities in attention.
We note that latent representation of key and query vectors in the positive orthant is natural for any problem which is
amenable to attention
. In the discussion of general attention given by Eq.Â (
14
), we noted that the affinity function
Ï•
\phi
takes values in
[
0
,
1
]
[0,1]
, and we considered an embedding
f
f
of a set of key vectors
k
1
,
â€¦
,
k
t
k_{1},\ldots,k_{t}
into
R
Î½
R^{\nu}
such that
f
â€‹
(
k
t
)
â‹…
f
â€‹
(
k
Ï„
)
=
Ï•
â€‹
(
k
t
,
k
Ï„
)
â‰¥
0
f(k_{t})\cdot f(k_{\tau})=\phi(k_{t},k_{\tau})\geq 0
. Given this condition on non-negativity of dot product on all pairs among the
t
t
vectors considered, we could have, without loss of generality, used an appropriately rotated embedding
f
f
so that
f
â€‹
(
k
Ï„
)
âˆˆ
(
R
+
)
Î½
f(k_{\tau})\in(R^{+})^{\nu}
, thus
directly reducing the problem of general attention to a problem of linear attention in the non-negative orthant
. The question which remains is a subtle one: whether this type of embedding of the latent space of language and reasoning in
(
R
+
)
Î½
(R^{+})^{\nu}
is â€˜naturalâ€™, i.e., preserved over long periods of time of inference and training, notably longer than the short window
t
t
of context used for Transformer-like attention.
In the rest of the paper, we are generally inclined to assume that representations in
(
R
+
)
Î½
(R^{+})^{\nu}
of concepts, combinations of concepts, and density distributions over such combinations of concepts, are universal to language and reasoning.
We limit ourselves to a very brief discussion of a way to represent attention keys with positive vectors for problems for which such a concept representation is not natural.
Using LSH to move key vectors into the positive orthant.
Locality Sensitive Hashing (LSH) is one technique for converting arbitrary vectors in a lower-dimensional space
R
a
R^{a}
, for some fixed
a
âˆˆ
â„•
a\in\mathbb{N}
, into vectors in
(
R
+
)
n
(R^{+})^{n}
, in a way which can be used to describe certain â€˜sharp-boundaryâ€™ affinity functions
Ï•
\phi
in
R
a
R^{a}
. Consider an
n
Ã—
a
n\times a
matrix represented as
n
n
fixed random vectors
Î»
1
,
â€¦
,
Î»
n
âˆˆ
R
a
\lambda_{1},\ldots,\lambda_{n}\in R^{a}
, and a corresponding sequence of
n
n
appropriately chosen gating functions
Î³
1
,
â€¦
,
Î³
n
:
R
â†’
R
+
\gamma_{1},\ldots,\gamma_{n}:R\to R^{+}
. For a vector
v
âˆˆ
R
a
v\in R^{a}
, we define:
b
â€‹
(
v
)
:=
Î³
â€‹
(
[
Î»
1
â€‹
â€¦
â€‹
Î»
n
]
â€‹
v
)
=
(
Î³
i
â€‹
(
v
T
â€‹
Î»
i
)
)
1
â‰¤
i
â‰¤
n
.
b(v):=\gamma([\lambda_{1}\ldots\lambda_{n}]v)=(\gamma_{i}({v}^{T}{\lambda_{i}}))_{1\leq i\leq n}.
(15)
Each
i
i
-th element of vector
b
b
thus corresponds to the outcome of the
i
i
-th bucket of LSH.
The bucketing function
b
b
may now be used to prepare queries and keys as attention inputs. If
Î³
i
\gamma_{i}
is a
{
0
,
1
}
\{0,1\}
-valued threshold function, then, for
q
,
k
i
âˆˆ
R
a
q,k_{i}\in R^{a}
,
b
â€‹
(
q
)
T
â€‹
b
â€‹
(
k
i
)
{b(q)}^{T}{b(k_{i})}
is an attention affinity function between
q
q
and
k
i
k_{i}
, equal to the number of LSH buckets shared between
q
q
and
k
i
k_{i}
.
Observation 7
.
The LSH vector affinity function
b
b
, given by EquationÂ (
15
), using
n
n
buckets on vectors in
R
a
R^{a}
for some
a
âˆˆ
â„•
a\in\mathbb{N}
, can be expressed through Linear Attention with attention keys in the positive orthant
(
R
+
)
n
(R^{+})^{n}
.âˆ
In the ReLU-based setup considered in BDH-GPU, an appropriate function
b
b
is plausibly easy to learn. LSH is a â€˜sharp-boundaryâ€™ technique, well-suited for finding
k
k
-nearest-neighbors of a queried vector in a set of keys. Hence, the class of attention affinity functions, naturally expressible using BDH-GPU, also includes such â€˜sharpâ€™ functions.
Attention in the positive concept space of language and reasoning.
BDH-GPU uses the positive orthant
(
R
+
)
n
(R^{+})^{n}
as its latent space for representing combinations of concepts in its activation vectors. Attention keys and queries are prepared entirely in this positive orthant.
When representing a task of reasoning or language inference in a high-dimensional space, positive activation vectors in
(
R
+
)
n
(R^{+})^{n}
have a natural interpretation of convex combinations of concepts. Such convex combinations of concepts may represent both semantically connected concepts (â€œbags-of-conceptsâ€), and mixed states of uncertainty between unconnected concepts. In this interpretation, a positive vector is considered as a state of certain knowledge when its L1-norm and L2-norm align closely. Note that for a (normalized) probability vector, the only vectors for which L1-norm and L2-norm coincide precisely are distributions concentrated on a single coordinate.
Linear Attention of BDH-GPU is capable of amplifying very small differences between keys in the L1-norm when matching queries to keys. Consider, for instance, two probability distribution vectors
x
1
,
x
2
âˆˆ
(
R
+
)
n
x_{1},x_{2}\in(R^{+})^{n}
, where
x
1
=
(
Î±
,
1
âˆ’
Î±
n
âˆ’
1
,
1
âˆ’
Î±
n
âˆ’
1
,
â€¦
,
1
âˆ’
Î±
n
âˆ’
1
)
x_{1}=(\alpha,\frac{1-\alpha}{n-1},\frac{1-\alpha}{n-1},\ldots,\frac{1-\alpha}{n-1})
and
x
2
=
(
1
âˆ’
Î±
n
âˆ’
1
,
Î±
,
1
âˆ’
Î±
n
âˆ’
1
,
â€¦
,
1
âˆ’
Î±
n
âˆ’
1
)
x_{2}=(\frac{1-\alpha}{n-1},\alpha,\frac{1-\alpha}{n-1},\ldots,\frac{1-\alpha}{n-1})
, for some
0
<
Î±
<
1
0<\alpha<1
. Now, vectors
x
1
x_{1}
and
x
2
x_{2}
almost coincide when treated as probability distributions,
â€–
x
1
âˆ’
x
2
â€–
1
=
O
â€‹
(
Î±
)
=
â€–
x
1
âˆ’
x
2
â€–
TVD
\|x_{1}-x_{2}\|_{1}=O(\alpha)=\|x_{1}-x_{2}\|_{\mathrm{TVD}}
. However, they are extremely different when considered as keys for the Linear Attention mechanism, with
x
1
x_{1}
showing very weak affinity to
x
2
x_{2}
:
x
1
T
â€‹
x
2
=
O
â€‹
(
Î±
âˆ’
2
â€‹
n
âˆ’
1
)
â€‹
x
1
T
â€‹
x
1
{x_{1}}^{T}{x_{2}}=O(\alpha^{-2}n^{-1}){x_{1}}^{T}{x_{1}}
.
Observation 8
.
In key-query matching, the Linear Attention mechanism of BDH-GPU is able to separate positive keys which are close in the L1-norm, strongly amplifying L1-norm differences of activation vectors.âˆ
This mechanism can be treated as complementary to the propagation dynamics of positive activations in the feed-forward network, discussed in Section
5.3
.
Natural support for long context.
There is no bound on context length in BDH-GPU, so the actual
t
=
Î©
~
â€‹
(
n
)
t=\tilde{\Omega}(\sqrt{n})
to
t
=
O
~
â€‹
(
n
)
t=\tilde{O}(n)
â€œequally important factsâ€ that a BDH-GPU model can distinguish in each layer in view of Claim
7
do not have to correspond to the latest
t
t
â€œfactsâ€ seen in context. For example, if, for some layer
l
l
, mechanisms from lower layers deem a given entry to be irrelevant for layer
l
l
, and provide an extremely weak attention â€˜valueâ€™ for this layer, and this key-value entry is effectively seen as omitted. This mechanism corresponds to weaker signals
y
y
in a layer which needs to take no action on a given input, e.g., does not have to remember it (cf.Â Fig.
14
). Indeed, empirically we observe progressive de-noising of state in the higher layers, with only small fractions of input tokens requiring significant key-value state update in the middle layers across the entire spectrum of state
ğ†
{\boldsymbol{\rho}}
of neurons.
As a result, the middle and higher layers of BDH-GPU may, in principle, have unbounded look-back on context. Nonetheless, as context length
t
t
increases, we find that damping of historical signals over long sequences is necessary in BDH-GPU to avoid overwhelming the model with noise from stale context. For the vanilla version of the architecture, we found that RoPE combined with ALiBi provide a sufficient remedy, and model performance improves as context length increases. More advanced techniques for BDH-GPU, related to selective forgetting, state compression, or other forms of state optimization, can also be added to the architecture.
6.2
Micro-interpretation of attention in BDH-GPU
BDH maintains its state in the
n
Ã—
n
n\times n
matrix
ğˆ
{\boldsymbol{\sigma}}
that has a clear interpretation as synapse weights that connect neurons (cf.Â Section
2
). On the other hand, BDH-GPUâ€™s state
ğ†
{\boldsymbol{\rho}}
is a
n
Ã—
d
n\times d
matrix. To perform the analysis for BDH-GPU, in this section we recover
ğˆ
{\boldsymbol{\sigma}}
from the relation:
ğˆ
t
âˆ’
1
,
l
=
âˆ‘
Ï„
<
t
y
Ï„
,
l
âˆ’
1
â€‹
x
Ï„
,
l
T
â€‹
U
t
âˆ’
Ï„
{\boldsymbol{\sigma}}_{t-1,l}=\sum_{\tau<t}{y_{\tau,l-1}}{x_{\tau,l}}^{T}U^{t-\tau}
(16)
Figure 11:
BDHâ€™s state
ğˆ
{\boldsymbol{\sigma}}
encodes neuron connections as a scale-free graph showing clear heavy-tailed (power-law-like) degree distribution.
We first analyze the neuron relationship graph encoded by matrix
ğˆ
{\boldsymbol{\sigma}}
. As explained in Section
2.2
,
ğˆ
{\boldsymbol{\sigma}}
can be interpreted as a graph of context dependent implications between
x
x
and
y
y
. We compute the
ğˆ
{\boldsymbol{\sigma}}
matrix for 0-th head at layer 5 of an 8-th layer network trained on Europarl translation corpus
(Koehn,
2005
)
(we provide more details in Appendix
B.3
). We filter out negative entries which are introduced by the RoPE positional embeddings
(Su etÂ al.,
2024
)
and enforce a small positive threshold on remaining values to further sparsify the network structure. We plot the histograms of neuron in- and out-degrees, unraveling a scale-free network structure.
Encouraged by the emergent network structure, we have identified a few synapses that are activated at recognizable concepts, we show examples in the next section.
6.3
Empirical findings: monosemantic synapses
We have identified in the
ğˆ
{\boldsymbol{\sigma}}
matrix entries (synapses) that show activity whenever a currency name or country name, both frequently occurring in the Euro-parliament transcripts, is present in the processed sentence. We have identified the synapses by searching for entries in
ğˆ
{\boldsymbol{\sigma}}
that have predictive power at separating sentences containing a concept from contrast sentences. We present a few examples in Figure
12
. We note that the synapses strength changes abruptly after words that are related to each concept. The same synapse is activated for concepts in both French and English sentences, even when the words used are different (e.g. â€œlivre sterlingâ€ vs â€œBritish Poundâ€). Synapse selectivity to a semantic context stems directly from sparsity of neuron activations as shown inÂ Fig.
13
.
Figure 12:
Evolution of values set by BDH-GPU on 2 specific synapses which we have named (following their interpretation) as â€œcurrency synapseâ€ and â€œcountry synapseâ€, relating to concepts naturally present in European Parliament transcripts on which the model was trained. We can notice that mentions of country or currency names result in an increase of the respective synapse value, indicating a stronger presence of the concept in the context. Moreover, the synapses consistently became activated in both French and English, confirming the (notice how it reacts both to â€œBritish Poundâ€ and â€œlivre sterlingâ€).
For visual clarity, we indicate changes that clear a small threshold with the
âˆ—
*
character (the changes in activity when the system is processing the translation of a source sentence tend to be small).
Figure 13:
Sparse updates to synapses related to meaningful concepts stem from sparse neuronal activations. BDH-GPU maintains in its recurrent state a â€œcurrency synapseâ€ (a concept naturally present in the Europarl corpus, see alsoÂ Fig.
12
). The synapse is updated using a Hebbian learning rule when activity in
y
y
activations at a preceding layer (4 in the example) leads to firing of neuron
x
x
in the next layer (5).
To confirm the selectivity of the synapses, we have generated, using ChatGPT, 50 sentences relating to European currencies, and another set of 50 sentences speaking about European politics, but not mentioning currencies. A one-sided Mannâ€“Whitney U test revealed that sentences relating to currencies received significantly higher â€œCurrency synapseâ€ values than those without the currency concept (
U
=
2368
U=2368
with
U
opt
=
2500
U_{\textrm{opt}}=2500
,
p
<
10
âˆ’
14
p<10^{-14}
). The rank-biserial correlation was
0.86
0.86
, further confirming association between Currency concept presence and synapse value.
6.4
Empirical findings: sparse neuron activations
Sparsity of signals is often a prerequisite to their interpretability. In section
6.3
we have shown that BDH has monosemantic synapses, selectively activated by occurrences of specific concepts. In this section, we experimentally show that neuron activity correlates with signal predictability: fewer neurons are active, or equivalently, layer activations become sparser, for more predictable input signals.
We have trained a BDH-GPU model with
n
=
65536
n=65536
neurons,
d
=
256
d=256
,
L
=
4
L=4
layers, and tokenization on letters of the Latin alphabet, to perform a single synthetic next-token prediction task. The input sequence started with a fixed
13
13
-letter warm-up sequence, followed by
8
8
repetitions of an
8
8
-letter random word (â€œfactâ€), with the same pattern repeating every
13
+
8
â‹…
8
=
77
13+8\cdot 8=77
letters. InÂ Fig.
14
, we show neuron activity patterns. We can notice that neurons in higher layers are active during warm-up and fact introduction, then become quiet. We then group neurons by their RoPE frequencies and find that largest difference of activity during memorization and repetition is shown by the slow-acting neuron population.
(a)
(b)
Figure 14:
Neurons in BDH-GPU are less active (signal is sparser) when the input is predictable. The input sequence started with a fixed
13
13
-letter warm-up sequence, followed by
8
8
repetitions of an
8
8
-letter random word (â€œfactâ€), with the same pattern repeating every
13
+
8
â‹…
8
=
77
13+8\cdot 8=77
letters. (a) Fraction of neurons with non-zero entry
y
t
,
l
y_{t,l}
in different layers
l
l
, with fact memorization effect noted through increased activation level in layer
2
2
. The activation in layer
2
2
has
4.0
%
âˆ’
7.5
%
4.0\%-7.5\%
non-zero entries during memorization and approximately
2.5
%
2.5\%
non-zero entries during repetition. (b) Detailed breakup of activation sparsity in layer
2
2
, with neurons bucketed into equal fractions by their RoPE phase:
freq
â€‹
0
âˆˆ
[
1
,
4
]
\textrm{freq}0\in[1,4]
,
freq
â€‹
1
âˆˆ
[
4
,
16
]
\textrm{freq}1\in[4,16]
,
freq
â€‹
2
âˆˆ
[
16
,
64
]
\textrm{freq}2\in[16,64]
,
â€¦
\ldots
,
freq
â€‹
7
âˆˆ
[
16384
,
65536
]
\textrm{freq}7\in[16384,65536]
. The slow-acting half of the neuron population (
freq
â€‹
4
âˆ’
freq
â€‹
7
\textrm{freq}4-\textrm{freq}7
) exhibits the largest amplitude ratio between peak activation during memorization and repetition phases.
From a biological standpoint, sparse and surprisal-driven neuron activation lowers energy consumption â€” despite fluctuations in low level percepts (in the experiment tokens are changing at every timestep), neurons in higher layers are inactive and do not expand energy. From a Deep Learning perspective, it has been recently shown that input complexity is related to predictability of internal representations of Transformers
(Herrmann etÂ al.,
2025
)
. BDH makes this very explicit and does not require a separate prediction network: the predictable steady-state consists of zero activations, and input complexity entails neuronal activity. This suggests that BDH, natively, at a neuron level, implements mechanisms reminiscent of adaptive computation time
(Graves,
2017
)
and conditional computation
(Cho and
Bengio,
2014
; Shazeer etÂ al.,
2017
)
, used in modern Transformers to lower computational effort during inference.
Finally, sparse activation vectors in BDH imply that potentiation of specific synapses occurs rarely during inference. This is useful from the point of view of interpretability, noise reduction in Linear Attention state, and opens the door to simplified and compressed representations, notably for state and for gradient backpropagation DAGâ€™s.
7
Playing with the Hatchling
7.1
Model merging: concatenating two models
Updating models with up-to-date knowledge and expanding models knowledge-base will become crucial in practical applications of AI. On possible solution is model composability, potentially allowing building of larger models by assembling a number of smaller, specialized models into a larger, more powerful one. A natural hope for such a system would be the achievement of â€more is different than a sum of its partâ€ effect. In the following experiment we are showing that doing so is relatively straight forward with BDH-GPU. This is because BDH-GPU can be scaled by varying only the number of neurons
n
n
. In this section we explore whether we can create larger models directly concatenating smaller models trained on disjoint subsets of data. Details in Appendix
B.4
. We have experimented with the following simple model merging procedure:
1.
Train a base model on a chosen language pair. In the experiment we have used English-Spanish (En-Es) translation data, and have trained a model with
n
=
24576
n=24576
neurons (19M parameters).
2.
Clone the base model and continue training on two datasets: English-French (En-Fr) and English-Portuguese (En-Pt).
3.
We then merge the weights of the En-Fr and En-Pt models to create a new En-FrPt model with
n
=
24576
â‹…
2
=
49152
n=24576\cdot 2=49152
neurons (38M parameters).
To create the merged model we:
(a)
concatenate all parameter tensors that have an â€˜
n
n
â€™ dimension (e.g.
D
y
{D_{y}}
,
D
x
{D_{x}}
,
E
E
, RoPE frequency buffers) along their
n
n
dimension,
(b)
average all other parameters (e.g. token embeddings and token prediction weights).
To validate the hypothesis that direct model merging is feasible, we report all results on the merged model without any subsequent training or finetuning. However, we have verified that the merged model quickly improves when trained on all language pairs.
4.
After each stage we evaluate the models on all involved language pairs: En-Es, En-Fr, En-Pt, regardless of the data seen by the model up to this stage.
Translation into English
Translation from English
Model:
Es
â†’
\rightarrow
En
Fr
â†’
\rightarrow
En
Pt
â†’
\rightarrow
En
En
â†’
\rightarrow
Es
En
â†’
\rightarrow
Fr
En
â†’
\rightarrow
Pt
1: Base En-Es
0.36
0.77
0.64
0.35
2.21
2.27
2: Base (1) tuned on En-Fr
0.58
0.36
0.68
2.57
0.31
2.54
3: Base (1) tuned on En-Pt
0.44
0.76
0.34
1.79
2.20
0.33
4: Merged (2
âˆ¥
\|
3)
0.43
0.40
0.39
1.45
0.77
0.86
Table 2:
Validation next token prediction losses (lower is better) of translation models trained on different language pairs and then merged. We evaluate each model on En-Es, En-Fr, En-Pt language pairs separately. We can see that the base model can translate between English and Spanish, while on En-Fr and En-Pt tasks it falls back on perplexities of an unconditional English language model (loss about
0.65
0.65
) and canâ€™t generate proper French or Portuguese. After tuning on French or Portuguese the model learns to translate between respectively English and French or English and Portuguese, while somewhat retaining the capacity to translate Spanish to English and losing the capability to translate English to Spanish. The merged model can translate Spanish, French, and Portuguese to English, however it mixes these three languages when asked to translate from English. This is consistent with qualitative results shown in Figure
15
.
We report quantitative results in Table
2
and show qualitative results of merged model operation in Figure
15
. The merged model shows human-like degradation of operation: while it retained the capability to generate and translate into English, it has lost the ability to generate proper text in Spanish, French, or Portuguese, mixing words and grammatical constructs. We have verified that a small amount of training on all language pairs restore the modelâ€™s proficiency in Spanish, French and Portuguese. However, we decided to report on the behavior of the merged model without any subsequent tuning to highlight the possibilities of model engineering offered by the large and sparse working dimension
n
n
of BDH-GPU.
<F:es>Esta es una afirmaciÃ³n clara.<T:en>
|
In this clarification, it is a clear statement.
<F:es>Esta es una afirmaciÃ³n clara.<T:en>
|
It is a clear statement.
<F:es>Esta es una afirmaciÃ³n clara.<T:en>
|
That is a clear affirmation.
<F:fr>Câ€™est une dÃ©claration claire.<T:en>
|
This is a clear statement.
<F:fr>Câ€™est une dÃ©claration claire.<T:en>
|
This is a clear declaration.
<F:fr>Câ€™est une dÃ©claration claire.<T:en>
|
It is a clear declaration.
<F:pt>Esta Ã© uma afirmaÃ§Ã£o clara.<T:en>
|
That is a clear statement.
<F:pt>Esta Ã© uma afirmaÃ§Ã£o clara.<T:en>
|
This is a clear statement.
<F:pt>Esta Ã© uma afirmaÃ§Ã£o clara.<T:en>
|
This is a clear assertion.
(a) Sampled translations from Spanish, French, and Portuguese to English. The vertical bar
|
|
delimits the prompt from model output. Each translation was sampled three times to show the modelâ€™s consistency.
<F:en>This is a clear statement.<T:es>
|
Ce rÃ©cent statement estÃ¡ clarificative.
<F:en>This is a clear statement.<T:es>
|
Il se revela exact.
<F:en>This is a clear statement.<T:es>
|
Constato que cette dÃ©claration Ã©tait monstruosa.
<F:en>This is a clear statement.<T:fr>
|
EstÃ¡ de noto uma dÃ©claration.
<F:en>This is a clear statement.<T:fr>
|
Ce sont une declaration clare.
<F:en>This is a clear statement.<T:fr>
|
Câ€™estÃ¡ uma declaraÃ§Ã£o clare.
<F:en>This is a clear statement.<T:pt>
|
Esta declaraÃ§Ã£o Ã©tangling Ã©tat estÃ¡ clara.
<F:en>This is a clear statement.<T:pt>
|
Istambigna de contence.
<F:en>This is a clear statement.<T:pt>
|
Câ€™estatÃ© clarification Ã© clara!.
(b) Sampled translations from English into Spanish, French, and Portuguese. The model mixes the three languages, though the meaning of the source sentence seems to have been preserved.
<F:en>
|
The European Convention on Human Rights has been set up in 1992, when it applied the Convention in 1
<F:es>
|
Naturalment, nos deputÃ©s de toda autre groupe southern Italians, notariously engaged in the discuss
<F:fr>
|
(ES) Mr President, aproveit de montrar ma satisfaction por a surprise de la parte de Milan, et parti
<F:pt>
|
(FI) Mr President, todos outreaches, mesures on ways and means of promoting the economic development
(c) Language-conditional samples. Consistently with the translation experiment in (a) and (b) above, the model properly generates English, and mixes Spanish, French, and Portuguese, sometimes slipping into English.
<F:es>Mi lingua project nominat Romanid esed publicat ja in may de pasat an.<T:en>
|
A Lingue nominated Project is Romanian published in Romanian pasta year.
<F:fr>Mi lingua project nominat Romanid esed publicat ja in may de pasat an.<T:en>
|
My language in Project Nomina is Romani esedi publish posted peas in maybe the same year.
<F:pt>Mi lingua project nominat Romanid esed publicat ja in may de pasat an.<T:en>
|
I have been a Latva project nomination Romanim esede publica published in May of the postal service and the service provider.
d) Attempts of the model to translate a sentence in RomanidÂ (
2025
), a zonal auxiliary language for speakers of Romance languages naturalistic constructed language intended to be intuitively understandable to speakers of Romance languages. The English translation of the prompt is: â€œMy language project called Romanid was published already in May of last yearâ€. The model is able to pick up some of the meaning of the prompt.
Figure 15:
Conditional and unconditional samples generated from a English-Spanish-French-Portuguese translation model created by direct concatenation of parameters of models trained on distinct language pairs.
The BDH-GPU model merging experiment has shown that when the model latent space promotes concept disentangling (c.f. Section
6.2
on monosemanticity) then it is feasible to directly compose concepts in this space, e.g. by concatenation of weights from different models. This feature of the BDH architecture allows us to see the models as composable computer programs with emergent properties.
7.2
Training without backpropagation through time
Sparsity of synapse activations in BDH opens the door to efficient approximations to backpropagation through time. The main intuition is that we only need to remember when a synapse has changed, and the
i
,
j
i,j
coordinates of the synapse implicitly encode which neurons were active and should take part in error signal backpropagation.
In this section we report results of preliminary experiments on the impact of removal of backpropagation through time on model performance. For the PyTorch implementation in Appendix
E
, this corresponds to â€˜detachâ€™-ing variables
K
and
V
in the implementation of the
LinearAttention
class.
In particular, we found that such a model, trained without any backpropagation through time, retained some ability to model language, but lost the ability to match concepts between different languages during translation. For translation tasks like those presented in Table
2
, loss values for English increased from a loss level of approximately
0.65
0.65
for an unconditional English language model (trained with backpropagation over time), to loss of approximately
0.75
âˆ’
1.05
0.75-1.05
for a model trained without backpropagation over time, depending on model variant, regardless of whether English was the source or target language in translation. No significant difficulties were encountered during training when crossing the barrier of the letter-bigram language model, at loss value
2.4
2.4
.
Beyond side-effects of the general design, we did not optimize the BDH-GPU model for suitability of training without backpropagation. We consider this architecture to be a good starting point for bootstrapping further investigations in this direction.
8
Conclusions
8.1
Takeaways for model engineering
This paper leads up to a new class of language and reasoning models which eliminate architecture nonuniformities, notably in terms of scaling for model size, and handling of time scales of inference.
The BDH-GPU architecture introduced in this paper opens the following opportunities:
1.
New ways of scaling models for time and size.
BDH-GPU is a state-space model which scales for size in one large dimension
n
n
(neurons in this dimension are indexed by RoPE oscillator frequency). Subject to appropriate sharding, this also leads to a desirable form of locality: important data is located just next to the sites at which it is being processed. This minimizes communication, and eliminates the most painful of all bottlenecks for reasoning models during inference: memory-to-core bandwidth.
2.
Faster model iteration.
During training and inference alike, BDH-GPU provides insight into parameter and state spaces of the model which allows for easy and direct evaluation of model health and performance, notably, through sparsity-related measures and through aggregates and statistics on the large pool of homogeneous neurons, even for relatively small models. Attention and parametric layers alike operate on the same neuron dimension (â€˜concept dimensionâ€™).
3.
Direct explainability of model state.
Elements of state of BDH-GPU are directly localized at neuron pairs, allowing for a micro-interpretation of the hidden state of the model.
4.
New opportunities for â€˜model surgeryâ€™.
The BDH-GPU architecture is, in principle, amenable to direct composability of model weights in a way resemblant of composability of programs. This concerns the potential both the direct composition of separately trained model parts, as well as â€˜surgeryâ€™ of parameter spaces of models, by inserting fragments of manually programmed protocols into machine-learned code.
8.2
Implications for brain science
We have obtained a micro-foundational description of attention for artificial language and reasoning models, expressed in a framework of local graph dynamics. This has been found to be consistent with the effects observed for the same function of
attention for language and reasoning
in the brain. By introducing a translation layer based on similarity of function between the artificial and biological planes, for blocks of feed-forward neural networks and attention mechanisms, our work points to the following hypothesis:
complex systems effects which are observed in the brain, around modular scale-free network structure, synaptic plasticity, and Hebbian learning arose from its core purpose â€” doing reasoning â€” and
not
from any specific longer-term training dynamics which the brain applies
.
We have exhibited how a general attention mechanism can be efficiently implemented as an artificial neuronal system with spiking neurons and synapse plasticity. More formally, we first describe the class of local interaction dynamics which any system
plausibly needs
to implement attention mechanisms. We then confirmed that the edge-reweighting rule is
sufficient
to allow a certain artificial Language Model (BDH-GPU) to operate at least at the level of the Transformer. For an artificial network, the edge-reweighting rule intuitively describes the interaction between two artificial neurons exhibiting rapid state-change behavior, and one synaptic neuron interconnection element exhibiting plasticity as shown in Fig.
13
.
More broadly, this work may potentially serve to support efforts aiming to isolate, from among the many extremely complex electrochemical patterns and signal dynamics occurring in the brain, those that are crucial for
solving tasks in-context (based on attention)
, from those that potentially serve other purposes, such as transfer of information from short-term memory to long-term memory, or long-term improvement of brain function (learning).
How this work helps with axiomatization of learning theory in the brain.
Attempts to understand the brain, starting from the perspective of longer time scales of training, have proved extremely challenging, defying progress. This paper pin-points attention-based reasoning at shorter time scales as â€˜the other end of the stringâ€™, and hints how, from here, untangling the entire story will plausibly be easier.
For natural systems undergoing continuous learning, the time scales to look at are: language function and reasoning (chain-of-thought inference), then short-to-long memory transfer from state to network weights, adaptation of structure: changes to interconnections, and finally, changes to neuron nodes.
For long time scales, this reduces the question of finding supervised training dynamics form the most general case, to a specific class of local dynamics: an interaction kernel performing â€˜edge-reweightingâ€™ rules. As these rules appear fundamental to logical inference and biochemical processes alike, its universality in processes that the brain is responsible for is plausible also beyond the realm of language-based reasoning.
From a systems perspective, we arrive at the following possible explanation.
The brain generally tries to be lazy in terms of energy expense, and does things as late as it can. Only reasoning needs to happen close to a critical regime, because it involves executing a real-time program which needs to be responsive, since the life and success of the biological organism depends on it. Then, for a certain time, which may be minutes for humans, the brain has enough synapses in it to represent (almost) all useful information it needs for reasoning, decision-making, etc. â€” all stored in short-term state, at synapses (and/or neurons). Some of the neuron activations which the brain performs at this time scale represent â€˜gradients of stateâ€™ â€” the gradients of in-context learning, passed on to modify synapse strength, in a weight-update process. As time goes by, the system runs out of state space. Then, memory processes work to iron things out, preserving in more permanent neuron connection weights and graph structure the elements of state that have been reinforced by feedback signals. Overall, there are fewer and fewer things that need to be remembered across progressively longer time scales. However, this entire memory process is, plausibly, subsidiary to the definition of the dynamics of reasoning and the synaptic dynamics of state that we discuss in this paper. In other words, the best form of description of the relaxation from state into longer-term memory follows from the specific kernel of the reasoning dynamics, such as the edge-reweighting kernel.
As for the ratio of time scales (measured in tokens for language), we can estimate that the time lapse after which harmonizing state with a memory process becomes important is of about the same order of magnitude as the average time between â€˜writesâ€™ (significant transmission increases) for individual synaptic elements (see e.g. Fig.
14
). In our models, this time is lower-bounded by the inverse of sparsity of the vector
y
y
, i.e.,
1
/
Ï
â‰ˆ
1
/
5
%
=
20
1/\rho\approx 1/5\%=20
tokens, but it could be much larger for larger systems; we also do not force it in any way to be sparser during training. During training with backpropagation, if the backpropagation window
T
T
is short enough,
T
<
1
/
Ï
T<1/\rho
tokens, we can plausibly assume that a synapse changes state only once in that window (and is used multiple times), hence the DAG of gradient backwards propagation is much more direct to embed within the system graph. Backpropagation is then a question of â€˜routingâ€™ gradients in the neuron communication graph, and not one of disentangling them. All natural training approaches, whether based on backpropagation, or any more direct form of relaxation â€˜from state into weightsâ€™, appear to bottleneck on the amount of available state space on synapses, becoming necessary at about
T
âˆ¼
1
/
Ï
T\sim 1/\rho
by a simple information-theoretic argument on state storage capacity.
Regardless of how much of this is an accurate description, and how much an intuition, at the very least, it appears we may now have a way forward. Some part of the â€œglobal mysteryâ€ of learning in the brain can be reduced to a more â€œlocalized problemâ€ of state-to-operator transfer for some relatively compact form of state-space dynamics (i.e., one specific local graph kernel). This change of perspective brings in both a completely new â€˜problem landscapeâ€™ in which to navigate towards a complete solution, as well as a set of new methods to use for the different types of graph structure changes involved in learning, including approaches from distributed computing, evolving network theory, and graph rewiring systems.
At this point, it seems one natural next step would be to ground the current discussion more deeply in findings of brain science, to refine or simplify the
actual kernels
used by brain reasoning (which was not the objective of this paper), and potentially seek validation through experiment.
8.3
Societal impact
This paper is a voice in favor of bringing principled understanding to reasoning in Machine Learning. Axiomatic AI provides an opportunity to reduce risks related to unpredictable behavior of AI models, and, to open or accelerate new development directions. The subject matter which we consider here serves as a direct introduction to the most crucial problem that lies ahead: controlling the behavior of autonomous AI reasoning models and AI systems as they progress across time scales, from seconds to years.
Transformer (GPT2)
BDH-GPU (
n
n
,
d
d
)
BDH(
n
n
,
Î”
\Delta
)
Brain models (reasoning and language function)
Inference hardware
GPU, CPU
GPU, CPU
CPU, Sparse GPU kernels, Neuromorphic
Brain and supporting systems
Model weights (predominant location)
5
5
tensors per layer (different shapes)
3
3
tensors per model (same shape
n
Ã—
d
n\times d
)
Neuron-synapse graph: connection topology, edge weights
Neuron-synapse graph: connection topology, edge weights
Representation of attention
KV-cache tensor (not localized at neurons)
n
Ã—
d
n\times d
tensor for each layer (localized at neurons)
Memory on synapse edge weights
State memory through synapse plasticity
Macro-description of attention
Key lookup data-structure, key-value map
Key lookup data-structure, key-value correlation matrix
Key lookup data-structure, key-value correlation matrix
Not known
Micro-description of attention
None
Neuron-pair correlations in context (transformed)
Neuron-pair correlations in context
Strengthened or weakened connections between neurons based on context
Scaling for model size
Multiple combinations of dimensions, e.g. MLP scales with
D
Ã—
D
D\times D
, scales separately with context length
Uniform linear array of
n
n
particles in a mean-field
n
n
-node graph model
n
n
-node graph model with evolving graph mechanisms
Distributed system micro-architecture
Follows from compiled matrix multiplication kernels, non-uniform
Particles run identical local kernels, communicating
O
â€‹
(
d
)
O(d)
-size messages through mean-field, and storing local state
All
n
n
neuron nodes run identical local kernels, communicating over neuron-synapse graphs. Some synapses act as memory elements.
n
n
neurons run local kernels and communicate through a network, using numerous signal patterns and coding schemes. Synapses act as memory element.
Macro-expressiveness of programs (approximation)
RASP-L, C-RASP
RASP-L, C-RASP
RASP-L, C-RASP (or superset)
Unknown
Micro-expressiveness of programs
Unknown
Subset of BDH
Probabilistic rule-based local protocols. Micro-Inductive bias interpreted as reasoning system in a form of propositional logic.
Unknown
Emergence of structure
Partially interpretable concept layer (evidence of monosemantic neurons for important concepts)
Evidence of emergent network, oscillator dynamics
Emergent network, oscillator dynamics
Emergent network; oscillatory effects; possible monosemantic â€œgrandfather neuronsâ€
Activation vectors
Dense activation; can be subsampled or sparsified by architecture modification
Positive vectors, sparse fresh activation vectors
y
y
Positive vectors, sparse fresh activation vectors
y
y
Sparse positive activation vectors
Table 3:
Comparison of properties of language and reasoning model architectures: the GPT2 Transformer, BDH-GPU, BDH, and brain models.
Acknowledgments
The authors thank David Sussillo, Navdeep Jaitly, and Emanuele Natale for insightful discussions on reasoning and the brain, and for early feedback on this write-up.
We also thank Samy Bengio for comments on the presentation.
We kindly acknowledge the support of all of the Pathway team, notably, PaweÅ‚ Podhajski for his amazing help with cluster setup, Victor Szczerba and Z Schwab for all discussions over coffee, and Kamil Piechowiak and Chris Ociepa for constructive comments on the presentation. AK thanks Christos Papadimitriou for being the direct inspiration for us to embark on this journey.
Author contributions
AK conceived the BDH and BDH-GPU architectures, conceived most of the theory, developed most of the model source code, conceived and performed experiments on synapses, and wrote most of the paper.
PU contributed crucial elements of BDH-GPU architecture, contributed model and framework source code, contributed to theoretical analysis, and performed experiments.
JCh led, designed, and oversaw methodology of experiments, led framework development, contributed major improvements to BDH-GPU architecture, contributed to the theory, implemented baselines, performed experiments, and substantially redacted the paper.
ZS conceived the project, guided research directions, introduced particle-interaction interpretation, acted as final judge in research decisions, and substantially redacted the paper.
MB optimized model source code, contributed framework source code, and performed experiments.
References
Abraham etÂ al. (2011)
I.Â Abraham, D.Â Delling, A.Â V. Goldberg, and R.Â F. Werneck.
A hub-based labeling algorithm for shortest paths in road networks.
In P.Â M. Pardalos and S.Â Rebennack, editors,
Experimental
Algorithms
, pages 230â€“241, Berlin, Heidelberg, 2011. Springer Berlin
Heidelberg.
ISBN 978-3-642-20662-7.
Achlioptas and Mcsherry (2007)
D.Â Achlioptas and F.Â Mcsherry.
Fast computation of low-rank matrix approximations.
J. ACM
, 54(2):9â€“es, Apr. 2007.
ISSN 0004-5411.
URL
https://doi.org/10.1145/1219092.1219097
.
Angluin etÂ al. (2006)
D.Â Angluin, J.Â Aspnes, Z.Â Diamadi, M.Â J. Fischer, and R.Â Peralta.
Computation in networks of passively mobile finite-state sensors.
Distributed Comput.
, 18(4):235â€“253, 2006.
URL
https://doi.org/10.1007/s00446-005-0138-3
.
Aspnes and Ruppert (2009)
J.Â Aspnes and E.Â Ruppert.
An Introduction to Population Protocols
, pages 97â€“120.
Springer Berlin Heidelberg, Berlin, Heidelberg, 2009.
ISBN 978-3-540-89707-1.
URL
https://doi.org/10.1007/978-3-540-89707-1_5
.
Ba etÂ al. (2016a)
J.Â Ba, G.Â E. Hinton, V.Â Mnih, J.Â Z. Leibo, and C.Â Ionescu.
Using fast weights to attend to the recent past.
Advances in neural information processing systems
, 29,
2016a.
Ba etÂ al. (2016b)
J.Â L. Ba, J.Â R. Kiros, and G.Â E. Hinton.
Layer normalization, 2016b.
URL
https://arxiv.org/abs/1607.06450
.
Bahdanau etÂ al. (2015)
D.Â Bahdanau, K.Â Cho, and Y.Â Bengio.
Neural machine translation by jointly learning to align and
translate.
In Y.Â Bengio and Y.Â LeCun, editors,
3rd International
Conference on Learning Representations, ICLR 2015, San Diego, CA, USA, May
7-9, 2015, Conference Track Proceedings
, 2015.
URL
http://arxiv.org/abs/1409.0473
.
Barlow (1972)
H.Â B. Barlow.
Single units and sensation: A neuron doctrine for perceptual
psychology?
Perception
, 1(4):371â€“394, 1972.
URL
https://doi.org/10.1068/p010371
.
PMID: 4377168.
Becchetti etÂ al. (2018)
L.Â Becchetti, V.Â Bonifaci, and E.Â Natale.
Pooling or sampling: Collective dynamics for electrical flow
estimation.
In
Proceedings of the 17th International Conference on
Autonomous Agents and MultiAgent Systems
, AAMAS â€™18, page 1576â€“1584,
Richland, SC, 2018.
Beck etÂ al. (2024)
M.Â Beck, K.Â PÃ¶ppel, M.Â Spanring, A.Â Auer, O.Â Prudnikova, M.Â Kopp,
G.Â Klambauer, J.Â Brandstetter, and S.Â Hochreiter.
xlstm: Extended long short-term memory.
Advances in Neural Information Processing Systems
,
37:107547â€“107603, 2024.
Ben-Kish etÂ al. (2025)
A.Â Ben-Kish, I.Â Zimerman, M.Â J. Mirza, J.Â Glass, L.Â Karlinsky, and R.Â Giryes.
Overflow prevention enhances long-context recurrent llms, 2025.
URL
https://arxiv.org/abs/2505.07793
.
BjÃ¶rner etÂ al. (1991)
A.Â BjÃ¶rner, L.Â LovÃ¡sz, and P.Â W. Shor.
Chip-firing games on graphs.
European Journal of Combinatorics
, 12(4):283â€“291, 1991.
ISSN 0195-6698.
URL
https://doi.org/10.1016/S0195-6698(13)80111-4
.
Blondel etÂ al. (2008)
V.Â D. Blondel, J.-L. Guillaume, R.Â Lambiotte, and E.Â Lefebvre.
Fast unfolding of communities in large networks.
Journal of Statistical Mechanics: Theory and Experiment
,
2008(10):P10008, oct 2008.
URL
https://dx.doi.org/10.1088/1742-5468/2008/10/P10008
.
Boczkowski etÂ al. (2019)
L.Â Boczkowski, A.Â Korman, and E.Â Natale.
Minimizing message size in stochastic communication patterns: fast
self-stabilizing protocols with 3 bits.
Distributed Comput.
, 32(3):173â€“191, 2019.
URL
https://doi.org/10.1007/s00446-018-0330-x
.
Bostrom (2014)
N.Â Bostrom.
Superintelligence: Paths, Dangers, Strategies
.
Oxford University Press, Inc., USA, 1st edition, 2014.
ISBN 0199678111.
Brunel (1996)
N.Â Brunel.
Hebbian learning of context in recurrent neural networks.
Neural Computation
, 8(8):1677â€“1710, 1996.
URL
https://ieeexplore.ieee.org/document/6796169
.
Buckman etÂ al. (2024)
J.Â Buckman, C.Â Gelada, and S.Â Zhang.
Symmetric Power Transformers, 2024.
URL
https://manifestai.com/articles/symmetric-power-transformers/
.
Budzinskiy (2025)
S.Â Budzinskiy.
When big data actually are low-rank, or entrywise approximation of
certain function-generated matrices, 2025.
URL
https://arxiv.org/abs/2407.03250
.
Cairns (2018)
H.Â Cairns.
Some halting problems for abelian sandpiles are undecidable in
dimension three.
SIAM Journal on Discrete Mathematics
, 32(4):2636â€“2666, 2018.
URL
https://doi.org/10.1137/16M1091964
.
Chen etÂ al. (2014)
Y.Â Chen, D.Â Doty, and Soloveichik.
Deterministic function computation with chemical reaction networks.
Nat Comput
, 13:517â€“534, 2014.
URL
https://link.springer.com/article/10.1007/s11047-013-9393-6
.
Cho and
Bengio (2014)
K.Â Cho and Y.Â Bengio.
Exponentially increasing the capacity-to-computation ratio for
conditional computation in deep learning, 2014.
URL
https://arxiv.org/abs/1406.7362
.
Choromanski etÂ al. (2021)
K.Â M. Choromanski, V.Â Likhosherstov, D.Â Dohan, X.Â Song, A.Â Gane, T.Â Sarlos,
P.Â Hawkins, J.Â Q. Davis, A.Â Mohiuddin, L.Â Kaiser, D.Â B. Belanger, L.Â J.
Colwell, and A.Â Weller.
Rethinking attention with performers.
In
International Conference on Learning Representations
, 2021.
URL
https://openreview.net/forum?id=Ua6zuk0WRH
.
Christiano etÂ al. (2011)
P.Â Christiano, J.Â A. Kelner, A.Â Madry, D.Â A. Spielman, and S.-H. Teng.
Electrical flows, laplacian systems, and faster approximation of
maximum flow in undirected graphs.
In
Proceedings of the Forty-Third Annual ACM Symposium on
Theory of Computing
, STOC â€™11, page 273â€“282, New York, NY, USA, 2011.
Association for Computing Machinery.
ISBN 9781450306911.
URL
https://doi.org/10.1145/1993636.1993674
.
Czyzowicz etÂ al. (2022)
J.Â Czyzowicz, L.Â Gasieniec, A.Â Kosowski, E.Â Kranakis, P.Â G. Spirakis, and
P.Â UznaÅ„ski.
On convergence and threshold properties of discrete lotka-volterra
population protocols.
J. Comput. Syst. Sci.
, 130:1â€“25, 2022.
URL
https://doi.org/10.1016/j.jcss.2022.06.002
.
Dabagia etÂ al. (2024)
M.Â Dabagia, C.Â H. Papadimitriou, and S.Â S. Vempala.
Computation with sequences of assemblies in a model of the brain.
Neural Computation
, 37(1):193â€“233, 12
2024.
ISSN 0899-7667.
URL
https://doi.org/10.1162/neco_a_01720
.
Dai etÂ al. (2019)
Z.Â Dai, Z.Â Yang, Y.Â Yang, J.Â G. Carbonell, Q.Â V. Le, and R.Â Salakhutdinov.
Transformer-XL: Attentive language models beyond a fixed-length
context.
In A.Â Korhonen, D.Â R. Traum, and L.Â MÃ rquez, editors,
Proceedings of the 57th Conference of the Association for Computational
Linguistics, ACL 2019, Florence, Italy, July 28- August 2, 2019, Volume 1:
Long Papers
, pages 2978â€“2988. Association for Computational Linguistics,
2019.
doi:
10.18653/V1/P19-1285
.
URL
https://doi.org/10.18653/v1/p19-1285
.
Dehghani etÂ al. (2019)
M.Â Dehghani, S.Â Gouws, O.Â Vinyals, J.Â Uszkoreit, and Åukasz Kaiser.
Universal transformers, 2019.
URL
https://arxiv.org/abs/1807.03819
.
Dolev (2000)
S.Â Dolev.
Self-stabilization
.
The MIT Press, 2000.
Doty etÂ al. (2021)
D.Â Doty, M.Â Eftekhari, L.Â Gasieniec, E.Â E. Severson, P.Â UznaÅ„ski, and
G.Â Stachowiak.
A time and space optimal stable population protocol solving exact
majority.
In
62nd IEEE Annual Symposium on Foundations of Computer
Science, FOCS 2021, Denver, CO, USA, February 7-10, 2022
, pages
1044â€“1055. IEEE, 2021.
URL
https://doi.org/10.1109/FOCS52979.2021.00104
.
Dudek and Kosowski (2018)
B.Â Dudek and A.Â Kosowski.
Universal protocols for information dissemination using emergent
signals.
In I.Â Diakonikolas, D.Â Kempe, and M.Â Henzinger, editors,
Proceedings of the 50th Annual ACM SIGACT Symposium on Theory of
Computing, STOC 2018, Los Angeles, CA, USA, June 25-29, 2018
, pages
87â€“99. ACM, 2018.
URL
https://doi.org/10.1145/3188745.3188818
.
Emberson etÂ al. (2025)
L.Â Emberson, B.Â Cottier, J.Â You, T.Â Adamczewski, and J.-S. Denain.
LLM responses to benchmark questions are getting longer over time,
2025.
URL
https://epoch.ai/data-insights/output-length
.
Accessed: 2025-07-25.
Feinberg (2019)
M.Â Feinberg.
Foundations of Chemical Reaction Network Theory
, volume 202 of
Applied Mathematical Sciences
.
Springer, 2019.
Fraigniaud and Giakkoupis (2010)
P.Â Fraigniaud and G.Â Giakkoupis.
On the searchability of small-world networks with arbitrary
underlying structure.
In
Proceedings of the Forty-Second ACM Symposium on Theory of
Computing
, STOC â€™10, page 389â€“398, New York, NY, USA, 2010. Association
for Computing Machinery.
ISBN 9781450300506.
doi:
10.1145/1806689.1806744
.
URL
https://doi.org/10.1145/1806689.1806744
.
Graves (2017)
A.Â Graves.
Adaptive computation time for recurrent neural networks, 2017.
URL
https://arxiv.org/abs/1603.08983
.
Gu and Dao (2024)
A.Â Gu and T.Â Dao.
Mamba: Linear-time sequence modeling with selective state spaces,
2024.
URL
https://arxiv.org/abs/2312.00752
.
Haziza etÂ al. (2025)
D.Â Haziza, T.Â Chou, D.Â Choudhary, L.Â Wehrstedt, F.Â Massa, J.Â Yu, G.Â Jeong,
S.Â Rao, P.Â Labatut, and J.Â Cai.
Accelerating transformer inference and training with 2:4 activation
sparsity, 2025.
URL
https://arxiv.org/abs/2503.16672
.
He etÂ al. (2010)
B.Â J. He, J.Â M. Zempel, A.Â Z. Snyder, and M.Â E. Raichle.
The temporal structures and functional significance of scale-free
brain activity.
Neuron
, 66(3):353â€“369, 2010.
ISSN 0896-6273.
URL
https://doi.org/10.1016/j.neuron.2010.04.020
.
Hebb (1949)
D.Â O. Hebb.
Organization of behavior.
New York: Wiley & Sons, 1949.
Herrmann etÂ al. (2025)
V.Â Herrmann, R.Â CsordÃ¡s, and J.Â Schmidhuber.
Measuring in-context computation complexity via hidden state
prediction, 2025.
URL
https://arxiv.org/abs/2503.13431
.
Hilbert (1902)
D.Â Hilbert.
Mathematical problems.
Bull. AMS
, 8(10):437â€“479, 1902.
ISSN 0002-9904 (print), 1936-881X (electronic).
URL
https://doi.org/10.1090/S0002-9904-1902-00923-3
.
English translation of Hilbertâ€™s famous list of 23 important problems
in mathematics for the 20th Century.
Hinton (2005)
G.Â E. Hinton.
What kind of a graphical model is the brain?
In
Proceedings of the 19th International Joint Conference on
Artificial Intelligence
, IJCAIâ€™05, page 1765â€“1775, San Francisco, CA, USA,
2005. Morgan Kaufmann Publishers Inc.
Hinton and Plaut (1987)
G.Â E. Hinton and D.Â C. Plaut.
Using fast weights to deblur old memories.
In
Proceedings of the ninth annual conference of the Cognitive
Science Society
, pages 177â€“186, 1987.
Hirvonen and Suomela (2025)
J.Â Hirvonen and J.Â Suomela.
Distributed Algorithms 2020 â€” the book
.
Aalto University, 2025.
URL
https://jukkasuomela.fi/da2020/da2020.pdf
.
Hochreiter and Schmidhuber (1997)
S.Â Hochreiter and J.Â Schmidhuber.
Long short-term memory.
Neural Comput.
, 9(8):1735â€“1780, Nov.
1997.
ISSN 0899-7667.
URL
https://doi.org/10.1162/neco.1997.9.8.1735
.
Hofbauer and Sigmund (1998)
J.Â Hofbauer and K.Â Sigmund.
Evolutionary Games and Population Dynamics
.
Cambridge University Press, 1998.
URL
https://www.cambridge.org/core/books/evolutionary-games-and-population-dynamics/A8D94EBE6A16837E7CB3CED24E1948F8
.
Holland etÂ al. (1983)
P.Â W. Holland, K.Â B. Laskey, and S.Â Leinhardt.
Stochastic blockmodels: First steps.
Social Networks
, 5(2):109â€“137, 1983.
ISSN 0378-8733.
URL
https://www.sciencedirect.com/science/article/pii/0378873383900217
.
Hu etÂ al. (2021)
E.Â J. Hu, Y.Â Shen, P.Â Wallis, Z.Â Allen-Zhu, Y.Â Li, S.Â Wang, L.Â Wang, and
W.Â Chen.
Lora: Low-rank adaptation of large language models, 2021.
URL
https://arxiv.org/abs/2106.09685
.
Huang etÂ al. (2025)
X.Â Huang, A.Â Yang, S.Â Bhattamishra, Y.Â Sarrof, A.Â Krebs, H.Â Zhou, P.Â Nakkiran,
and M.Â Hahn.
A formal framework for understanding length generalization in
transformers.
In
The Thirteenth International Conference on Learning
Representations
, 2025.
URL
https://openreview.net/forum?id=U49N5V51rU
.
Jabr and Rothschild (2012)
F.Â Jabr and A.Â Rothschild.
How brainless slime molds redefine intelligence.
Nature
, 7(1), 2012.
Jojic etÂ al. (2023)
A.Â Jojic, Z.Â Wang, and N.Â Jojic.
Gpt is becoming a turing machine: Here are some ways to program it.
arXiv preprint arXiv:2303.14310
, 2023.
Kalev and Hen (2025)
A.Â Kalev and I.Â Hen.
Feynman path integrals for discrete-variable systems: Walks on
hamiltonian graphs.
Phys. Rev. Res.
, 7:013220, Feb 2025.
URL
https://link.aps.org/doi/10.1103/PhysRevResearch.7.013220
.
Karpathy (2024)
A.Â Karpathy.
nanoGPT.
https://github.com/karpathy/nanoGPT
, 2024.
Karrer and Newman (2011)
B.Â Karrer and M.Â E.Â J. Newman.
Stochastic blockmodels and community structure in networks.
Phys. Rev. E
, 83:016107, Jan 2011.
URL
https://link.aps.org/doi/10.1103/PhysRevE.83.016107
.
Katharopoulos etÂ al. (2020)
A.Â Katharopoulos, A.Â Vyas, N.Â Pappas, and F.Â Fleuret.
Transformers are RNNs: Fast autoregressive transformers with linear
attention.
In H.Â D. III and A.Â Singh, editors,
Proceedings of the 37th
International Conference on Machine Learning
, volume 119 of
Proceedings of Machine Learning Research
, pages 5156â€“5165. PMLR,
13â€“18 Jul 2020.
URL
https://proceedings.mlr.press/v119/katharopoulos20a.html
.
Kempe etÂ al. (2003)
D.Â Kempe, J.Â Kleinberg, and E.Â Tardos.
Maximizing the spread of influence through a social network.
In
KDD â€™03: Proceedings of the ninth ACM SIGKDD international
conference on Knowledge discovery and data mining
, pages 137â€“146, New York,
NY, USA, 2003. ACM Press.
ISBN 1-58113-737-0.
URL
https://doi.acm.org/10.1145/956750.956769
.
Kitaev etÂ al. (2020)
N.Â Kitaev, Å.Â Kaiser, and A.Â Levskaya.
Reformer: The efficient transformer.
In
8th International Conference on Learning Representations,
ICLR 2020, Addis Ababa, Ethiopia, April 26-30, 2020
. OpenReview.net, 2020.
URL
https://openreview.net/forum?id=rkgNKkHtvB
.
Koehn (2005)
P.Â Koehn.
Europarl: A parallel corpus for statistical machine translation.
In
Proceedings of Machine Translation Summit X: Papers
, pages
79â€“86, Phuket, Thailand, Sept. 13-15 2005.
URL
https://aclanthology.org/2005.mtsummit-papers.11/
.
Kosowski and UznaÅ„ski (2018)
A.Â Kosowski and P.Â UznaÅ„ski.
Population protocols are fast.
In C.Â Newport and I.Â Keidar, editors,
Proceedings of the 2018
ACM Symposium on Principles of Distributed Computing, PODC 2018, Egham,
United Kingdom, July 23-27, 2018
, pages 475â€“477. ACM, 2018.
URL
https://arxiv.org/abs/1802.06872
.
Krauthgamer and Sapir (2023)
R.Â Krauthgamer and S.Â Sapir.
Comparison of matrix norm sparsification.
Algorithmica
, 85(12):3957â€“3972, 2023.
URL
https://doi.org/10.1007/s00453-023-01172-6
.
Kumar etÂ al. (2025)
A.Â Kumar, L.Â Owen, N.Â R. Chowdhury, and F.Â GÃ¼ra.
ZClip: Adaptive spike mitigation for LLM pre-training, 2025.
URL
https://arxiv.org/abs/2504.02507
.
LeCun (2022)
Y.Â LeCun.
A path towards autonomous machine intelligence version 0.9. 2,
2022-06-27.
Open Review
, 62(1):1â€“62, 2022.
LeCun etÂ al. (2015)
Y.Â LeCun, Y.Â Bengio, and G.Â Hinton.
Deep learning.
Nature
, 521(7553):436â€“444, 2015.
Lee etÂ al. (2017)
J.Â Lee, Y.Â Bahri, R.Â Novak, S.Â S. Schoenholz, J.Â Pennington, and
J.Â Sohl-Dickstein.
Deep neural networks as gaussian processes.
arXiv preprint arXiv:1711.00165
, 2017.
Lin etÂ al. (2014)
A.Â C. Lin, A.Â M. Bygrave, A.Â DeÂ Calignon, T.Â Lee, and G.Â MiesenbÃ¶ck.
Sparse, decorrelated odor coding in the mushroom body enhances
learned odor discrimination.
Nature neuroscience
, 17(4):559â€“568, 2014.
Lin and Jegelka (2018)
H.Â Lin and S.Â Jegelka.
Resnet with one-neuron hidden layers is a universal approximator.
Advances in neural information processing systems
, 31, 2018.
Liu etÂ al. (2025)
K.Â Liu, J.Â Gao, and K.Â Chen.
Scaling up the state size of RNN LLMs for long-context scenarios.
In W.Â Che, J.Â Nabende, E.Â Shutova, and M.Â T. Pilehvar, editors,
Proceedings of the 63rd Annual Meeting of the Association for
Computational Linguistics (Volume 1: Long Papers)
, pages 11516â€“11529,
Vienna, Austria, July 2025. Association for Computational Linguistics.
ISBN 979-8-89176-251-0.
URL
https://aclanthology.org/2025.acl-long.564/
.
Loshchilov and Hutter (2019)
I.Â Loshchilov and F.Â Hutter.
Decoupled weight decay regularization, 2019.
URL
https://arxiv.org/abs/1711.05101
.
Mante etÂ al. (2013)
V.Â Mante, D.Â Sussillo, K.Â V. Shenoy, and W.Â T. Newsome.
Context-dependent computation by recurrent dynamics in prefrontal
cortex.
nature
, 503(7474):78â€“84, 2013.
MassouliÃ© (2014)
L.Â MassouliÃ©.
Community detection thresholds and the weak ramanujan property.
In
Proceedings of the Forty-Sixth Annual ACM Symposium on
Theory of Computing
, STOC â€™14, page 694â€“703, New York, NY, USA, 2014.
Association for Computing Machinery.
ISBN 9781450327107.
URL
https://doi.org/10.1145/2591796.2591857
.
McCulloch and Pitts (1943)
W.Â S. McCulloch and W.Â Pitts.
A logical calculus of the ideas immanent in nervous activity.
The Bulletin of Mathematical Biophysics
, 5(4):115â€“133, 1943.
McSherry etÂ al. (2013)
F.Â McSherry, D.Â G. Murray, R.Â Isaacs, and M.Â Isard.
Differential dataflow.
In
Sixth Biennial Conference on Innovative Data Systems
Research, CIDR 2013, Asilomar, CA, USA, January 6-9, 2013, Online
Proceedings
. www.cidrdb.org, 2013.
URL
https://cidrdb.org/cidr2013/Papers/CIDR13_Paper111.pdf
.
Merrill and
Sabharwal (2024)
W.Â Merrill and A.Â Sabharwal.
The expressive power of transformers with chain of thought.
In
The Twelfth International Conference on Learning
Representations
, 2024.
URL
https://openreview.net/forum?id=NjNGlPh8Wh
.
Mikolov etÂ al. (2013)
T.Â Mikolov, I.Â Sutskever, K.Â Chen, G.Â S. Corrado, and J.Â Dean.
Distributed representations of words and phrases and their
compositionality.
Advances in neural information processing systems
, 26, 2013.
Mitropolsky and Papadimitriou (2025)
D.Â Mitropolsky and C.Â H. Papadimitriou.
Simulated language acquisition in a biologically realistic model of
the brain.
bioRxiv
, 2025.
doi:
10.1101/2025.07.15.664996
.
URL
https://www.biorxiv.org/content/early/2025/07/19/2025.07.15.664996
.
Mohsenzadeh etÂ al. (2020)
Y.Â Mohsenzadeh, C.Â Mullin, B.Â Lahner, and A.Â Oliva.
Emergence of visual center-periphery spatial organization in deep
convolutional neural networks.
Scientific Reports
, 10(1):4638, 2020.
URL
https://doi.org/10.1038/s41598-020-61409-0
.
Nair and Hinton (2010)
V.Â Nair and G.Â E. Hinton.
Rectified linear units improve restricted boltzmann machines.
In
Proceedings of the 27th international conference on machine
learning (ICML-10)
, pages 807â€“814, 2010.
Neal (2012)
R.Â M. Neal.
Bayesian learning for neural networks
, volume 118.
Springer Science & Business Media, 2012.
Neumann (1958)
J.Â v. Neumann.
The computer and the brain
.
Yale University Press, USA, 1958.
ISBN 0300007930.
Newman (2006)
M.Â E.Â J. Newman.
Modularity and community structure in networks.
Proceedings of the National Academy of Sciences
, 103(23):8577â€“8582, 2006.
doi:
10.1073/pnas.0601602103
.
URL
https://www.pnas.org/doi/abs/10.1073/pnas.0601602103
.
Olshausen (2018)
B.Â A. Olshausen.
(ed.), The Brain and Computation â€” Simons Institute Program,
Berkeley, 2018.
URL
https://simons.berkeley.edu/programs/brain-computation
.
Olshausen and Field (1997)
B.Â A. Olshausen and D.Â J. Field.
Sparse coding with an overcomplete basis set: A strategy employed by
V1?
Vision Research
, 37(23):3311â€“3325, 1997.
ISSN 0042-6989.
URL
https://doi.org/10.1016/S0042-6989(97)00169-7
.
Olsson etÂ al. (2022)
C.Â Olsson, N.Â Elhage, N.Â Nanda, N.Â Joseph, N.Â DasSarma, T.Â Henighan, B.Â Mann,
A.Â Askell, Y.Â Bai, A.Â Chen, T.Â Conerly, D.Â Drain, D.Â Ganguli,
Z.Â Hatfield-Dodds, D.Â Hernandez, S.Â Johnston, A.Â Jones, J.Â Kernion,
L.Â Lovitt, K.Â Ndousse, D.Â Amodei, T.Â Brown, J.Â Clark, J.Â Kaplan,
S.Â McCandlish, and C.Â Olah.
In-context learning and induction heads.
Transformer Circuits Thread
, 2022.
URL
https://transformer-circuits.pub/2022/in-context-learning-and-induction-heads/index.html
.
Ostmeier etÂ al. (2025)
S.Â Ostmeier, B.Â Axelrod, M.Â Varma, M.Â E. Moseley, A.Â Chaudhari, and
C.Â Langlotz.
LieRE: Lie rotational positional encodings, 2025.
URL
https://arxiv.org/abs/2406.10322
.
Papadimitriou etÂ al. (2020)
C.Â H. Papadimitriou, S.Â S. Vempala, D.Â Mitropolsky, M.Â Collins, and W.Â Maass.
Brain computation by assemblies of neurons.
Proceedings of the National Academy of Sciences
, 117(25):14464â€“14472, 2020.
URL
https://www.pnas.org/doi/abs/10.1073/pnas.2001893117
.
Paszke etÂ al. (2019)
A.Â Paszke, S.Â Gross, F.Â Massa, A.Â Lerer, J.Â Bradbury, G.Â Chanan, T.Â Killeen,
Z.Â Lin, N.Â Gimelshein, L.Â Antiga, etÂ al.
Pytorch: An imperative style, high-performance deep learning library.
Advances in neural information processing systems
, 32, 2019.
Peleg (2000)
D.Â Peleg.
Distributed Computing: A Locality-Sensitive Approach
.
Society for Industrial and Applied Mathematics, 2000.
URL
https://epubs.siam.org/doi/abs/10.1137/1.9780898719772
.
PÃ©rez etÂ al. (2021)
J.Â PÃ©rez, P.Â BarcelÃ³, and J.Â Marinkovic.
Attention is turing complete.
J. Mach. Learn. Res.
, 22(1), Jan. 2021.
ISSN 1532-4435.
Press etÂ al. (2022)
O.Â Press, N.Â A. Smith, and M.Â Lewis.
Train short, test long: Attention with linear biases enables input
length extrapolation, 2022.
URL
https://arxiv.org/abs/2108.12409
.
Radford etÂ al. (2019)
A.Â Radford, J.Â Wu, R.Â Child, D.Â Luan, D.Â Amodei, and I.Â Sutskever.
Language models are unsupervised multitask learners.
OpenAI blog
, 1(8):9, 2019.
Rolla (2020)
L.Â T. Rolla.
Activated random walks on
â„¤
d
\mathbb{Z}^{d}
.
Probability Surveys
, 17, Jan. 2020.
ISSN 1549-5787.
URL
https://dx.doi.org/10.1214/19-PS339
.
Romanid (2025)
Romanid.
Wikipedia, the free encyclopedia, 2025.
URL
https://en.wikipedia.org/w/index.php?title=Romanid&oldid=1275565870
.
[Online; accessed 24-July-2025].
Rumelhart etÂ al. (1986)
D.Â E. Rumelhart, G.Â E. Hinton, and R.Â J. Williams.
Learning representations by back-propagating errors.
Nature
, 323(6088):533â€“536, 1986.
Rusch and Rus (2025)
T.Â K. Rusch and D.Â Rus.
Oscillatory state-space models.
In
The Thirteenth International Conference on Learning
Representations
, 2025.
URL
https://openreview.net/forum?id=GRMfXcAAFh
.
Sabour etÂ al. (2017)
S.Â Sabour, N.Â Frosst, and G.Â E. Hinton.
Dynamic routing between capsules.
Advances in neural information processing systems
, 30, 2017.
Schmidhuber (1993)
J.Â Schmidhuber.
Reducing the ratio between learning complexity and number of time
varying variables in fully recurrent nets.
In
International Conference on Artificial Neural Networks
,
pages 460â€“463. Springer, 1993.
Shazeer etÂ al. (2017)
N.Â Shazeer, A.Â Mirhoseini, K.Â Maziarz, A.Â Davis, Q.Â Le, G.Â Hinton, and J.Â Dean.
Outrageously large neural networks: The sparsely-gated
mixture-of-experts layer, 2017.
URL
https://arxiv.org/abs/1701.06538
.
Shen etÂ al. (2022)
Z.Â Shen, H.Â Yang, and S.Â Zhang.
Optimal approximation rate of ReLU networks in terms of width and
depth.
Journal de MathÃ©matiques Pures et AppliquÃ©es
, 157:101â€“135, 2022.
ISSN 0021-7824.
doi:
https://doi.org/10.1016/j.matpur.2021.07.009
.
URL
https://www.sciencedirect.com/science/article/pii/S0021782421001124
.
Shojaee etÂ al. (2025)
P.Â Shojaee, I.Â Mirzadeh, K.Â Alizadeh, M.Â Horton, S.Â Bengio, and M.Â Farajtabar.
The illusion of thinking: Understanding the strengths and limitations
of reasoning models via the lens of problem complexity, 2025.
URL
https://arxiv.org/abs/2506.06941
.
Srivastava etÂ al. (2014)
N.Â Srivastava, G.Â Hinton, A.Â Krizhevsky, I.Â Sutskever, and R.Â Salakhutdinov.
Dropout: a simple way to prevent neural networks from overfitting.
The journal of machine learning research
, 15(1):1929â€“1958, 2014.
Su etÂ al. (2024)
J.Â Su, M.Â H.Â M. Ahmed, Y.Â Lu, S.Â Pan, W.Â Bo, and Y.Â Liu.
Roformer: Enhanced transformer with rotary position embedding.
Neurocomputing
, 568:127063, 2024.
doi:
10.1016/J.NEUCOM.2023.127063
.
URL
https://doi.org/10.1016/j.neucom.2023.127063
.
Sun etÂ al. (2023)
Y.Â Sun, L.Â Dong, S.Â Huang, S.Â Ma, Y.Â Xia, J.Â Xue, J.Â Wang, and F.Â Wei.
Retentive Network: A successor to Transformer for large language
models, 2023.
URL
https://arxiv.org/abs/2307.08621
.
Turing (1950)
A.Â M. Turing.
Computing machinery and intelligence.
Mind
, 59(236):433â€“460, 1950.
ISSN 00264423.
URL
https://www.jstor.org/stable/2251299
.
Udell and Townsend (2019)
M.Â Udell and A.Â Townsend.
Why are big data matrices approximately low rank?
SIAM J. Math. Data Sci.
, 1(1):144â€“160,
2019.
doi:
10.1137/18M1183480
.
URL
https://doi.org/10.1137/18M1183480
.
Vaswani etÂ al. (2017)
A.Â Vaswani, N.Â Shazeer, N.Â Parmar, J.Â Uszkoreit, L.Â Jones, A.Â N. Gomez,
Å.Â Kaiser, and I.Â Polosukhin.
Attention is all you need.
Advances in neural information processing systems
, 30, 2017.
Wei etÂ al. (2022)
J.Â Wei, X.Â Wang, D.Â Schuurmans, M.Â Bosma, B.Â Ichter, F.Â Xia, E.Â H. Chi, Q.Â V.
Le, and D.Â Zhou.
Chain-of-thought prompting elicits reasoning in large language
models.
In
Proceedings of the 36th International Conference on Neural
Information Processing Systems
, NIPS â€™22, Red Hook, NY, USA, 2022. Curran
Associates Inc.
ISBN 9781713871088.
Weiss etÂ al. (2021)
G.Â Weiss, Y.Â Goldberg, and E.Â Yahav.
Thinking like transformers.
In M.Â Meila and T.Â Zhang, editors,
Proceedings of the 38th
International Conference on Machine Learning
, volume 139 of
Proceedings of Machine Learning Research
, pages 11080â€“11090. PMLR,
18â€“24 Jul 2021.
URL
https://proceedings.mlr.press/v139/weiss21a.html
.
Whittington etÂ al. (2020)
J.Â C. Whittington, T.Â H. Muller, S.Â Mark, G.Â Chen, C.Â Barry, N.Â Burgess, and
T.Â E. Behrens.
The Tolman-Eichenbaum Machine: Unifying space and relational memory
through generalization in the hippocampal formation.
Cell
, 183(5):1249â€“1263.e23, 2020.
ISSN 0092-8674.
URL
https://doi.org/10.1016/j.cell.2020.10.024
.
Whittington etÂ al. (2022)
J.Â C.Â R. Whittington, J.Â Warren, and T.Â E. Behrens.
Relating transformers to models and neural representations of the
hippocampal formation.
In
International Conference on Learning Representations
, 2022.
URL
https://openreview.net/forum?id=B8DVo9B1YE0
.
Williams and Peng (1990)
R.Â J. Williams and J.Â Peng.
An efficient gradient-based algorithm for on-line training of
recurrent network trajectories.
Neural computation
, 2(4):490â€“501, 1990.
Yang and Chiang (2024)
A.Â Yang and D.Â Chiang.
Counting like transformers: Compiling temporal counting logic into
softmax transformers, 2024.
URL
https://arxiv.org/abs/2404.04393
.
Yang (2019)
G.Â Yang.
Wide feedforward or recurrent neural networks of any architecture are
gaussian processes.
Advances in Neural Information Processing Systems
, 32, 2019.
Yang etÂ al. (2016)
Z.Â Yang, D.Â Yang, C.Â Dyer, X.Â He, A.Â Smola, and E.Â Hovy.
Hierarchical attention networks for document classification.
In
Proceedings of the 2016 Conference of the North American
Chapter of the Association for Computational Linguistics: Human Language
Technologies
, pages 1480â€“1489, 2016.
You etÂ al. (2025)
C.Â You, K.Â Wu, Z.Â Jia, L.Â Chen, S.Â Bhojanapalli, J.Â Guo, U.Â Evci,
J.Â Wassenberg, P.Â Netrapalli, J.Â J. Willcock, S.Â Subramanian, F.Â Chern,
A.Â Andreev, S.Â Pathak, F.Â Yu, P.Â Jain, D.Â E. Culler, H.Â M. Levy, and
S.Â Kumar.
Spark transformer: Reactivating sparsity in FFN and attention,
2025.
URL
https://arxiv.org/abs/2506.06644
.
Zhou etÂ al. (2024)
H.Â Zhou, A.Â Bradley, E.Â Littwin, N.Â Razin, O.Â Saremi, J.Â M. Susskind,
S.Â Bengio, and P.Â Nakkiran.
What algorithms can transformers learn? A study in length
generalization.
In
The Twelfth International Conference on Learning
Representations, ICLR 2024, Vienna, Austria, May 7-11, 2024
.
OpenReview.net, 2024.
URL
https://openreview.net/forum?id=AssIuHnmHX
.
Zou (2019)
M.Â Zou.
Aspects of Efficiency in Selected Problems of Computation on
Large Graphs
.
PhD thesis, Paris Diderot University, France, 2019.
URL
https://tel.archives-ouvertes.fr/tel-02436610
.
Appendix A
Connection between generalization of reasoning and computational expressiveness
State-of-the-art reasoning models have the interpretation of (Turing-complete) programs, executed over a certain period of time. This shifts the emphasis of generalization, from discovering the structure of mathematical functions which maps inputs to outputs, to discovering a class of runnable programs, which take as input a given class of input prompts, and process these prompts â€œin the right directionâ€.
Consider a given reasoning task, whose scope is defined as a set
ğ’«
\mathcal{P}
of valid input prompts, given as bounded-length token sequences over some alphabet
Î©
\Omega
. Given a prompt from
ğ’«
\mathcal{P}
, a model solving the considered task is eventually (i.e, after some number of steps of reasoning) expected to generate an output, in the form of a bounded-length token sequence over the same alphabet
Î©
\Omega
, which is subjected to evaluation. Consider language models sampled from some probability distribution
â„³
1
\mathcal{M}_{1}
over parameter sets in some architecture
ğ’œ
1
\mathcal{A}_{1}
.
Now, suppose that for some other model architecture
ğ’œ
2
\mathcal{A}_{2}
there exists a distribution
â„³
2
\mathcal{M}_{2}
over language models in
ğ’œ
2
\mathcal{A}_{2}
such that, for a valid input prompt chosen uniformly at random from
ğ’«
\mathcal{P}
, the outputs sampled from a model
M
1
âˆ¼
â„³
1
M_{1}\sim\mathcal{M}_{1}
and the outputs sampled from a model
M
2
âˆ¼
â„³
2
M_{2}\sim\mathcal{M}_{2}
, have (almost) the same distribution in the space of bounded-length sequences over
Î©
\Omega
, and are both obtained within some asymptotic bound on the number of steps of reasoning, in expectation. The described setting is equivalent to saying that
models
â„³
2
\mathcal{M}_{2}
have generalized the considered task
ğ’«
\mathcal{P}
in (almost) the same way as models
â„³
1
\mathcal{M}_{1}
. Indeed, conversely, if the described condition did not hold, we could, in a finite number of trials, distinguish solutions to problem
ğ’«
\mathcal{P}
obtained by model families
â„³
1
\mathcal{M}_{1}
and
â„³
2
\mathcal{M}_{2}
.
Now, consider model architectures
ğ’œ
1
,
ğ’œ
2
\mathcal{A}_{1},\mathcal{A}_{2}
which apply Chain-of-Thought reasoning
(Wei etÂ al.,
2022
)
. A model in such an architecture has the interpretation of a trainable probabilistic program, taking inputs from
ğ’«
\mathcal{P}
, and the architectures themselves represent computational machine architectures. Moving to a discussion of computational expressiveness, we obtain the following statement.
Observation 9
.
Given a probability distribution of models
â„³
1
\mathcal{M}_{1}
in architecture
ğ’œ
1
\mathcal{A}_{1}
, suppose there exists a distribution over models in architecture
ğ’œ
2
\mathcal{A}_{2}
which generalizes on task
ğ’«
\mathcal{P}
in the same way as models from
â„³
1
\mathcal{M}_{1}
. Then, the machine architecture
ğ’œ
2
\mathcal{A}_{2}
has sufficient computational expressiveness to simulate programs from
â„³
1
\mathcal{M}_{1}
efficiently on the set of inputs
ğ’«
\mathcal{P}
, i.e.,
ğ’œ
2
\mathcal{A}_{2}
contains programs which obtain an (almost) identical distribution of outputs within the given bounds on running time.
âˆ
In particular, we note that if we were to consider the special case of
ğ’œ
1
\mathcal{A}_{1}
being reasonable human agents, we could say that architecture
ğ’œ
2
\mathcal{A}_{2}
generalizes reasoning, in the same way as humans, if we can train models
â„³
2
\mathcal{M}_{2}
in
ğ’œ
2
\mathcal{A}_{2}
which accurately reproduce the outcomes of reasoning for some sample
â„³
1
\mathcal{M}_{1}
of humans in
ğ’œ
1
\mathcal{A}_{1}
.
This leads us naturally to describe Language Model generalization through a universal reference to the principles of operation of the human brain, treated as a distributed computing architecture, and not through a characterization of language and reasoning prompts
ğ’«
\mathcal{P}
that the model should be able to deal with in some specific way.
Appendix B
Further description of experiments
B.1
Language translation task
We have evaluated our models on a mixed language modeling and translation task derived from the Europarl corpus
(Koehn,
2005
)
. The corpus consists of sentence-level aligned translations of transcripts of European Parliament proceedings. For each language pair, we treat the data as a long stream of interleaved source and target sentences (sampling for each sentence which language is the source, and which is the target) on which we train decoder only models. Thus, models are jointly trained as language models and translators. We train all models using Truncated Backpropagation Through Time
(Williams and Peng,
1990
)
. Subsequent minibatches served by the data loader are related: each is a continuation of the previous. Each model maintains a recurrent state, carried across minibatches:
ğ†
{\boldsymbol{\rho}}
matrix for BDH-GPU and a FIFO buffer of recent KV-cache entries for the TransformerXL
(Dai etÂ al.,
2019
)
baseline. We train all models on raw UTF8 data. We are mainly interested in model comparison and prefer to keep the experimental setup as simple as possible. A few minibatches are shown in Fig.
16
.
The joint language modeling and translation formulation has several benefits:
1.
Next token prediction is representative for LLM training. Simple architectures, such as decoder-only models are sufficient.
2.
The task promotes models with long context capabilities â€” subsequent sentences are related and the model can meaningfully
utilize long context to model the source language sentences.
3.
The task promotes models which carry state across minibatches, as training data is temporally coherent and the final model state at the end of one minibatch is a natural initialization of hidden state on the next minibatch.
4.
Translation can be seen as language modeling coupled with fuzzy copying. Successful models will need to develop in-context learning capabilities such as inductive heads
(Olsson etÂ al.,
2022
)
.
0. |<F:en>For countries such as Sweden and Finland, another system o|
        1. |f allocation would be extremely significant.<T:es>Por ejemplo, p|
        2. |ara pases como Suecia y Finlandia tendra un gran significado|
        3. | que se hiciese otra forma de distribucin.<F:es>El diputado Fe|
        4. |rber ha presentado una propuesta que implica una distribucin m|
        5. |s flexible, y yo respaldo esta enmienda.<T:en>Mr Ferber has ta|
        6. |bled an amendment which involves our looking in a considerably m|
        7. |ore flexible way at the present allocation, and I support this a|
        8. |mendment.<F:en>.<T:es>.<F:en>(NL) Mr President, I would like to |
        9. |start by thanking both parliamentary committees and not least bo|
Figure 16:
Exemplary sequence of 10 successive minibatches from the translation task. The model is trained on raw UTF8 bytes (for visualization we pad multi-byte UTF8 characters with â€œâ€¢â€ symbol). Special token strings
<F:lang_code>
and
<T:lang_code>
delimit source and target sentences. Minibatches are temporally coherent: source sentences are followed by their translations, and subsequent source sentences are part of the same larger document.
B.2
BDH Scaling Experimental Details
We provide details on models used in scaling experiments described in Section
4.2
. All models were implemented in PyTorch
(Paszke etÂ al.,
2019
)
and trained on the Europarl
(Koehn,
2005
)
task described in Section
B.1
. We have kept the same training regime for all models at all sizes: En-PL and En-Cs language pairs (380MB total). All models trained on raw UTF8 bytes seeing a total of 1.2B tokens (about 3 epochs). All minibatches were 2048 tokens long, but we have varied the number of examples in the minibatch (varying number of tokens in each minibatch) to accommodate different memory requirements of different models. We have used multi-GPU training using the Distributed Data Parallel approach using AdamW
(Loshchilov and Hutter,
2019
)
with learning rate
10
âˆ’
3
10^{-3}
, and 1000 warm-up step followed by linear learning rate decay over the course of training to
10
âˆ’
4
10^{-4}
, adaptive gradient clipping
(Kumar etÂ al.,
2025
)
, and weight decay
0.1
0.1
. Models were trained to operate on a context longer than minibatch length using Truncated Backpropagation Through time
(Williams and Peng,
1990
)
.
The Baseline model, dubbed GPTXL, was a GPT2-like transformer
(Radford etÂ al.,
2019
)
based off the NanoGPT
(Karpathy,
2024
)
implementation with KV-cache carried across minibatches as in TransformerXL
(Dai etÂ al.,
2019
)
. We have used ALiBi positional biases
Press etÂ al. (
2022
)
. We list its hyperparameters for various model sizes in Table
4
. Optimal Dropout was selected using a small sweep at each model size.
model
num
embd
num
MLP
dropout
Carried KV-cache
size
layer
dim
head
dim
size
25M
9
480
5
1920
0.01
4096
50M
12
576
6
2304
0.02
4096
100M
15
768
8
3072
0.02
4096
200M
18
960
10
3840
0.002
4096
400M
25
1152
12
4608
0.005
4096
800M
28
1536
16
6144
0.15
4096
Table 4:
Hyperparameters for GPTXL baselines in scaling experiments. The model architecture follows GPT2
(Radford etÂ al.,
2019
)
, with a FIFO buffer of past KV-cache entries
(Dai etÂ al.,
2019
)
.
BDH-GPU directly uses model code provided in Appendix
E
. BDH-GPUâ€™ adds xLSTM-like gating mechanism
(Beck etÂ al.,
2024
)
, and merges next token predictions from all layers. Both BDH-GPU and BDH-GPUâ€™ use same architectural hyperparameters, gathered in Table
5
.
model
num
d
d
n
n
num
dropout
size
layer
head
25M
8
256
32768
4
0.1
50M
8
256
65536
4
0.1
100M
8
256
131072
4
0.1
200M
8
256
262144
4
0.1
400M
8
256
524288
4
0.1
800M
8
256
1048576
4
0.1
Table 5:
Hyperparameters for BDH-GPU models in scaling experiments.
B.3
BDH Monosemantic Synapse Experiment Details
We provide details for models used in exploration of monosemantic synapses in Section
6.2
. The model was trained on Europarl
(Koehn,
2005
)
described in Section
B.1
. It had
d
=
256
,
n
=
49152
d=256,n=49152
,
4
4
attention heads, and
8
8
layers. The model was trained on about one epoch of En-Es, En-Pt, and En-Fr data (total 1.9B tokens) in a Distributed Data Parallel setup using AdamW
(Loshchilov and Hutter,
2019
)
with learning rate
10
âˆ’
3
10^{-3}
, 1000 warm-up step followed by linear learning rate decay over the course of training to
10
âˆ’
4
10^{-4}
, adaptive gradient clipping
(Kumar etÂ al.,
2025
)
, and weight decay
0.1
0.1
. We have used Truncated Backpropagation Through time, carrying over the recurrent state of attention and training on sequences of length
2048
2048
characters at a time. We have used minimal Dropout
(Srivastava etÂ al.,
2014
)
of
0.01
0.01
.
B.4
BDH Merging Experiment Details
We provide details for models described in Section
7.1
All models were trained on Europarl
(Koehn,
2005
)
described in Section
B.1
. We provide model architecture hyperparametrs in Table
6
. Models were trained on about two passes over the training set in a Distributed Data Parallel setup using AdamW
(Loshchilov and Hutter,
2019
)
with learning rate
10
âˆ’
3
10^{-3}
, 1000 warmup step followed by linear learning rate decay over the course of training to
10
âˆ’
4
10^{-4}
, adaptive gradient clipping
(Kumar etÂ al.,
2025
)
, and weight decay
0.1
0.1
. We have used Truncated Backpropagation Through time, carrying over the recurrent state of attention and training on sequences of length
2048
2048
characters at a time. We have used minimal Dropout
(Srivastava etÂ al.,
2014
)
of
0.01
0.01
.
Model
Init.
Training
Data size
Training
n
d
num.
num.
param.
from
data
(bytes)
tokens
heads
layers
count
BaseEnEs
â€”
En-Es
612M
1.2B
24576
256
4
8
19M
TunedEnFr
BaseEnEs
En-Fr
640M
1.2B
24576
256
4
8
19M
TunedEnPt
BaseEnEs
En-Pt
616M
1.2B
24576
256
4
8
19M
MergedEnEsFrPt
TunedEnFr+TunedEnPt
â€”
â€”
â€”
49152
256
4
8
38M
Table 6:
Architecture and training details for model merging experiments.
Appendix C
Omitted formal claims and proofs
C.1
Proof of Observation
1
Proof.
The equivalence is straightforward to verify, rewriting the linear-algebraic multiplication expressions of Eq.Â (
6
) in Einstein summation notation and comparing respective index pairs. At any time, during the execution of rules for layer
l
l
, variables
X
â€‹
(
i
)
X(i)
,
Y
â€‹
(
i
)
Y(i)
and
Ïƒ
l
â€‹
(
i
,
j
)
\sigma_{l}(i,j)
in the protocol description, for
i
,
j
âˆˆ
{
1
,
â€¦
,
n
}
i,j\in\{1,\ldots,n\}
correspond to the
i
i
-th coordinate of vectors
x
t
,
l
x_{t,l}
(based on
x
t
,
l
âˆ’
1
x_{t,l-1}
from the previous round),
y
t
,
l
y_{t,l}
(based on
y
t
,
l
âˆ’
1
y_{t,l-1}
from the previous round), and matrix entry
ğˆ
t
,
l
{\boldsymbol{\sigma}}_{t,l}
(based on
ğˆ
t
âˆ’
1
,
l
{\boldsymbol{\sigma}}_{t-1,l}
from the previous token). The auxiliary variable
A
â€‹
(
i
)
A(i)
corresponds to a similar auxiliary vector
a
t
,
l
:=
ğˆ
t
âˆ’
1
,
l
â€‹
x
t
,
l
a_{t,l}:={\boldsymbol{\sigma}}_{t-1,l}x_{t,l}
in an intermediate step of computation of
y
t
,
l
y_{t,l}
from
x
t
,
l
x_{t,l}
. The parameter
u
â€‹
(
i
,
j
)
âˆˆ
R
+
u(i,j)\in R^{+}
associated with an element of state follows from the definition of matrix
U
U
; we assume for simplicity that
U
U
is diagonal (which corresponds to the case of ALiBi). Finally, in Table
1
, the auxiliary node variables
X
ğ”¢
â€‹
(
i
)
,
X
ğ”¦
â€‹
(
i
)
,
Y
ğ”¢
â€‹
(
i
)
,
Y
ğ”¦
â€‹
(
i
)
X^{\mathfrak{e}}(i),X^{\mathfrak{i}}(i),Y^{\mathfrak{e}}(i),Y^{\mathfrak{i}}(i)
are used to handle the thresholding of the inhibitory circuit.
âˆ
C.2
Formal statement of Claim
7
(linear attention)
We provide the following Claim, expressing the operation of attention under
C
C
-non-adversarial
key vectors
(
k
Ï„
)
(k_{\tau})
,
t
=
1
â€‹
â€¦
â€‹
t
t=1\ldots t
, understood in the sense that there exists
C
âˆˆ
N
C\in N
,
0
â‰¤
C
<
t
âˆ’
1
0\leq C<t-1
such that, if considering
(
k
Ï„
)
(k_{\tau})
as a sequence of random variables, each
f
â€‹
(
k
Ï„
)
f(k_{\tau})
,
Ï„
=
1
â€‹
â€¦
â€‹
t
\tau=1\ldots t
, can be considered sampled independently at random in
S
Î½
S^{\nu}
with respect to all keys sampled previously, except for at most
C
C
such keys. We put
C
=
t
âˆ’
1
C=t-1
for adversarial inputs, or if this condition cannot be satisfied at all due to the nature of function
f
f
.
Claim 8
.
Let
Î›
\Lambda
be a space of keys and queries, let
Ï•
:
Î›
Ã—
Î›
â†’
[
âˆ’
1
,
1
]
\phi:\Lambda\times\Lambda\to[-1,1]
be an attention affinity function, and let
f
:
Î›
â†’
S
Î½
f:\Lambda\to S^{\nu}
, for some
Î½
=
O
â€‹
(
poly
â€‹
(
n
)
)
\nu=O(\mathrm{poly}(n))
, be such that for any
q
,
k
âˆˆ
R
q,k\in R
, we have
f
â€‹
(
q
)
â‹…
f
â€‹
(
k
)
=
Ï•
â€‹
(
q
,
k
)
Â±
O
â€‹
(
n
âˆ’
100
)
f(q)\cdot f(k)=\phi(q,k)\pm O(n^{-100})
.
Fix
Î´
>
0
\delta>0
and
C
âˆˆ
â„•
C\in\mathbb{N}
. Let
A
Ï•
,
t
A_{\phi,t}
be a block which computes attention
a
t
a_{t}
given by Eq.Â (
14
), for a given sequence of key-query inputs
(
k
1
,
â€¦
,
k
t
)
(k_{1},\ldots,k_{t})
and values
(
v
1
,
â€¦
,
v
t
)
(v_{1},\ldots,v_{t})
, where
t
<
Î´
â€‹
n
/
(
(
C
+
1
)
â€‹
log
â¡
n
)
t<\delta n/((C+1)\log n)
is fixed,
k
Ï„
âˆˆ
Î›
k_{\tau}\in\Lambda
, and
v
Ï„
âˆˆ
R
d
v_{\tau}\in R^{d}
are of similar strength in the L2-norm, with
c
1
â‰¤
â€–
v
Ï„
â€–
â‰¤
c
2
c_{1}\leq\|v_{\tau}\|\leq c_{2}
, for all
Ï„
=
1
â€‹
â€¦
â€‹
t
\tau=1\ldots t
, for some constants
0
<
c
1
â‰¤
c
2
0<c_{1}\leq c_{2}
. Then the (simplified) linear attention equation of BDH-GPU:
a
t
âˆ—
:=
âˆ‘
Ï„
=
1
t
âˆ’
1
v
Ï„
â€‹
x
Ï„
T
â€‹
x
t
{a^{*}_{t}}:=\sum_{\tau=1}^{t-1}{v_{\tau}}{x_{\tau}}^{T}{x_{t}}
(17)
expresses
A
Ï•
,
t
A_{\phi,t}
with
O
â€‹
(
Î´
)
O(\sqrt{\delta})
-error in the L2-norm (i.e.,
â€–
a
Ï„
âˆ—
âˆ’
a
Ï„
â€–
=
O
â€‹
(
Î´
)
\|a^{*}_{\tau}-a_{\tau}\|=O(\sqrt{\delta})
, provided that the input vector
(
k
Ï„
)
(k_{\tau})
is
C
C
-non-adversarial, under a suitable randomly chosen key preparation function
f
â€²
:
Î›
â†’
R
n
f^{\prime}:\Lambda\to R^{n}
,
x
Ï„
:=
f
â€²
â€‹
(
k
Ï„
)
x_{\tau}:=f^{\prime}(k_{\tau})
, where
f
â€²
f^{\prime}
depends on
f
f
, w.h.p. in
n
n
with respect to choice of
f
â€²
f^{\prime}
.
Proof (sketch).
To simplify notation, assume w.l.o.g. that
Î›
=
S
Î½
\Lambda=S^{\nu}
and
f
=
i
â€‹
d
â€‹
e
â€‹
m
f=idem
; to undo this assumption, at the end of the proof we apply
f
âˆ˜
f
â€²
f\circ f^{\prime}
for preparation in place of
f
â€²
f^{\prime}
.
All vectors
v
v
and the result
a
t
a_{t}
we are looking to calculate are in
R
d
R^{d}
. With this notation, the attention task we are approximating is:
a
t
=
q
â€‹
âˆ‘
Ï„
=
1
t
k
Ï„
T
â€‹
v
Ï„
.
a_{t}=q\sum_{\tau=1}^{t}k_{\tau}^{T}v_{\tau}.
(18)
(this is still the general form of attention almost precisely equivalent toÂ (
14
), not a special case).
The goal is to show how, subject to
t
<
Î´
â€‹
n
/
log
2
â¡
n
t<\delta n/\log^{2}n
, linear attention in dimension
n
n
given byÂ (
17
) is a sufficiently precise estimation ofÂ (
18
).
Consider now, with
Î›
=
S
Î½
\Lambda=S^{\nu}
,
f
â€²
:
S
Î½
â†’
R
n
f^{\prime}:S^{\nu}\to R^{n}
, where we recall that
x
Ï„
:=
f
â€²
â€‹
(
k
Ï„
)
x_{\tau}:=f^{\prime}(k_{\tau})
, to be a suitable dimensionality reduction preserving approximation of scalar product between
R
Î½
R^{\nu}
and
R
n
R^{n}
. For simplicity of argument, we let
f
â€²
:
R
Î½
â†’
R
n
f^{\prime}:R^{\nu}\to R^{n}
be a standard Johnson-Lindenstrauss transform, with the additional property that
f
â€²
â€‹
(
âˆ’
z
)
=
âˆ’
f
â€²
â€‹
(
z
)
f^{\prime}(-z)=-f^{\prime}(z)
for all
z
âˆˆ
R
Î½
z\in R^{\nu}
(easy to obtain from any other Johnson-Lindenstrauss transform
f
â€²â€²
f^{\prime\prime}
by taking
f
â€²
â€‹
(
z
)
:=
(
f
â€²â€²
â€‹
(
z
)
âˆ’
f
â€²â€²
â€‹
(
âˆ’
z
)
)
/
2
f^{\prime}(z):=(f^{\prime\prime}(z)-f^{\prime\prime}(-z))/2
). The distortion of scalar product in
R
n
R^{n}
is then known to be bounded as follows:
|
k
Ï„
T
â€‹
k
t
âˆ’
x
Ï„
T
â€‹
x
t
|
=
O
â€‹
(
Îµ
)
â€‹
(
â€–
k
Ï„
â€–
+
â€–
k
t
â€–
)
=
O
â€‹
(
Îµ
)
|{k_{\tau}}^{T}{k_{t}}-{x_{\tau}}^{T}{x_{t}}|=O(\varepsilon)(\|k_{\tau}\|+\|k_{t}\|)=O(\varepsilon)
, w.h.p. with respect to choice of
f
â€²
f^{\prime}
. Here,
Îµ
=
log
â¡
n
/
n
=
O
â€‹
(
Î´
)
/
(
C
+
1
)
â€‹
t
â€‹
log
â¡
t
\varepsilon=\sqrt{\log n/n}=O(\sqrt{\delta})/\sqrt{(C+1)t\log t}
, where the last inequality follows from the assumption on
t
t
made in the Claim.
We now consider the sequence
r
Ï„
:=
k
Ï„
T
â€‹
k
t
âˆ’
x
Ï„
T
â€‹
x
t
r_{\tau}:={k_{\tau}}^{T}{k_{t}}-{x_{\tau}}^{T}{x_{t}}
, for
Ï„
<
t
\tau<t
. Set aside the (at most
C
C
) elements
r
Ï„
r_{\tau}
for which
k
Ï„
k_{\tau}
and
k
t
k_{t}
are not independent. For all other elements, consider that
|
r
Ï„
|
=
O
â€‹
(
Îµ
)
|r_{\tau}|=O(\varepsilon)
as established previously, and the sign
r
Ï„
/
|
r
Ï„
|
r_{\tau}/|r_{\tau}|
is chosen independently at random with respect to all but at least
C
C
elements by the conditions imposed on
f
â€²
f^{\prime}
and
k
Ï„
k_{\tau}
. It follows that
âˆ‘
Ï„
=
1
t
r
Ï„
\sum_{\tau=1}^{t}r_{\tau}
can be represented as a sum of
O
â€‹
(
C
)
O(C)
martingales, each of which has length
O
â€‹
(
t
/
(
C
+
1
)
)
O(t/(C+1))
and all elements bounded by
O
â€‹
(
Îµ
)
O(\varepsilon)
with
Îµ
=
O
â€‹
(
Î´
)
/
(
C
+
1
)
â€‹
t
â€‹
log
â¡
t
\varepsilon=O(\sqrt{\delta})/\sqrt{(C+1)t\log t}
. The Claim follows directly, by applying Azumaâ€™s inequality to each of these martingales independently.
âˆ
Considering the extreme cases of
C
=
0
C=0
and
C
=
t
âˆ’
1
C=t-1
, the above Claim leads directly to Claim
7
, clarifying over what time, linear attention can be used to express general attention.
C.3
Proof of Claim
3
Proof.
The proof is almost immediate, through the construction of an appropriate neuron-synapse interaction graphs
H
ğ”¢
H^{\mathfrak{e}}
,
H
ğ”¦
H^{\mathfrak{i}}
such that
G
ğ”¢
=
H
ğ”¢
2
â€‹
[
V
]
G^{\mathfrak{e}}={H^{\mathfrak{e}}}^{2}[V]
and
G
ğ”¦
=
H
ğ”¦
2
â€‹
[
V
]
G^{\mathfrak{i}}={H^{\mathfrak{i}}}^{2}[V]
. Consider
E
â€²
âˆˆ
(
R
+
)
2
â€‹
d
Ã—
n
E^{\prime}\in(R^{+})^{2d\times n}
such that
E
Î±
,
j
â€²
=
(
E
Î±
,
j
)
+
E^{\prime}_{\alpha,j}=\left(E_{\alpha,j}\right)^{+}
and
E
Î±
+
d
,
j
â€²
=
(
âˆ’
E
Î±
,
j
)
+
E^{\prime}_{\alpha+d,j}=\left(-E_{\alpha,j}\right)^{+}
, for
j
âˆˆ
{
1
,
â€¦
,
n
}
j\in\{1,\ldots,n\}
and
Î±
âˆˆ
{
1
,
â€¦
,
d
}
\alpha\in\{1,\ldots,d\}
. Define
D
ğ”¢
,
D
ğ”¦
âˆˆ
(
R
+
)
n
Ã—
2
â€‹
d
D^{\mathfrak{e}},D^{\mathfrak{i}}\in(R^{+})^{n\times 2d}
so that:
(
D
ğ”¢
âˆ’
D
ğ”¦
)
â€‹
E
â€²
=
D
â€‹
E
.
(D^{\mathfrak{e}}-D^{\mathfrak{i}})E^{\prime}=DE.
Indeed, notice that this is always possible by redistributing elements of
D
D
into
D
ğ”¢
D^{\mathfrak{e}}
and
D
ğ”¦
D^{\mathfrak{i}}
(putting
D
i
,
Î±
ğ”¢
=
D
i
+
d
,
Î±
ğ”¦
=
(
D
i
,
Î±
)
+
D^{\mathfrak{e}}_{i,\alpha}=D^{\mathfrak{i}}_{i+d,\alpha}=\left(D_{i,\alpha}\right)^{+}
) and
D
i
,
Î±
ğ”¦
=
D
i
+
d
,
Î±
ğ”¢
=
(
âˆ’
D
i
,
Î±
)
+
D^{\mathfrak{i}}_{i,\alpha}=D^{\mathfrak{e}}_{i+d,\alpha}=\left(-D_{i,\alpha}\right)^{+}
), so that, for all
i
,
j
âˆˆ
{
1
,
â€¦
,
n
}
i,j\in\{1,\ldots,n\}
and
Î±
âˆˆ
{
1
,
â€¦
,
d
}
\alpha\in\{1,\ldots,d\}
, we have:
(
D
i
,
Î±
ğ”¢
âˆ’
D
i
,
Î±
ğ”¦
)
â€‹
E
Î±
,
j
â€²
+
(
D
i
,
Î±
+
d
ğ”¢
âˆ’
D
i
,
Î±
+
d
ğ”¦
)
â€‹
E
Î±
+
d
,
j
â€²
=
D
i
,
Î±
â€‹
E
Î±
,
j
.
(D^{\mathfrak{e}}_{i,\alpha}-D^{\mathfrak{i}}_{i,\alpha})E^{\prime}_{\alpha,j}+(D^{\mathfrak{e}}_{i,\alpha+d}-D^{\mathfrak{i}}_{i,\alpha+d})E^{\prime}_{\alpha+d,j}=D_{i,\alpha}E_{\alpha,j}.
Considering
S
=
{
1
,
â€¦
,
2
â€‹
d
}
S=\{1,\ldots,2d\}
, the definition of
H
ğ”¢
H^{\mathfrak{e}}
as the union of edges of
D
ğ”¢
D^{\mathfrak{e}}
and
E
â€²
E^{\prime}
on input neuron layer
V
V
, hidden layer
S
S
, and output neuron layer
V
V
follows. Likewise, we define
H
ğ”¦
H^{\mathfrak{i}}
as the union of edges of
D
ğ”¦
D^{\mathfrak{i}}
and
E
â€²
E^{\prime}
.
We verify that for
G
ğ”¢
=
H
ğ”¢
2
â€‹
[
V
]
G^{\mathfrak{e}}={H^{\mathfrak{e}}}^{2}[V]
and
G
ğ”¦
=
H
ğ”¦
2
â€‹
[
V
]
G^{\mathfrak{i}}={H^{\mathfrak{i}}}^{2}[V]
, we have
G
ğ”¢
âˆ’
G
ğ”¦
=
D
â€‹
E
G^{\mathfrak{e}}-G^{\mathfrak{i}}=DE
, and the Claim holds.
âˆ
Considerations of building linear circuits.
The above proof makes the neuron-synapse interaction graphs
H
ğ”¢
H^{\mathfrak{e}}
,
H
ğ”¦
H^{\mathfrak{i}}
sparse in terms of the number of edges, as required to show that the number of parameters are preserved by correspondence. However, it is a purely technical construction, and nodes in the synaptic layer have high degree,
n
n
. While preserving strict equivalence of linear dynamics, the degrees of nodes of the considered graphs in the synaptic layer can be reduced in this construction, at the cost of increasing the number of edges of graphs
H
ğ”¢
H^{\mathfrak{e}}
,
H
ğ”¦
H^{\mathfrak{i}}
. (For example, subdividing each node of the synaptic layer into
a
2
a^{2}
nodes can be used to reduce their degree
Î˜
â€‹
(
a
)
\Theta(a)
-times, while increasing the number of edges
Î˜
â€‹
(
a
)
\Theta(a)
-times; putting
a
=
n
/
d
a=\sqrt{n/d}
we reach graphs
H
ğ”¢
H^{\mathfrak{e}}
,
H
ğ”¦
H^{\mathfrak{i}}
with degree
O
â€‹
(
n
â€‹
d
)
O(\sqrt{nd})
in both the neuron and synaptic layers, and consequently
O
â€‹
(
n
â€‹
n
â€‹
d
)
O(n\sqrt{nd})
edges.)
Reduction of internal degrees in this circuit is also possible by introducing more than 1 hidden layer, creating a form of branching circuit. The implementation for this in a distributed way remains very simple, as the considered dynamics of the form
z
â†’
G
â€‹
z
z\to Gz
are linear (token-propagation dynamics). The bound on the number of edges needed to represent such a circuit remains
O
â€‹
(
n
â€‹
d
)
O(nd)
, even when the circuit has constant degree.
The technical construction of the linear circuits
H
ğ”¢
H^{\mathfrak{e}}
,
H
ğ”¦
H^{\mathfrak{i}}
provided in this Appendix do not affect results concerning the analysis of the structure of neuron-neuron interaction graphs
G
ğ”¢
G^{\mathfrak{e}}
,
G
ğ”¦
G^{\mathfrak{i}}
. These neuron-neuron interaction graphs plausibly maintain a heavy-tailed, power-law-like degree distribution, as is the case for the models considered empirically in Section
5.5
.
C.4
Formal statement of Claim
4
Claim 9
.
Let
D
y
,
E
{D_{y}},E
be parameter matrices of BDH-Normfree. Then, there exists a graph
G
y
âˆˆ
ğ’¢
â€‹
(
n
,
O
â€‹
(
n
â€‹
d
)
)
{G_{y}}\in\mathcal{G}(n,O(nd))
, expressible through a sparse linear circuit, a graph
G
s
{G_{s}}
having
O
â€‹
(
n
â€‹
d
)
O(nd)
edges, and a sparse linear value preparation function
A
:
R
+
n
â†’
R
+
n
A:{R^{+}}^{n}\to{R^{+}}^{n}
, such that, for any sequence of keys
(
x
Ï„
,
l
)
0
â‰¤
Ï„
â‰¤
t
(x_{\tau,l})_{0\leq\tau\leq t}
and values
(
y
Ï„
,
l
âˆ’
1
)
0
â‰¤
Ï„
â‰¤
t
(y_{\tau,l-1})_{0\leq\tau\leq t}
, with
x
Ï„
,
l
,
y
Ï„
,
l
âˆ’
1
âˆˆ
R
+
n
x_{\tau,l},y_{\tau,l-1}\in{R^{+}}^{n}
, we have:
(
G
y
ğ”¢
âˆ’
G
y
ğ”¦
)
â€‹
ğˆ
t
âˆ’
1
,
l
âˆ—
â€‹
x
t
,
l
=
D
y
â€‹
E
â€‹
ğˆ
t
âˆ’
1
,
l
â€‹
x
t
,
l
,
({G_{y}}^{\mathfrak{e}}-{G_{y}}^{\mathfrak{i}}){\boldsymbol{\sigma}}^{*}_{t-1,l}x_{t,l}={D_{y}}E{\boldsymbol{\sigma}}_{t-1,l}x_{t,l},
where
ğ›”
t
âˆ’
1
,
l
=
âˆ‘
Ï„
<
t
y
Ï„
,
l
âˆ’
1
â€‹
x
Ï„
,
l
T
â€‹
U
t
âˆ’
Ï„
{\boldsymbol{\sigma}}_{t-1,l}=\sum_{\tau<t}{y_{\tau,l-1}}{x_{\tau,l}}^{T}U^{t-\tau}
represents the attention state of BDH-Normfree following Eq.Â (
16
), and
ğ›”
t
âˆ’
1
,
l
âˆ—
=
(
âˆ‘
Ï„
<
t
A
â€‹
(
y
Ï„
,
l
âˆ’
1
)
â€‹
x
Ï„
,
l
T
â€‹
U
t
âˆ’
Ï„
)
âŠ™
G
s
{\boldsymbol{\sigma}}^{*}_{t-1,l}=\left(\sum_{\tau<t}{A(y_{\tau,l-1})}{x_{\tau,l}}^{T}U^{t-\tau}\right)\odot{G_{s}}
represents the corresponding attention state of the BDH system with sparse attention on graph
G
s
{G_{s}}
, subject to appropriate preparation of attention values using function
f
y
f_{y}
.
Before we start the proof, we make a general point about the formulation of the claim. We are considering the problem of expressing (or more generally, approximating) the matrix operator
ğˆ
t
âˆ’
1
,
l
{\boldsymbol{\sigma}}_{t-1,l}
by another, sparser one. The setting of our problem can be distilled into obtaining an equality or approximation of the form
E
â€‹
ğˆ
t
âˆ’
1
,
l
â‰ˆ
E
âˆ—
â€‹
ğˆ
t
âˆ’
1
,
l
âˆ—
E{\boldsymbol{\sigma}}_{t-1,l}\approx E^{*}{\boldsymbol{\sigma}}^{*}_{t-1,l}
, where
E
âˆˆ
R
d
Ã—
n
E\in R^{d\times n}
is a given low-rank matrix,
E
âˆ—
âˆˆ
R
d
Ã—
n
E^{*}\in R^{d\times n}
can be defined arbitrarily, and
ğˆ
âˆ—
{\boldsymbol{\sigma}}^{*}
is defined as in the statement of the Claim. If we content ourselves with an approximation, then it is possible to have
ğˆ
âˆ—
=
ğˆ
{\boldsymbol{\sigma}}^{*}={\boldsymbol{\sigma}}
(i.e., put
f
y
=
i
â€‹
d
â€‹
e
â€‹
m
f_{y}=idem
), using for example the stochastic sparsification framework of
(Achlioptas and Mcsherry,
2007
)
, or a value-dependent variant (cf. e.g.
(Krauthgamer and Sapir,
2023
)
). The samples chosen by such a framework in a value-dependent variant would lead to a graph
G
s
G_{s}
which plausibly reflects the power-law element distributions that we empirically observe in
ğˆ
{\boldsymbol{\sigma}}
.
Figure 17:
Non-uniform graph attention: interpretation of
E
â€‹
(
ğˆ
l
,
t
âŠ™
G
s
)
E({\boldsymbol{\sigma}}_{l,t}\odot G_{s})
after sparsification of graph
G
s
G_{s}
.
While the spirit of such an approximation is generally valid, we opt in the proof for a simpler, purely technical argument applicable to our specific setting, which gives a strict equality in the statement of Claim
9
subject to linear preparation of attention values with a function
A
A
. In practice, this would mean that two successive layers of BDH with sparse state are sufficient to express a layer of BDH-Normfree under this reduction.
To prove the claim, it is enough to embed the connection structure of the encoder matrix, treating it as a graph, into
G
s
{G_{s}}
.
Proof.
(of Claim
9
)
Fix arbitrarily subset
D
âŠ†
V
D\subseteq V
of neurons, with
|
D
|
=
2
â€‹
d
|D|=2d
. For the given matrix
E
âˆˆ
R
d
Ã—
n
E\in R^{d\times n}
from BDH-GPU, let
E
â€²
âˆˆ
(
R
+
)
2
â€‹
d
Ã—
n
E^{\prime}\in(R^{+})^{2d\times n}
be defined as in the proof of Claim
3
in Appendix
C.3
, and let
D
y
ğ”¢
{D_{y}}^{\mathfrak{e}}
,
D
y
ğ”¦
{D_{y}}^{\mathfrak{i}}
also be applied as in that proof for considerations of decoder
D
y
{D_{y}}
. Define the value preparation function
A
A
as the immersion of vectors over
V
V
into
D
D
using
E
â€²
E^{\prime}
. Define
G
s
{G_{s}}
to be the all-ones matrix on the
2
â€‹
d
2d
columns corresponding to
D
D
, and zeros elsewhere. Then, define
E
âˆ—
âˆˆ
R
2
â€‹
d
Ã—
n
E^{*}\in R^{2d\times n}
to be a diagonal matrix acting on its first
2
â€‹
d
2d
elements (corresponding to
D
D
), and zeros elsewhere. Setting
G
y
ğ”¢
=
D
y
ğ”¢
â€‹
E
âˆ—
{G_{y}}^{\mathfrak{e}}={D_{y}}^{\mathfrak{e}}E^{*}
and
G
y
ğ”¦
=
D
y
ğ”¦
â€‹
E
âˆ—
{G_{y}}^{\mathfrak{i}}={D_{y}}^{\mathfrak{i}}E^{*}
, we obtain the claim.
âˆ
Appendix D
Desirable properties of a local graph dynamics for language models
We outline several general criteria of computational expressiveness and computational efficiency which a distributed computing system has to meet to effectively deal with language and reasoning. For this, we take a first-principles approach, relying only on very fundamental properties which an attention-based language model appears to need to capture, and which are applicable far beyond the specific case of BDH â€” plausibly, being equally applicable to human and human-like reasoning.
18
18
18
In particular, the reader will have no doubt observed that graph settings applicable to language inference and reasoning systems, which involve task inputs spread out over time and the emergence of graph structure, are very different from graph-based frameworks which directly associate the task to solve with the communication graph (the latter case includes most considerations of: Graph Neural Networks, Graph Transformers, the LOCAL/CONGEST model of distributed computing, Approximate Message Passing systems, etc.)
Hypothesis 2
.
We expect any efficient graph-based distributed system dealing with language and reasoning using an attention-based approach to have the following characteristics:
â€¢
[No Easy Simulation] The system achieves computationally irreducible dynamics, i.e., it provides no systematic opportunity to predict the outcomes of its inference or approximate its dynamics in a numerically easier way than by running the system itself.
â€¢
[Particles Talk] The state-space dynamics of the distributed system is a non-linear interacting particle dynamics, i.e., the system does not admit an efficient representation as a non-interacting particle system, but relies on a form of non-linear evolution expressed through (at least) two-particle interactions. (Such interactions are necessary, in particular, to enable multi-point correlation analysis on language inputs, when assuming only a small number of inference steps of the system per output token.)
â€¢
[Attention Deforms Pairwise Connections] The system is capable of computing correlations between pairs of scalar variables localized at different nodes of the distributed system, and storing the state of such correlations so that the result is accessible from these two nodes. (This is plausibly needed to express attention in a state-space system.)
â€¢
[Time Dictates Structure] The communication graph of the distributed system does not, in itself, represent any specific task input to solve, but reflects a trained model (a program), whereas tasks are represented as inputs to this program, presented over time. The communication graphs used to solve language and reasoning problems are expected to display modular, scale-free structure.
A detailed discussion of the four items of the Hypothesis is provided below.
[No Easy Simulation]
â‹„
\diamond
Computational models have irreducible dynamics.
We start by recalling a general observation which is applicable to most learning systems
L
L
(machine learning models, biological systems) that have learned how to do computations: they are likely to have chosen state-space dynamics that will allow them to resolve their computational problem with the least effort during inference. In other words,
if there is a physical system
P
P
that solves a given computational problem, and if there exists a simulation
S
â€‹
(
P
)
S(P)
of this physical system that would approximate system
P
P
with less effort, the learning system
L
L
will be following the dynamics of
S
â€‹
(
P
)
S(P)
, not those of
P
P
.
We provide a few hypothetical examples for intuition, anchored in different areas of particle dynamics.
If
P
P
were the particle dynamics of electrons in a resistor network, the simulation
S
â€‹
(
P
)
S(P)
could be a calculation based on Ohmâ€™s law with a Laplacian solver â€” and we would consequently expect the dynamics of our computational system
L
L
to follow the Laplacian solver code, and not to simulate electron dynamics.
If
P
P
were the ensemble of billions of Internet users performing short walks clicking through links of the world wide web, the simulation
S
â€‹
(
P
)
S(P)
would be a calculation of aggregate behavior, reminiscent of PageRank, and we would expect
L
L
to encode the parallel dynamics of Map-Reduce matrix operations of PageRank, not the simulation of individual agents.
If
P
P
were a quantum system amenable to approximation by perturbation theory, we would expect
L
L
to simulate the (classical) calculus of this perturbation theory, and not the quantum system
P
P
directly.
Most mechanical systems admit some form of more efficient simulation, which means the the dynamics of such systems are rarely a suitable choice for neuronal models. Anecdotally, in nature, only very simple systems like the Physarum slime mold
(Jabr and Rothschild,
2012
)
rely on direct action (with hydrostatic pressure gradients) to perform their optimization process; and contemporary neuroscience research suggests that even the simplest neuronal brains do not perform their work in a similar â€œfluid-mechanicalâ€ manner.
The irreducibility of
L
L
means that this system is stretched to the limits of stability, just as a highly optimized numerical algorithm would be have been simplified and optimized to the limit of numerical stability. This relates to the limits of dimensionality reduction techniques that we have explored through a largely equivalent information-lens perspective of loss of precision and loss of information which it inflicts upon the model.
[Particles Talk]
â‹„
\diamond
Latent concept spaces arise from outcomes of particle-particle interactions.
Dynamics of systems with multiple particles moving around in a (deformable) environment fall into two broad categories, depending on the strength of interaction between different parts of the dynamics. In the simpler setting, particles can be assumed
at short time scales
to be moving in an environment unchanged by other particles â€” the concurrent action of other particles, which would change the environment, does not need to be taken into account when representing individual particle motion, nor is it necessary to consider particle-particle interactions. By contrast, in the more general setting, the dynamics of multiple particles are tightly coupled, and their dynamics need to be modeled (simulated) together.
An example of a dynamics with no coupling would be a dynamics of multiple independent random walkers, such as the previously mentioned dynamics of electricity in wires, or the dynamics of PageRank. Examples of dynamics including interactions between particles, which may either happen directly or be moderated through the environment, include cellular automata, particle method simulations and molecular simulations, or swarms of communicating agents.
The natural representation of state-space models as moving particles comes from the following interpretation. A distributed system with depth-
L
L
computations (not least BDH or the BDH-GPU model given by the state equationsÂ (
4
)) is amenable to interpretation as a system of walker particles performing an
L
L
-step walk over layers, starting at some token
t
0
t_{0}
in the input layer
0
and, in each time step
t
â‰¥
t
0
t\geq t_{0}
, either pausing (skipping a time step) or moving on to the next layer, until they reach the last layer
L
L
in some time step
t
f
t_{f}
, at which point they leave the system, contributing to the distribution of the
t
f
t_{f}
-th output token. When attempting this approach with
independent
walkers, the distribution of tokens output by such a system could be described by correlation functions following or resembling the Dyson series,
âˆ‘
Ï„
L
=
0
t
âˆ‘
Ï„
L
âˆ’
1
=
0
Ï„
L
âˆ’
1
â€¦
â€‹
âˆ‘
Ï„
1
=
0
Ï„
2
âˆ’
1
F
â€‹
(
input
â€‹
(
Ï„
1
)
,
â€¦
,
input
â€‹
(
Ï„
L
)
)
\sum_{\tau_{L}=0}^{t}\sum_{\tau_{L-1}=0}^{\tau_{L}-1}\ldots\sum_{\tau_{1}=0}^{\tau_{2}-1}F(\textrm{input}(\tau_{1}),\ldots,\textrm{input}(\tau_{L}))
. However, the output of attention (e.g., the linear attention output
a
âˆ—
a^{*}
given by equation (
4
) for BDH-GPU, or defined similarly in other state space models based on linear attention), cannot be represented as a Dyson formula when unrolling the dynamics backwards through layers (even if it looks deceptively similar at first glance). Each entry retrieved from attention is an interplay between two moments of time: the moment at which the key-value pair was entered, and the moment at which the corresponding query arrived. In consequence, the considered dynamics can be represented, in each layer, as a linear sum of two-point correlations between current time
t
t
and some point
Ï„
\tau
in the past. Thus, in the
l
l
-th layer, this recursion can (with some approximation) be unrolled into a linear combination of functions of sets of
2
l
2^{l}
input tokens (provided in the
0
-th layer), but cannot be represented through correlation functions
F
F
on smaller sets of tokens (e.g., of size linear in
l
l
). Otherwise put, a system like BDH can be described using particles performing
l
l
-step walks when
relying on intermediate elements of KV-state
ğ›”
{\boldsymbol{\sigma}}
, which are produced during interactions with other walker particles in intermediate layers, but needs to be viewed through at least
2
l
2^{l}
-point correlation functions defined directly on input tokens in the input layer.
The considered point is relevant because it
precludes many forms of modeling of attention-based language dynamics, in particular those using non-interacting particle theories
. The precluded approaches include:
â€¢
L
L
-grams,
word2vec
-like
L
L
-skip-grams
(Mikolov etÂ al.,
2013
)
, as well as any other
L
L
-point correlations of past input tokens.
â€¢
L
L
-step non-interacting random walk models (walks inside the network structure, which move from input layers towards output layers across time).
â€¢
systems known to be equivalent to the above, such as approximations of classical spin-chain systems by means of Feynman integral path lengths bounded by
L
L
(Kalev and Hen,
2025
)
, and many forms of graph/GNN kernels based on
L
L
-th powers of the graph Laplacian.
â€¢
by extension,
L
L
-layer state-space systems which perform excessive compression (size reduction) of their state, in a way which eliminates most long-term correlations.
We can ask if this requirement for communication between particles is an artifact of the construction of BDH (and similarly, of the Transformer), or if it comes from a genuine need related to language and reasoning tasks. For language problems
per se
, the need for multi-point token correlation in
L
L
-layer language modeling plausibly follows from the expectation that the model should have the ability to create a syntax tree of a sentence by means of a single quick parallel scan over words in this sentence. With this assumption, the depth
L
L
of computation used to build a language syntax tree should be sufficient to represent the number of
levels
of the syntax tree that the model is able to process naturally, but can be (and in general, should plausibly be) much smaller than the number of
leaves
(words) of this syntax tree. This is consistent with the RASP-L-based understanding of the Transformerâ€™s capabilities, which allows for expressing depth-L trees in a depth-L Transformer.
19
19
19
This does not mean the problem is easy; synthetic problems inspired by this type of tree problem were (for us) among the hardest to train into a Transformer with no Chain-of-Thought â€” as compared to RASP-L problems described in
(Zhou etÂ al.,
2024
)
and others we tested.
Such a way of mapping the tree structure of problems into the modelâ€™s layers, from bottom to top, also essentially captures the â€œgenerativeâ€ nature of the considered models, which rely on concept spaces created and stored in state in intermediate layers, to guide both language comprehension and reasoning on language. Thus, the ability to handle language syntax trees efficiently, in itself, precludes the previously-mentioned types of modeling approaches.
[Attention Deforms Pairwise Connections]
â‹„
\diamond
The interaction process
X
â€‹
(
i
)
,
Y
â€‹
(
j
)
â†’
Ïƒ
â€‹
(
i
,
j
)
X(i),Y(j)\to\sigma(i,j)
describes attention.
The preceding discussion in paragraph [Particles Talk] grounds state-of-the-art state-space language models in the world of interacting particle systems.
Whenever the global vector-based description of a state-space model calls for a three-point operation, such as the trilinear operation of key-value-query attention, this translates into the nature of pairwise (for polynomial interaction terms, degree-two) non-linear particle interactions in the transition equations of the same model when described at the level of particles. Notably, at scale,
the state-space transition equations of an attention-based model plausibly involve altering or deforming correlation strength between pairs of particles, with such pairs being represented as interaction variables in the state of the system
. This requirement on structure, repeated across layers, can be seen as sufficient: interactions of particle pairs are about the only requirement on non-linear rulesets that the system needs to be support, as demonstrated by the simple local transition rules of BDH.
Overall, the statement â€œattention is all you needâ€, which describes a system-level global property,
translates into â€œ
X
â€‹
(
i
)
,
Y
â€‹
(
j
)
â†’
Ïƒ
â€‹
(
i
,
j
)
{X(i),Y(j)\to\sigma(i,j)}
is all you needâ€ at the level of particle dynamics of a state-space language model.
[Time Dictates Structure]
â‹„
\diamond
Inputs to reasoning problems are sequential, not graph-based.
Many real-world graphs are anchored in a spatial embedding of their nodes which is given by external constraints. For example, the structure of many social and transportation networks is impacted by the geographical placement of people and infrastructure on the globe.
In designing the dynamics for BDH, we are free from such spatial constraints. The graph topology corresponding to the model is free to take the shape needed to best resolve the problem. The problem itself is encoded as a sequence of tokens which arrive over time to the model (we take here a state-space view of the system).
We can naturally presume that the structure of the model graph of BDH is shaped in a way which follows from two aspects: this temporal encoding of information, and from the abstract (Platonic) latent space of concepts needed to deal with language and reasoning.
When looking for the right particle dynamics for language models, it seems reasonable to discard all
unnecessary
aspects of spatial constraints.
One example of a particle interaction system which includes externally imposed constraints on the structure of the state space is that of cellular automata operating on a two-dimensional grid. While 2D cellular automata have appealed to public imagination, appearing in attempts to observe the emergence of intelligence at least since the 1970â€™s, they are, in fact, an extremely cumbersome choice for representing in-context reasoning or language for any attention-based model. State-of-the-art language models seem to have no structural need for a low-dimensional grid in their dynamics. Arguably, the connection structure which needs to emerge in a graph system, allowing it to work efficiently in a setting of efficient information search
is precisely the opposite: it is a multi-scale, expander-like system of shortcuts, cf. e.g.
(Fraigniaud and Giakkoupis,
2010
)
. This scale-free graph structure is expected to correspond to the scale-free temporal behavior observed in natural systems
(He etÂ al.,
2010
)
.
In the rest of this paragraph we briefly review other areas of computer science, and how they relate to the particle dynamics we are looking for in terms of their relationship to handling temporal inputs and the constraints they impose on the structure of the state-space.
The freedom of choice of graph topology in solving problems around language and in-context reasoning, which we are dealing with here, can be contrasted with settings in which the graph is, at the same time, part of the system dynamics (encoding interactions in the system) and a part of the statement of the problem input. This is particularly true for models of distributed computing inspired by computer networking (LOCAL, CONGEST, etc.) and other forms of interaction networks (Approximate Message Passing, quantum LOCC, etc.), where the same graph
G
G
represents the communication network for the dynamics, and encodes the problem input â€” with the required output being some function of
G
G
(e.g., a clustering, coloring, spanning tree, etc.). Some distributed problems on graphs can be formulated so that the input and required output are independent of the graph structure, the notable ones being: majority consensus, leader election, information broadcasting, and computing aggregates. For such problems, the graph represents only a communication system, whose topology is more an obstacle to overcome, than an actual help in solving the problem. This applies also to architectures in Machine Learning which adhere to a known graph structure, such as Graph Neural Networks or Graph Transformers, when solving problems whose inputs are not naturally embedded in such a structure.
A handful of approaches in distributed computing are intended to describe systems which compute a function of an input signal which, like language, is spread out sequentially over time, and where computations happen while this signal is still arriving. In particular, some forms of particle dynamics can be distilled from the theory of self-stabilizing systems
(Dolev,
2000
)
, giving rise to settings where the system is expected to adapt its state in response to a time-changing input (see e.g.
(Boczkowski etÂ al.,
2019
)
).
Among distributed streaming frameworks, one approach which, owing to its design, admits an elegant particle-based interpretation for time-changing inputs, is the incremental computing framework
(McSherry etÂ al.,
2013
)
. This framework emphasizes temporal commutativity, and is well suited to expressing dynamics of non-interacting particles, such as PageRank-like computation performed incrementally with Map-Reduce on time-changing graphs, or building nearest-neighbor indexes on sets of changing vectors. It does not naturally extend to the non-linear particle-particle interaction dynamics that appear in the context of attention (see paragraph [Particles Talk]).
Appendix E
BDH-GPU PyTorch code listing
The code listing below implements BDH-GPU (Definition
4
) for PyTorch version 2.7. It is self-contained, except for the implementation of RoPE which needs to be filled by the user. With respect to the state dynamics ofÂ Eq.Â (
8
), it provides an extension supporting heads. The placement of layer norms and residual connections is modified with respect toÂ Eq.Â (
8
); in general, this aspect offers some flexibility.
This implementation assumes the simplest case of a fixed context window of length
T
T
. An unbounded context window is technically supported using a state-space kernel for Linear Attention, and works best following appropriate adaptation of the model for truncated backpropagation through time (see Appendix
B.2
).
â¬‡
import
torch
import
torch
.
nn
.
functional
as
F
from
torch
import
nn
D
=
256
#
internal
dimension
H
=
4
#
heads
N
=
32768
#
neurons
L
=
6
#
layers
dropout
=
0.05
vocab_size
=
256
class
BDH_GPU
(
nn
.
Module
):
def
__init__
(
self
):
self
.
ln
=
nn
.
LayerNorm
(
D
,
elementwise_affine
=
False
,
bias
=
False
)
self
.
wte
=
nn
.
Embedding
(
vocab_size
,
D
)
self
.
drop
=
nn
.
Dropout
(
dropout
)
self
.
encoder
=
nn
.
Parameter
(
torch
.
zeros
((
N
,
D
)).
normal_
(
std
=0.02)
)
self
.
decoder_x
=
nn
.
Parameter
(
torch
.
zeros
((
H
,
D
,
N
//
H
)).
normal_
(
std
=0.02)
)
self
.
decoder_y
=
nn
.
Parameter
(
torch
.
zeros
((
H
,
D
,
N
//
H
)).
normal_
(
std
=0.02)
)
self
.
readout
=
nn
.
Parameter
(
torch
.
zeros
((
D
,
vocab_size
)).
normal_
(
std
=0.02)
)
self
.
attn
=
LinearAttention
()
def
forward
(
self
,
idx
):
B
,
T
=
idx
.
size
()
#
mini-batch
dimensions
v_ast
=
self
.
ln
(
self
.
wte
(
idx
).
unsqueeze
(1))
#
B,
1,
T,
D
for
_
in
range
(
L
):
x
=
F
.
relu
(
v_ast
@
self
.
decoder_x
)
#
B,
H,
T,
N//H
a_ast
=
self
.
attn
(
Q
=
x
,
K
=
x
,
V
=
v_ast
,
)
y
=
F
.
relu
(
self
.
ln
(
a_ast
)
@
self
.
decoder_y
)
*
x
#
B,
H,
T,
N//H
y
=
y
.
transpose
(1,
2).
reshape
(
B
,
1,
T
,
N
)
y
=
self
.
drop
(
y
)
#
Start
of
layer
with
vectors
x,
y
v_ast
=
v_ast
+
self
.
ln
(
y
@
self
.
encoder
)
#
B,
1,
T,
D
v_ast
=
self
.
ln
(
v_ast
)
return
v_ast
.
squeeze
(1)
@
self
.
readout
#
B,
T,
vocab_size
class
LinearAttention
(
nn
.
Module
):
def
forward
(
Q
,
K
,
V
):
Qr
=
RoPE
(
Q
)
Kr
=
RoPE
(
K
)
return
(
Qr
@
Kr
.
mT
).
tril
(
diagonal
=-1)
@
V
Generated  on Tue Sep 30 16:50:07 2025 by
L
a
T
e
XML